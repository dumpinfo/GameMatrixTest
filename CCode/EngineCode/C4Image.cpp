 

#include "C4Image.h"
#include "C4Computation.h"


using namespace C4;


namespace
{
	enum
	{
		kHorizonMapRadius			= 16,
		kAmbientOcclusionRadius		= 16
	};


	const unsigned_int8 bleedOffsetData[426] =
	{
		0x01, 0x00, 0x00, 0x01, 0x01, 0x01,
		0x02, 0x00, 0x02, 0x01, 0x00, 0x02, 0x01, 0x02, 0x02, 0x02,
		0x03, 0x00, 0x03, 0x01, 0x03, 0x02, 0x00, 0x03, 0x01, 0x03, 0x02, 0x03,
		0x04, 0x00, 0x04, 0x01, 0x04, 0x02, 0x03, 0x03, 0x00, 0x04, 0x01, 0x04, 0x02, 0x04,
		0x05, 0x00, 0x05, 0x01, 0x05, 0x02, 0x04, 0x03, 0x05, 0x03, 0x03, 0x04, 0x04, 0x04, 0x00, 0x05, 0x01, 0x05, 0x02, 0x05, 0x03, 0x05,
		0x06, 0x00, 0x06, 0x01, 0x06, 0x02, 0x06, 0x03, 0x05, 0x04, 0x04, 0x05, 0x00, 0x06, 0x01, 0x06, 0x02, 0x06, 0x03, 0x06,
		0x07, 0x00, 0x07, 0x01, 0x07, 0x02, 0x07, 0x03, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x04, 0x06, 0x05, 0x06, 0x00, 0x07, 0x01, 0x07, 0x02, 0x07, 0x03, 0x07,
		0x08, 0x00, 0x08, 0x01, 0x08, 0x02, 0x08, 0x03, 0x07, 0x04, 0x08, 0x04, 0x07, 0x05, 0x06, 0x06, 0x04, 0x07, 0x05, 0x07, 0x00, 0x08, 0x01, 0x08, 0x02, 0x08, 0x03, 0x08, 0x04, 0x08,
		0x09, 0x00, 0x09, 0x01, 0x09, 0x02, 0x09, 0x03, 0x09, 0x04, 0x08, 0x05, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x05, 0x08, 0x00, 0x09, 0x01, 0x09, 0x02, 0x09, 0x03, 0x09, 0x04, 0x09,
		0x0A, 0x00, 0x0A, 0x01, 0x0A, 0x02, 0x0A, 0x03, 0x0A, 0x04, 0x09, 0x05, 0x08, 0x06, 0x09, 0x06, 0x08, 0x07, 0x06, 0x08, 0x07, 0x08, 0x05, 0x09, 0x06, 0x09, 0x00, 0x0A, 0x01, 0x0A, 0x02, 0x0A, 0x03, 0x0A, 0x04, 0x0A,
		0x0B, 0x00, 0x0B, 0x01, 0x0B, 0x02, 0x0B, 0x03, 0x0B, 0x04, 0x0A, 0x05, 0x0A, 0x06, 0x09, 0x07, 0x08, 0x08, 0x07, 0x09, 0x05, 0x0A, 0x06, 0x0A, 0x00, 0x0B, 0x01, 0x0B, 0x02, 0x0B, 0x03, 0x0B, 0x04, 0x0B,
		0x0C, 0x00, 0x0C, 0x01, 0x0C, 0x02, 0x0C, 0x03, 0x0C, 0x04, 0x0B, 0x05, 0x0B, 0x06, 0x0A, 0x07, 0x09, 0x08, 0x0A, 0x08, 0x08, 0x09, 0x09, 0x09, 0x07, 0x0A, 0x08, 0x0A, 0x05, 0x0B, 0x06, 0x0B, 0x00, 0x0C, 0x01, 0x0C, 0x02, 0x0C, 0x03, 0x0C, 0x04, 0x0C,
		0x0D, 0x00, 0x0D, 0x01, 0x0D, 0x02, 0x0D, 0x03, 0x0D, 0x04, 0x0C, 0x05, 0x0D, 0x05, 0x0C, 0x06, 0x0B, 0x07, 0x0C, 0x07, 0x0B, 0x08, 0x0A, 0x09, 0x09, 0x0A, 0x07, 0x0B, 0x08, 0x0B, 0x05, 0x0C, 0x06, 0x0C, 0x07, 0x0C, 0x00, 0x0D, 0x01, 0x0D, 0x02, 0x0D, 0x03, 0x0D, 0x04, 0x0D, 0x05, 0x0D,
		0x0E, 0x00, 0x0E, 0x01, 0x0E, 0x02, 0x0E, 0x03, 0x0E, 0x04, 0x0E, 0x05, 0x0D, 0x06, 0x0D, 0x07, 0x0C, 0x08, 0x0B, 0x09, 0x0A, 0x0A, 0x0B, 0x0A, 0x09, 0x0B, 0x0A, 0x0B, 0x08, 0x0C, 0x06, 0x0D, 0x07, 0x0D, 0x00, 0x0E, 0x01, 0x0E, 0x02, 0x0E, 0x03, 0x0E, 0x04, 0x0E, 0x05, 0x0E,
		0x0F, 0x00, 0x0F, 0x01, 0x0F, 0x02, 0x0F, 0x03, 0x0F, 0x04, 0x0F, 0x05, 0x0E, 0x06, 0x0E, 0x07, 0x0D, 0x08, 0x0C, 0x09, 0x0D, 0x09, 0x0C, 0x0A, 0x0B, 0x0B, 0x09, 0x0C, 0x0A, 0x0C, 0x08, 0x0D, 0x09, 0x0D, 0x06, 0x0E, 0x07, 0x0E, 0x00, 0x0F, 0x01, 0x0F, 0x02, 0x0F, 0x03, 0x0F, 0x04, 0x0F, 0x05, 0x0F
	};


	const int8 horizonAngleRange[(kHorizonMapRadius * 2 + 1) * (kHorizonMapRadius * 2 + 1)][2] =
	{
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-9, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -6}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-10, -10}, {-10, -9}, {-9, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -6}, {-6, -5}, {-5, -5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-11, -10}, {-11, -10}, {-10, -10}, {-10, -9}, {-10, -9}, {-9, -9}, {-9, -8}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-7, -6}, {-6, -6}, {-6, -5}, {-6, -5}, {-5, -5}, {-5, -4}, {-5, -4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-11, -11}, {-11, -11}, {-11, -10}, {-10, -10}, {-10, -10}, {-10, -9}, {-9, -9}, {-9, -8}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-7, -6}, {-6, -6}, {-6, -5}, {-5, -5}, {-5, -5}, {-5, -4}, {-4, -4}, {-4, -4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-12, -11}, {-11, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -10}, {-10, -9}, {-10, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -5}, {-6, -5}, {-5, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -4}, {-4, -3}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -10}, {-10, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -5}, {-5, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {-13, -12}, {-12, -12}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -11}, {-11, -10}, {-10, -10}, {-10, -9}, {-10, -9}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-6, -5}, {-6, -5}, {-5, -5}, {-5, -4}, {-4, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {-3, -3}, {-3, -2}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {-13, -12}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -9}, {-10, -9}, {-9, -8}, {-9, -8}, {-8, -7}, {-7, -6}, {-7, -6}, {-6, -5}, {-6, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-3, -2}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {-13, -13}, {-13, -13}, {-13, -13}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -9}, {-9, -8}, {-9, -8}, {-8, -7}, {-7, -6}, {-7, -6}, {-6, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-2, -2}, {-2, -2}, {-2, -2}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {-14, -13}, {-14, -13}, {-13, -13}, {-13, -13}, {-13, -12}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -10}, {-10, -9}, {-10, -9}, {-9, -8}, {-8, -7}, {-7, -6}, {-6, -5}, {-6, -5}, {-5, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-3, -2}, {-2, -2}, {-2, -2}, {-2, -1}, {-2, -1}, {0, 0}, {0, 0},
		{0, 0}, {-14, -14}, {-14, -14}, {-14, -13}, {-14, -13}, {-14, -13}, {-13, -13}, {-13, -13}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -11}, {-11, -10}, {-11, -10}, {-10, -9}, {-9, -8}, {-8, -7}, {-7, -6}, {-6, -5}, {-5, -4}, {-5, -4}, {-4, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-2, -2}, {-2, -2}, {-2, -1}, {-2, -1}, {-2, -1}, {-1, -1}, {-1, -1}, {0, 0},
		{0, 0}, {-14, -14}, {-14, -14}, {-14, -14}, {-14, -14}, {-14, -13}, {-14, -13}, {-14, -13}, {-14, -13}, {-13, -12}, {-13, -12}, {-13, -12}, {-12, -11}, {-11, -10}, {-11, -9}, {-10, -8}, {-8, -7}, {-7, -5}, {-6, -4}, {-5, -4}, {-4, -3}, {-3, -2}, {-3, -2}, {-3, -2}, {-2, -1}, {-2, -1}, {-2, -1}, {-2, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {0, 0},
		{0, 0}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-14, -14}, {-14, -14}, {-14, -13}, {-14, -13}, {-14, -13}, {-14, -13}, {-13, -12}, {-13, -12}, {-12, -11}, {-11, -10}, {-10, -8}, {-9, -6}, {-7, -5}, {-5, -4}, {-4, -3}, {-3, -2}, {-3, -2}, {-2, -1}, {-2, -1}, {-2, -1}, {-2, -1}, {-1, -1}, {-1, -1}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {0, 0},
		{0, 0}, {-15, -15}, {-15, -15}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-14, -13}, {-14, -13}, {-14, -12}, {-13, -12}, {-13, -10}, {-11, -8}, {-9, -6}, {-7, -4}, {-5, -2}, {-3, -2}, {-3, -1}, {-2, -1}, {-2, -1}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -13}, {-15, -13}, {-15, -12}, {-14, -9}, {-11, -4}, {-6, -1}, {-3, 0}, {-2, 0}, {-2, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {14, 17}, {14, 17}, {12, 19}, {0, 0}, {-3, 3}, {-1, 1}, {-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {13, 15}, {13, 15}, {12, 15}, {9, 14}, {4, 11}, {1, 6}, {0, 3}, {0, 2}, {0, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {15, 15}, {15, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {13, 14}, {13, 14}, {12, 14}, {12, 13}, {10, 13}, {8, 11}, {6, 9}, {4, 7}, {2, 5}, {2, 3}, {1, 3}, {1, 2}, {1, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 14}, {14, 14}, {13, 14}, {13, 14}, {13, 14}, {13, 14}, {12, 13}, {12, 13}, {11, 12}, {10, 11}, {8, 10}, {6, 9}, {5, 7}, {4, 5}, {3, 4}, {2, 3}, {2, 3}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0},
		{0, 0}, {14, 14}, {14, 14}, {14, 14}, {14, 14}, {13, 14}, {13, 14}, {13, 14}, {13, 14}, {12, 13}, {12, 13}, {12, 13}, {11, 12}, {10, 11}, {9, 11}, {8, 10}, {7, 8}, {5, 7}, {4, 6}, {4, 5}, {3, 4}, {2, 3}, {2, 3}, {2, 3}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {1, 1}, {1, 1}, {0, 0},
		{0, 0}, {14, 14}, {14, 14}, {13, 14}, {13, 14}, {13, 14}, {13, 13}, {13, 13}, {12, 13}, {12, 13}, {12, 12}, {11, 12}, {10, 11}, {10, 11}, {9, 10}, {8, 9}, {7, 8}, {6, 7}, {5, 6}, {4, 5}, {4, 5}, {3, 4}, {3, 3}, {2, 3}, {2, 3}, {2, 2}, {2, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {0, 0},
		{0, 0}, {0, 0}, {13, 14}, {13, 14}, {13, 13}, {13, 13}, {12, 13}, {12, 13}, {12, 13}, {12, 12}, {11, 12}, {11, 11}, {10, 11}, {9, 10}, {9, 10}, {8, 9}, {7, 8}, {6, 7}, {5, 6}, {5, 6}, {4, 5}, {4, 4}, {3, 4}, {3, 3}, {2, 3}, {2, 3}, {2, 3}, {2, 2}, {2, 2}, {1, 2}, {1, 2}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {13, 13}, {13, 13}, {13, 13}, {12, 13}, {12, 13}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {10, 11}, {10, 11}, {9, 10}, {8, 9}, {8, 9}, {7, 8}, {6, 7}, {6, 7}, {5, 6}, {4, 5}, {4, 5}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {2, 3}, {2, 3}, {2, 2}, {2, 2}, {2, 2}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {12, 13}, {12, 13}, {12, 13}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {10, 11}, {10, 11}, {9, 10}, {9, 10}, {8, 9}, {8, 9}, {7, 8}, {6, 7}, {6, 7}, {5, 6}, {5, 6}, {4, 5}, {4, 5}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {2, 3}, {2, 3}, {2, 3}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {12, 13}, {12, 12}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {11, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 10}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {5, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 4}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {3, 3}, {2, 3}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {11, 11}, {10, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 5}, {4, 4}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {11, 12}, {11, 11}, {11, 11}, {10, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 5}, {4, 4}, {4, 4}, {3, 4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {11, 11}, {11, 11}, {10, 11}, {10, 10}, {10, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 5}, {5, 5}, {4, 5}, {4, 4}, {4, 4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {10, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {10, 10}, {9, 10}, {9, 9}, {9, 9}, {8, 9}, {8, 8}, {8, 8}, {7, 8}, {7, 7}, {7, 7}, {6, 7}, {6, 6}, {6, 6}, {5, 6}, {5, 5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {9, 9}, {9, 9}, {8, 9}, {8, 8}, {8, 8}, {7, 8}, {7, 7}, {7, 7}, {6, 7}, {6, 6}, {6, 6}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}
	};

	const float horizonDeltaAngle[(kHorizonMapRadius * 2 + 1) * (kHorizonMapRadius * 2 + 1)][2] =
	{
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-1.8925468F, 0.0446915F}, {-1.8313987F, 0.0455172F}, {-1.7681919F, 0.046192F}, {-1.7033478F, 0.0466929F}, {-1.6373645F, 0.0470013F}, {-1.5707963F, 0.0471055F}, {-1.5042281F, 0.0470013F}, {-1.4382448F, 0.0466929F}, {-1.3734008F, 0.046192F}, {-1.3101938F, 0.0455172F}, {-1.2490457F, 0.0446915F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.0344438F, 0.0451446F}, {-1.975688F, 0.0463905F}, {-1.9138202F, 0.0475292F}, {-1.8490959F, 0.048526F}, {-1.7818896F, 0.0493463F}, {-1.7126933F, 0.0499583F}, {-1.6421037F, 0.0503367F}, {-1.5707963F, 0.0504646F}, {-1.4994888F, 0.0503367F}, {-1.4288992F, 0.0499583F}, {-1.3597029F, 0.0493463F}, {-1.2924966F, 0.048526F}, {-1.2277723F, 0.0475292F}, {-1.1659045F, 0.0463905F}, {-1.1071487F, 0.0451446F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.176341F, 0.0446915F}, {-2.1224513F, 0.0462909F}, {-2.0647377F, 0.0478546F}, {-2.0032041F, 0.0493463F}, {-1.9379701F, 0.0507236F}, {-1.8692952F, 0.0519406F}, {-1.7975951F, 0.0529502F}, {-1.7234456F, 0.0537085F}, {-1.6475682F, 0.0541794F}, {-1.5707963F, 0.0543391F}, {-1.4940243F, 0.0541794F}, {-1.4181469F, 0.0537085F}, {-1.3439974F, 0.0529502F}, {-1.2722973F, 0.0519406F}, {-1.2036224F, 0.0507236F}, {-1.1383885F, 0.0493463F}, {-1.0768549F, 0.0478546F}, {-1.0191413F, 0.0462909F}, {-0.9652516F, 0.0446915F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.2655346F, 0.0452369F}, {-2.2142975F, 0.0471055F}, {-2.1587989F, 0.0489897F}, {-2.0988707F, 0.0508546F}, {-2.0344438F, 0.0526558F}, {-1.9655874F, 0.0543391F}, {-1.8925468F, 0.0558434F}, {-1.815775F, 0.0571039F}, {-1.7359449F, 0.0580585F}, {-1.6539375F, 0.0586546F}, {-1.5707963F, 0.0588574F}, {-1.487655F, 0.0586546F}, {-1.4056476F, 0.0580585F}, {-1.3258177F, 0.0571039F}, {-1.2490457F, 0.0558434F}, {-1.1760052F, 0.0543391F}, {-1.1071487F, 0.0526558F}, {-1.0427218F, 0.0508546F}, {-0.9827936F, 0.0489897F}, {-0.9272952F, 0.0471055F}, {-0.8760579F, 0.0452369F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.3561944F, 0.0454232F}, {-2.3086113F, 0.0475292F}, {-2.2565257F, 0.0497107F}, {-2.1995925F, 0.0519406F}, {-2.1375255F, 0.0541794F}, {-2.0701429F, 0.0563733F}, {-1.9974237F, 0.0584537F}, {-1.9195673F, 0.0603388F}, {-1.8370484F, 0.0619379F}, {-1.7506498F, 0.0631613F}, {-1.6614562F, 0.0639311F}, {-1.5707963F, 0.064194F}, {-1.4801363F, 0.0639311F}, {-1.3909428F, 0.0631613F}, {-1.3045443F, 0.0619379F}, {-1.2220252F, 0.0603388F}, {-1.1441688F, 0.0584537F}, {-1.0714496F, 0.0563733F}, {-1.004067F, 0.0541794F}, {-0.942F, 0.0519406F}, {-0.8850667F, 0.0497107F}, {-0.8329812F, 0.0475292F}, {-0.7853981F, 0.0454232F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.4468543F, 0.0452369F}, {-2.4037775F, 0.0475292F}, {-2.3561944F, 0.0499583F}, {-2.3036115F, 0.0525104F}, {-2.2455372F, 0.0551596F}, {-2.1815223F, 0.0578637F}, {-2.1112158F, 0.0605597F}, {-2.0344438F, 0.0631613F}, {-1.9513026F, 0.065559F}, {-1.862253F, 0.0676251F}, {-1.7681919F, 0.0692266F}, {-1.6704649F, 0.0702439F}, {-1.5707963F, 0.0705931F}, {-1.4711276F, 0.0702439F}, {-1.3734008F, 0.0692266F}, {-1.2793395F, 0.0676251F}, {-1.19029F, 0.065559F}, {-1.1071487F, 0.0631613F}, {-1.0303767F, 0.0605597F}, {-0.9600703F, 0.0578637F}, {-0.8960553F, 0.0551596F}, {-0.8379812F, 0.0525104F}, {-0.7853981F, 0.0499583F}, {-0.737815F, 0.0475292F}, {-0.6947382F, 0.0452369F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.5360479F, 0.0446915F}, {-2.4980914F, 0.0471055F}, {-2.4558632F, 0.0497107F}, {-2.4087774F, 0.0525104F}, {-2.3561944F, 0.0554984F}, {-2.2974386F, 0.0586546F}, {-2.2318394F, 0.0619379F}, {-2.1587989F, 0.0652791F}, {-2.0778949F, 0.0685725F}, {-1.9890207F, 0.0716727F}, {-1.8925468F, 0.074398F}, {-1.7894653F, 0.0765465F}, {-1.6814535F, 0.0779286F}, {-1.5707963F, 0.0784063F}, {-1.4601391F, 0.0779286F}, {-1.3521274F, 0.0765465F}, {-1.2490457F, 0.074398F}, {-1.152572F, 0.0716727F}, {-1.0636978F, 0.0685725F}, {-0.9827936F, 0.0652791F}, {-0.909753F, 0.0619379F}, {-0.844154F, 0.0586546F}, {-0.7853981F, 0.0554984F}, {-0.732815F, 0.0525104F}, {-0.6857295F, 0.0497107F}, {-0.643501F, 0.0471055F}, {-0.6055446F, 0.0446915F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {-2.5899376F, 0.0462909F}, {-2.55359F, 0.0489897F}, {-2.5127964F, 0.0519406F}, {-2.4668517F, 0.0551596F}, {-2.4149503F, 0.0586546F}, {-2.3561944F, 0.0624186F}, {-2.2896263F, 0.0664211F}, {-2.2142975F, 0.0705931F}, {-2.1293957F, 0.0748132F}, {-2.0344438F, 0.0788928F}, {-1.9295669F, 0.0825723F}, {-1.815775F, 0.08554F}, {-1.6951513F, 0.0874818F}, {-1.5707963F, 0.0881592F}, {-1.4464412F, 0.0874818F}, {-1.3258177F, 0.08554F}, {-1.2120256F, 0.0825723F}, {-1.1071487F, 0.0788928F}, {-1.012197F, 0.0748132F}, {-0.9272952F, 0.0705931F}, {-0.8519662F, 0.0664211F}, {-0.7853981F, 0.0624186F}, {-0.7266423F, 0.0586546F}, {-0.6747409F, 0.0551596F}, {-0.6287962F, 0.0519406F}, {-0.5880025F, 0.0489897F}, {-0.5516549F, 0.0462909F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {-2.6779451F, 0.0451446F}, {-2.6476511F, 0.0478546F}, {-2.6135182F, 0.0508546F}, {-2.5748634F, 0.0541794F}, {-2.5308666F, 0.0578637F}, {-2.4805495F, 0.0619379F}, {-2.4227626F, 0.0664211F}, {-2.3561944F, 0.0713074F}, {-2.2794225F, 0.0765465F}, {-2.1910457F, 0.082015F}, {-2.0899424F, 0.0874818F}, {-1.975688F, 0.0925822F}, {-1.8490959F, 0.0968247F}, {-1.7126933F, 0.0996686F}, {-1.5707963F, 0.1006736F}, {-1.4288992F, 0.0996686F}, {-1.2924966F, 0.0968247F}, {-1.1659045F, 0.0925822F}, {-1.0516501F, 0.0874818F}, {-0.9505468F, 0.082015F}, {-0.86217F, 0.0765465F}, {-0.7853981F, 0.0713074F}, {-0.71883F, 0.0664211F}, {-0.6610431F, 0.0619379F}, {-0.6107258F, 0.0578637F}, {-0.5667291F, 0.0541794F}, {-0.5280743F, 0.0508546F}, {-0.4939413F, 0.0478546F}, {-0.4636476F, 0.0451446F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {-2.7367007F, 0.0463905F}, {-2.7091848F, 0.0493463F}, {-2.6779451F, 0.0526558F}, {-2.642246F, 0.0563733F}, {-2.6011731F, 0.0605597F}, {-2.55359F, 0.0652791F}, {-2.4980914F, 0.0705931F}, {-2.4329664F, 0.0765465F}, {-2.3561944F, 0.0831412F}, {-2.2655346F, 0.0902895F}, {-2.1587989F, 0.0977455F}, {-2.0344438F, 0.1050213F}, {-1.8925468F, 0.1113409F}, {-1.7359449F, 0.1157281F}, {-1.5707963F, 0.11731F}, {-1.4056476F, 0.1157281F}, {-1.2490457F, 0.1113409F}, {-1.1071487F, 0.1050213F}, {-0.9827936F, 0.0977455F}, {-0.8760579F, 0.0902895F}, {-0.7853981F, 0.0831412F}, {-0.7086262F, 0.0765465F}, {-0.643501F, 0.0705931F}, {-0.5880025F, 0.0652791F}, {-0.5404194F, 0.0605597F}, {-0.4993467F, 0.0563733F}, {-0.4636476F, 0.0526558F}, {-0.4324077F, 0.0493463F}, {-0.4048917F, 0.0463905F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {-2.8198421F, 0.0446915F}, {-2.7985687F, 0.0475292F}, {-2.7744188F, 0.0507236F}, {-2.7468016F, 0.0543391F}, {-2.7149651F, 0.0584537F}, {-2.6779451F, 0.0631613F}, {-2.634494F, 0.0685725F}, {-2.5829932F, 0.0748132F}, {-2.5213432F, 0.082015F}, {-2.4468543F, 0.0902895F}, {-2.3561944F, 0.0996686F}, {-2.2455372F, 0.1099858F}, {-2.1112158F, 0.1206785F}, {-1.9513026F, 0.1305594F}, {-1.7681919F, 0.1377961F}, {-1.5707963F, 0.1404896F}, {-1.3734008F, 0.1377961F}, {-1.19029F, 0.1305594F}, {-1.0303767F, 0.1206785F}, {-0.8960553F, 0.1099858F}, {-0.7853981F, 0.0996686F}, {-0.6947382F, 0.0902895F}, {-0.6202495F, 0.082015F}, {-0.5585992F, 0.0748132F}, {-0.5070984F, 0.0685725F}, {-0.4636476F, 0.0631613F}, {-0.4266273F, 0.0584537F}, {-0.3947911F, 0.0543391F}, {-0.3671737F, 0.0507236F}, {-0.3430238F, 0.0475292F}, {-0.3217505F, 0.0446915F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {-2.8809902F, 0.0455172F}, {-2.8632929F, 0.048526F}, {-2.8430936F, 0.0519406F}, {-2.8198421F, 0.0558434F}, {-2.7928216F, 0.0603388F}, {-2.7610862F, 0.065559F}, {-2.7233684F, 0.0716727F}, {-2.6779451F, 0.0788928F}, {-2.6224465F, 0.0874818F}, {-2.55359F, 0.0977455F}, {-2.4668517F, 0.1099858F}, {-2.3561944F, 0.1243549F}, {-2.2142975F, 0.1404896F}, {-2.0344438F, 0.1568156F}, {-1.815775F, 0.1698462F}, {-1.5707963F, 0.1749689F}, {-1.3258177F, 0.1698462F}, {-1.1071487F, 0.1568156F}, {-0.9272952F, 0.1404896F}, {-0.7853981F, 0.1243549F}, {-0.6747409F, 0.1099858F}, {-0.5880025F, 0.0977455F}, {-0.519146F, 0.0874818F}, {-0.4636476F, 0.0788928F}, {-0.4182243F, 0.0716727F}, {-0.3805062F, 0.065559F}, {-0.3487709F, 0.0603388F}, {-0.3217505F, 0.0558434F}, {-0.2984988F, 0.0519406F}, {-0.2782995F, 0.048526F}, {-0.2606023F, 0.0455172F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {-2.9441971F, 0.046192F}, {-2.9304993F, 0.0493463F}, {-2.9147937F, 0.0529502F}, {-2.896614F, 0.0571039F}, {-2.8753407F, 0.0619379F}, {-2.8501358F, 0.0676251F}, {-2.8198421F, 0.074398F}, {-2.7828218F, 0.0825723F}, {-2.7367007F, 0.0925822F}, {-2.6779451F, 0.1050213F}, {-2.6011731F, 0.1206785F}, {-2.4980914F, 0.1404896F}, {-2.3561944F, 0.1651486F}, {-2.1587989F, 0.1936582F}, {-1.8925468F, 0.2199879F}, {-1.5707963F, 0.2314772F}, {-1.2490457F, 0.2199879F}, {-0.9827936F, 0.1936582F}, {-0.7853981F, 0.1651486F}, {-0.643501F, 0.1404896F}, {-0.5404194F, 0.1206785F}, {-0.4636476F, 0.1050213F}, {-0.4048917F, 0.0925822F}, {-0.3587706F, 0.0825723F}, {-0.3217505F, 0.074398F}, {-0.2914566F, 0.0676251F}, {-0.266252F, 0.0619379F}, {-0.2449786F, 0.0571039F}, {-0.2267987F, 0.0529502F}, {-0.2110933F, 0.0493463F}, {-0.1973955F, 0.046192F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {-3.009041F, 0.0466929F}, {-2.99969F, 0.0499583F}, {-2.9889433F, 0.0537085F}, {-2.976444F, 0.0580585F}, {-2.961739F, 0.0631613F}, {-2.9441971F, 0.0692266F}, {-2.9229238F, 0.0765465F}, {-2.896614F, 0.08554F}, {-2.8632929F, 0.0968247F}, {-2.8198421F, 0.1113409F}, {-2.7610862F, 0.1305594F}, {-2.6779451F, 0.1568156F}, {-2.55359F, 0.1936582F}, {-2.3561944F, 0.2449785F}, {-2.0344438F, 0.3062773F}, {-1.5707963F, 0.3398368F}, {-1.1071487F, 0.3062773F}, {-0.7853981F, 0.2449785F}, {-0.5880025F, 0.1936582F}, {-0.4636476F, 0.1568156F}, {-0.3805062F, 0.1305594F}, {-0.3217505F, 0.1113409F}, {-0.2782995F, 0.0968247F}, {-0.2449786F, 0.08554F}, {-0.2186689F, 0.0765465F}, {-0.1973955F, 0.0692266F}, {-0.1798534F, 0.0631613F}, {-0.1651486F, 0.0580585F}, {-0.1526492F, 0.0537085F}, {-0.1418969F, 0.0499583F}, {-0.1325514F, 0.0466929F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {-3.0750246F, 0.0470013F}, {-3.070285F, 0.0503367F}, {-3.0648207F, 0.0541794F}, {-3.0584514F, 0.0586546F}, {-3.0509328F, 0.0639311F}, {-3.0419239F, 0.0702439F}, {-3.0309355F, 0.0779286F}, {-3.0172376F, 0.0874818F}, {-2.99969F, 0.0996686F}, {-2.976444F, 0.1157281F}, {-2.9441971F, 0.1377961F}, {-2.896614F, 0.1698462F}, {-2.8198421F, 0.2199879F}, {-2.6779451F, 0.3062773F}, {-2.3561944F, 0.4636474F}, {-1.5707963F, 0.6154797F}, {-0.7853981F, 0.4636474F}, {-0.4636476F, 0.3062773F}, {-0.3217505F, 0.2199879F}, {-0.2449786F, 0.1698462F}, {-0.1973955F, 0.1377961F}, {-0.1651486F, 0.1157281F}, {-0.1418969F, 0.0996686F}, {-0.1243549F, 0.0874818F}, {-0.1106572F, 0.0779286F}, {-0.0996686F, 0.0702439F}, {-0.0906598F, 0.0639311F}, {-0.0831412F, 0.0586546F}, {-0.0767718F, 0.0541794F}, {-0.0713074F, 0.0503367F}, {-0.0665681F, 0.0470013F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {3.1415927F, 0.0471055F}, {3.1415927F, 0.0504646F}, {3.1415927F, 0.0543391F}, {3.1415927F, 0.0588574F}, {3.1415927F, 0.064194F}, {3.1415927F, 0.0705931F}, {3.1415927F, 0.0784063F}, {3.1415927F, 0.0881592F}, {3.1415927F, 0.1006736F}, {3.1415927F, 0.11731F}, {3.1415927F, 0.1404896F}, {3.1415927F, 0.1749689F}, {3.1415927F, 0.2314772F}, {3.1415927F, 0.3398368F}, {3.1415927F, 0.6154797F}, {0.0F, 0.0F}, {0.0F, 0.6154797F}, {0.0F, 0.3398368F}, {0.0F, 0.2314772F}, {0.0F, 0.1749689F}, {0.0F, 0.1404896F}, {0.0F, 0.11731F}, {0.0F, 0.1006736F}, {0.0F, 0.0881592F}, {0.0F, 0.0784063F}, {0.0F, 0.0705931F}, {0.0F, 0.064194F}, {0.0F, 0.0588574F}, {0.0F, 0.0543391F}, {0.0F, 0.0504646F}, {0.0F, 0.0471055F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {3.0750246F, 0.0470013F}, {3.070285F, 0.0503367F}, {3.0648207F, 0.0541794F}, {3.0584514F, 0.0586546F}, {3.0509328F, 0.0639311F}, {3.0419239F, 0.0702439F}, {3.0309355F, 0.0779286F}, {3.0172376F, 0.0874818F}, {2.99969F, 0.0996686F}, {2.976444F, 0.1157281F}, {2.9441971F, 0.1377961F}, {2.896614F, 0.1698462F}, {2.8198421F, 0.2199879F}, {2.6779451F, 0.3062773F}, {2.3561944F, 0.4636474F}, {1.5707963F, 0.6154797F}, {0.7853981F, 0.4636474F}, {0.4636476F, 0.3062773F}, {0.3217505F, 0.2199879F}, {0.2449786F, 0.1698462F}, {0.1973955F, 0.1377961F}, {0.1651486F, 0.1157281F}, {0.1418969F, 0.0996686F}, {0.1243549F, 0.0874818F}, {0.1106572F, 0.0779286F}, {0.0996686F, 0.0702439F}, {0.0906598F, 0.0639311F}, {0.0831412F, 0.0586546F}, {0.0767718F, 0.0541794F}, {0.0713074F, 0.0503367F}, {0.0665681F, 0.0470013F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {3.009041F, 0.0466929F}, {2.99969F, 0.0499583F}, {2.9889433F, 0.0537085F}, {2.976444F, 0.0580585F}, {2.961739F, 0.0631613F}, {2.9441971F, 0.0692266F}, {2.9229238F, 0.0765465F}, {2.896614F, 0.08554F}, {2.8632929F, 0.0968247F}, {2.8198421F, 0.1113409F}, {2.7610862F, 0.1305594F}, {2.6779451F, 0.1568156F}, {2.55359F, 0.1936582F}, {2.3561944F, 0.2449785F}, {2.0344438F, 0.3062773F}, {1.5707963F, 0.3398368F}, {1.1071487F, 0.3062773F}, {0.7853981F, 0.2449785F}, {0.5880025F, 0.1936582F}, {0.4636476F, 0.1568156F}, {0.3805062F, 0.1305594F}, {0.3217505F, 0.1113409F}, {0.2782995F, 0.0968247F}, {0.2449786F, 0.08554F}, {0.2186689F, 0.0765465F}, {0.1973955F, 0.0692266F}, {0.1798534F, 0.0631613F}, {0.1651486F, 0.0580585F}, {0.1526492F, 0.0537085F}, {0.1418969F, 0.0499583F}, {0.1325514F, 0.0466929F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {2.9441971F, 0.046192F}, {2.9304993F, 0.0493463F}, {2.9147937F, 0.0529502F}, {2.896614F, 0.0571039F}, {2.8753407F, 0.0619379F}, {2.8501358F, 0.0676251F}, {2.8198421F, 0.074398F}, {2.7828218F, 0.0825723F}, {2.7367007F, 0.0925822F}, {2.6779451F, 0.1050213F}, {2.6011731F, 0.1206785F}, {2.4980914F, 0.1404896F}, {2.3561944F, 0.1651486F}, {2.1587989F, 0.1936582F}, {1.8925468F, 0.2199879F}, {1.5707963F, 0.2314772F}, {1.2490457F, 0.2199879F}, {0.9827936F, 0.1936582F}, {0.7853981F, 0.1651486F}, {0.643501F, 0.1404896F}, {0.5404194F, 0.1206785F}, {0.4636476F, 0.1050213F}, {0.4048917F, 0.0925822F}, {0.3587706F, 0.0825723F}, {0.3217505F, 0.074398F}, {0.2914566F, 0.0676251F}, {0.266252F, 0.0619379F}, {0.2449786F, 0.0571039F}, {0.2267987F, 0.0529502F}, {0.2110933F, 0.0493463F}, {0.1973955F, 0.046192F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {2.8809902F, 0.0455172F}, {2.8632929F, 0.048526F}, {2.8430936F, 0.0519406F}, {2.8198421F, 0.0558434F}, {2.7928216F, 0.0603388F}, {2.7610862F, 0.065559F}, {2.7233684F, 0.0716727F}, {2.6779451F, 0.0788928F}, {2.6224465F, 0.0874818F}, {2.55359F, 0.0977455F}, {2.4668517F, 0.1099858F}, {2.3561944F, 0.1243549F}, {2.2142975F, 0.1404896F}, {2.0344438F, 0.1568156F}, {1.815775F, 0.1698462F}, {1.5707963F, 0.1749689F}, {1.3258177F, 0.1698462F}, {1.1071487F, 0.1568156F}, {0.9272952F, 0.1404896F}, {0.7853981F, 0.1243549F}, {0.6747409F, 0.1099858F}, {0.5880025F, 0.0977455F}, {0.519146F, 0.0874818F}, {0.4636476F, 0.0788928F}, {0.4182243F, 0.0716727F}, {0.3805062F, 0.065559F}, {0.3487709F, 0.0603388F}, {0.3217505F, 0.0558434F}, {0.2984988F, 0.0519406F}, {0.2782995F, 0.048526F}, {0.2606023F, 0.0455172F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {2.8198421F, 0.0446915F}, {2.7985687F, 0.0475292F}, {2.7744188F, 0.0507236F}, {2.7468016F, 0.0543391F}, {2.7149651F, 0.0584537F}, {2.6779451F, 0.0631613F}, {2.634494F, 0.0685725F}, {2.5829932F, 0.0748132F}, {2.5213432F, 0.082015F}, {2.4468543F, 0.0902895F}, {2.3561944F, 0.0996686F}, {2.2455372F, 0.1099858F}, {2.1112158F, 0.1206785F}, {1.9513026F, 0.1305594F}, {1.7681919F, 0.1377961F}, {1.5707963F, 0.1404896F}, {1.3734008F, 0.1377961F}, {1.19029F, 0.1305594F}, {1.0303767F, 0.1206785F}, {0.8960553F, 0.1099858F}, {0.7853981F, 0.0996686F}, {0.6947382F, 0.0902895F}, {0.6202495F, 0.082015F}, {0.5585992F, 0.0748132F}, {0.5070984F, 0.0685725F}, {0.4636476F, 0.0631613F}, {0.4266273F, 0.0584537F}, {0.3947911F, 0.0543391F}, {0.3671737F, 0.0507236F}, {0.3430238F, 0.0475292F}, {0.3217505F, 0.0446915F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {2.7367007F, 0.0463905F}, {2.7091848F, 0.0493463F}, {2.6779451F, 0.0526558F}, {2.642246F, 0.0563733F}, {2.6011731F, 0.0605597F}, {2.55359F, 0.0652791F}, {2.4980914F, 0.0705931F}, {2.4329664F, 0.0765465F}, {2.3561944F, 0.0831412F}, {2.2655346F, 0.0902895F}, {2.1587989F, 0.0977455F}, {2.0344438F, 0.1050213F}, {1.8925468F, 0.1113409F}, {1.7359449F, 0.1157281F}, {1.5707963F, 0.11731F}, {1.4056476F, 0.1157281F}, {1.2490457F, 0.1113409F}, {1.1071487F, 0.1050213F}, {0.9827936F, 0.0977455F}, {0.8760579F, 0.0902895F}, {0.7853981F, 0.0831412F}, {0.7086262F, 0.0765465F}, {0.643501F, 0.0705931F}, {0.5880025F, 0.0652791F}, {0.5404194F, 0.0605597F}, {0.4993467F, 0.0563733F}, {0.4636476F, 0.0526558F}, {0.4324077F, 0.0493463F}, {0.4048917F, 0.0463905F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {2.6779451F, 0.0451446F}, {2.6476511F, 0.0478546F}, {2.6135182F, 0.0508546F}, {2.5748634F, 0.0541794F}, {2.5308666F, 0.0578637F}, {2.4805495F, 0.0619379F}, {2.4227626F, 0.0664211F}, {2.3561944F, 0.0713074F}, {2.2794225F, 0.0765465F}, {2.1910457F, 0.082015F}, {2.0899424F, 0.0874818F}, {1.975688F, 0.0925822F}, {1.8490959F, 0.0968247F}, {1.7126933F, 0.0996686F}, {1.5707963F, 0.1006736F}, {1.4288992F, 0.0996686F}, {1.2924966F, 0.0968247F}, {1.1659045F, 0.0925822F}, {1.0516501F, 0.0874818F}, {0.9505468F, 0.082015F}, {0.86217F, 0.0765465F}, {0.7853981F, 0.0713074F}, {0.71883F, 0.0664211F}, {0.6610431F, 0.0619379F}, {0.6107258F, 0.0578637F}, {0.5667291F, 0.0541794F}, {0.5280743F, 0.0508546F}, {0.4939413F, 0.0478546F}, {0.4636476F, 0.0451446F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.5899376F, 0.0462909F}, {2.55359F, 0.0489897F}, {2.5127964F, 0.0519406F}, {2.4668517F, 0.0551596F}, {2.4149503F, 0.0586546F}, {2.3561944F, 0.0624186F}, {2.2896263F, 0.0664211F}, {2.2142975F, 0.0705931F}, {2.1293957F, 0.0748132F}, {2.0344438F, 0.0788928F}, {1.9295669F, 0.0825723F}, {1.815775F, 0.08554F}, {1.6951513F, 0.0874818F}, {1.5707963F, 0.0881592F}, {1.4464412F, 0.0874818F}, {1.3258177F, 0.08554F}, {1.2120256F, 0.0825723F}, {1.1071487F, 0.0788928F}, {1.012197F, 0.0748132F}, {0.9272952F, 0.0705931F}, {0.8519662F, 0.0664211F}, {0.7853981F, 0.0624186F}, {0.7266423F, 0.0586546F}, {0.6747409F, 0.0551596F}, {0.6287962F, 0.0519406F}, {0.5880025F, 0.0489897F}, {0.5516549F, 0.0462909F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.5360479F, 0.0446915F}, {2.4980914F, 0.0471055F}, {2.4558632F, 0.0497107F}, {2.4087774F, 0.0525104F}, {2.3561944F, 0.0554984F}, {2.2974386F, 0.0586546F}, {2.2318394F, 0.0619379F}, {2.1587989F, 0.0652791F}, {2.0778949F, 0.0685725F}, {1.9890207F, 0.0716727F}, {1.8925468F, 0.074398F}, {1.7894653F, 0.0765465F}, {1.6814535F, 0.0779286F}, {1.5707963F, 0.0784063F}, {1.4601391F, 0.0779286F}, {1.3521274F, 0.0765465F}, {1.2490457F, 0.074398F}, {1.152572F, 0.0716727F}, {1.0636978F, 0.0685725F}, {0.9827936F, 0.0652791F}, {0.909753F, 0.0619379F}, {0.844154F, 0.0586546F}, {0.7853981F, 0.0554984F}, {0.732815F, 0.0525104F}, {0.6857295F, 0.0497107F}, {0.643501F, 0.0471055F}, {0.6055446F, 0.0446915F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, 
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.4468543F, 0.0452369F}, {2.4037775F, 0.0475292F}, {2.3561944F, 0.0499583F}, {2.3036115F, 0.0525104F}, {2.2455372F, 0.0551596F}, {2.1815223F, 0.0578637F}, {2.1112158F, 0.0605597F}, {2.0344438F, 0.0631613F}, {1.9513026F, 0.065559F}, {1.862253F, 0.0676251F}, {1.7681919F, 0.0692266F}, {1.6704649F, 0.0702439F}, {1.5707963F, 0.0705931F}, {1.4711276F, 0.0702439F}, {1.3734008F, 0.0692266F}, {1.2793395F, 0.0676251F}, {1.19029F, 0.065559F}, {1.1071487F, 0.0631613F}, {1.0303767F, 0.0605597F}, {0.9600703F, 0.0578637F}, {0.8960553F, 0.0551596F}, {0.8379812F, 0.0525104F}, {0.7853981F, 0.0499583F}, {0.737815F, 0.0475292F}, {0.6947382F, 0.0452369F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.3561944F, 0.0454232F}, {2.3086113F, 0.0475292F}, {2.2565257F, 0.0497107F}, {2.1995925F, 0.0519406F}, {2.1375255F, 0.0541794F}, {2.0701429F, 0.0563733F}, {1.9974237F, 0.0584537F}, {1.9195673F, 0.0603388F}, {1.8370484F, 0.0619379F}, {1.7506498F, 0.0631613F}, {1.6614562F, 0.0639311F}, {1.5707963F, 0.064194F}, {1.4801363F, 0.0639311F}, {1.3909428F, 0.0631613F}, {1.3045443F, 0.0619379F}, {1.2220252F, 0.0603388F}, {1.1441688F, 0.0584537F}, {1.0714496F, 0.0563733F}, {1.004067F, 0.0541794F}, {0.942F, 0.0519406F}, {0.8850667F, 0.0497107F}, {0.8329812F, 0.0475292F}, {0.7853981F, 0.0454232F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.2655346F, 0.0452369F}, {2.2142975F, 0.0471055F}, {2.1587989F, 0.0489897F}, {2.0988707F, 0.0508546F}, {2.0344438F, 0.0526558F}, {1.9655874F, 0.0543391F}, {1.8925468F, 0.0558434F}, {1.815775F, 0.0571039F}, {1.7359449F, 0.0580585F}, {1.6539375F, 0.0586546F}, {1.5707963F, 0.0588574F}, {1.487655F, 0.0586546F}, {1.4056476F, 0.0580585F}, {1.3258177F, 0.0571039F}, {1.2490457F, 0.0558434F}, {1.1760052F, 0.0543391F}, {1.1071487F, 0.0526558F}, {1.0427218F, 0.0508546F}, {0.9827936F, 0.0489897F}, {0.9272952F, 0.0471055F}, {0.8760579F, 0.0452369F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, 
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.176341F, 0.0446915F}, {2.1224513F, 0.0462909F}, {2.0647377F, 0.0478546F}, {2.0032041F, 0.0493463F}, {1.9379701F, 0.0507236F}, {1.8692952F, 0.0519406F}, {1.7975951F, 0.0529502F}, {1.7234456F, 0.0537085F}, {1.6475682F, 0.0541794F}, {1.5707963F, 0.0543391F}, {1.4940243F, 0.0541794F}, {1.4181469F, 0.0537085F}, {1.3439974F, 0.0529502F}, {1.2722973F, 0.0519406F}, {1.2036224F, 0.0507236F}, {1.1383885F, 0.0493463F}, {1.0768549F, 0.0478546F}, {1.0191413F, 0.0462909F}, {0.9652516F, 0.0446915F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {2.0344438F, 0.0451446F}, {1.975688F, 0.0463905F}, {1.9138202F, 0.0475292F}, {1.8490959F, 0.048526F}, {1.7818896F, 0.0493463F}, {1.7126933F, 0.0499583F}, {1.6421037F, 0.0503367F}, {1.5707963F, 0.0504646F}, {1.4994888F, 0.0503367F}, {1.4288992F, 0.0499583F}, {1.3597029F, 0.0493463F}, {1.2924966F, 0.048526F}, {1.2277723F, 0.0475292F}, {1.1659045F, 0.0463905F}, {1.1071487F, 0.0451446F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, 
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {1.8925468F, 0.0446915F}, {1.8313987F, 0.0455172F}, {1.7681919F, 0.046192F}, {1.7033478F, 0.0466929F}, {1.6373645F, 0.0470013F}, {1.5707963F, 0.0471055F}, {1.5042281F, 0.0470013F}, {1.4382448F, 0.0466929F}, {1.3734008F, 0.046192F}, {1.3101938F, 0.0455172F}, {1.2490457F, 0.0446915F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F},
		{0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}, {0.0F, 0.0F}
	}; 

 
	int8 ambientOcclusionAngleRange[(kAmbientOcclusionRadius * 2 + 1) * (kAmbientOcclusionRadius * 2 + 1)][2] = 
	{
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-9, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -6}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-10, -10}, {-10, -9}, {-9, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -6}, {-6, -5}, {-5, -5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, 
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-11, -10}, {-11, -10}, {-10, -10}, {-10, -9}, {-10, -9}, {-9, -9}, {-9, -8}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-7, -6}, {-6, -6}, {-6, -5}, {-6, -5}, {-5, -5}, {-5, -4}, {-5, -4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-11, -11}, {-11, -11}, {-11, -10}, {-10, -10}, {-10, -10}, {-10, -9}, {-9, -9}, {-9, -8}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-7, -6}, {-6, -6}, {-6, -5}, {-5, -5}, {-5, -5}, {-5, -4}, {-4, -4}, {-4, -4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {-12, -11}, {-11, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -10}, {-10, -9}, {-10, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -5}, {-6, -5}, {-5, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -4}, {-4, -3}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -10}, {-10, -9}, {-9, -9}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-6, -6}, {-6, -5}, {-5, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {-13, -12}, {-12, -12}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -11}, {-11, -10}, {-10, -10}, {-10, -9}, {-10, -9}, {-9, -8}, {-8, -8}, {-8, -7}, {-7, -7}, {-7, -6}, {-6, -5}, {-6, -5}, {-5, -5}, {-5, -4}, {-4, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {-3, -3}, {-3, -2}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {-13, -12}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -9}, {-10, -9}, {-9, -8}, {-9, -8}, {-8, -7}, {-7, -6}, {-7, -6}, {-6, -5}, {-6, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-3, -2}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {-13, -13}, {-13, -13}, {-13, -13}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -10}, {-11, -10}, {-10, -9}, {-9, -8}, {-9, -8}, {-8, -7}, {-7, -6}, {-7, -6}, {-6, -5}, {-5, -4}, {-5, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-2, -2}, {-2, -2}, {-2, -2}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {-14, -13}, {-14, -13}, {-13, -13}, {-13, -13}, {-13, -12}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -11}, {-11, -11}, {-11, -10}, {-10, -9}, {-10, -9}, {-9, -8}, {-8, -7}, {-7, -6}, {-6, -5}, {-6, -5}, {-5, -4}, {-4, -4}, {-4, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-3, -2}, {-2, -2}, {-2, -2}, {-2, -1}, {-2, -1}, {0, 0}, {0, 0},
		{0, 0}, {-14, -14}, {-14, -14}, {-14, -13}, {-14, -13}, {-14, -13}, {-13, -13}, {-13, -13}, {-13, -12}, {-13, -12}, {-12, -12}, {-12, -11}, {-11, -10}, {-11, -10}, {-10, -9}, {-9, -8}, {-8, -7}, {-7, -6}, {-6, -5}, {-5, -4}, {-5, -4}, {-4, -3}, {-3, -3}, {-3, -2}, {-3, -2}, {-2, -2}, {-2, -2}, {-2, -1}, {-2, -1}, {-2, -1}, {-1, -1}, {-1, -1}, {0, 0},
		{0, 0}, {-14, -14}, {-14, -14}, {-14, -14}, {-14, -14}, {-14, -13}, {-14, -13}, {-14, -13}, {-14, -13}, {-13, -12}, {-13, -12}, {-13, -12}, {-12, -11}, {-11, -10}, {-11, -9}, {-10, -8}, {-8, -7}, {-7, -5}, {-6, -4}, {-5, -4}, {-4, -3}, {-3, -2}, {-3, -2}, {-3, -2}, {-2, -1}, {-2, -1}, {-2, -1}, {-2, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {0, 0},
		{0, 0}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-14, -14}, {-14, -14}, {-14, -13}, {-14, -13}, {-14, -13}, {-14, -13}, {-13, -12}, {-13, -12}, {-12, -11}, {-11, -10}, {-10, -8}, {-9, -6}, {-7, -5}, {-5, -4}, {-4, -3}, {-3, -2}, {-3, -2}, {-2, -1}, {-2, -1}, {-2, -1}, {-2, -1}, {-1, -1}, {-1, -1}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {0, 0},
		{0, 0}, {-15, -15}, {-15, -15}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-14, -13}, {-14, -13}, {-14, -12}, {-13, -12}, {-13, -10}, {-11, -8}, {-9, -6}, {-7, -4}, {-5, -2}, {-3, -2}, {-3, -1}, {-2, -1}, {-2, -1}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -15}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -14}, {-15, -13}, {-15, -13}, {-15, -12}, {-14, -9}, {-11, -4}, {-6, -1}, {-3, 0}, {-2, 0}, {-2, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {15, 16}, {14, 17}, {14, 17}, {12, 19}, {0, 0}, {-3, 3}, {-1, 1}, {-1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {13, 15}, {13, 15}, {12, 15}, {9, 14}, {4, 11}, {1, 6}, {0, 3}, {0, 2}, {0, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {15, 15}, {15, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {13, 14}, {13, 14}, {12, 14}, {12, 13}, {10, 13}, {8, 11}, {6, 9}, {4, 7}, {2, 5}, {2, 3}, {1, 3}, {1, 2}, {1, 2}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {14, 15}, {14, 15}, {14, 15}, {14, 15}, {14, 14}, {14, 14}, {13, 14}, {13, 14}, {13, 14}, {13, 14}, {12, 13}, {12, 13}, {11, 12}, {10, 11}, {8, 10}, {6, 9}, {5, 7}, {4, 5}, {3, 4}, {2, 3}, {2, 3}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 0},
		{0, 0}, {14, 14}, {14, 14}, {14, 14}, {14, 14}, {13, 14}, {13, 14}, {13, 14}, {13, 14}, {12, 13}, {12, 13}, {12, 13}, {11, 12}, {10, 11}, {9, 11}, {8, 10}, {7, 8}, {5, 7}, {4, 6}, {4, 5}, {3, 4}, {2, 3}, {2, 3}, {2, 3}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {1, 1}, {1, 1}, {0, 0},
		{0, 0}, {14, 14}, {14, 14}, {13, 14}, {13, 14}, {13, 14}, {13, 13}, {13, 13}, {12, 13}, {12, 13}, {12, 12}, {11, 12}, {10, 11}, {10, 11}, {9, 10}, {8, 9}, {7, 8}, {6, 7}, {5, 6}, {4, 5}, {4, 5}, {3, 4}, {3, 3}, {2, 3}, {2, 3}, {2, 2}, {2, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 1}, {1, 1}, {0, 0},
		{0, 0}, {0, 0}, {13, 14}, {13, 14}, {13, 13}, {13, 13}, {12, 13}, {12, 13}, {12, 13}, {12, 12}, {11, 12}, {11, 11}, {10, 11}, {9, 10}, {9, 10}, {8, 9}, {7, 8}, {6, 7}, {5, 6}, {5, 6}, {4, 5}, {4, 4}, {3, 4}, {3, 3}, {2, 3}, {2, 3}, {2, 3}, {2, 2}, {2, 2}, {1, 2}, {1, 2}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {13, 13}, {13, 13}, {13, 13}, {12, 13}, {12, 13}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {10, 11}, {10, 11}, {9, 10}, {8, 9}, {8, 9}, {7, 8}, {6, 7}, {6, 7}, {5, 6}, {4, 5}, {4, 5}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {2, 3}, {2, 3}, {2, 2}, {2, 2}, {2, 2}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {12, 13}, {12, 13}, {12, 13}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {10, 11}, {10, 11}, {9, 10}, {9, 10}, {8, 9}, {8, 9}, {7, 8}, {6, 7}, {6, 7}, {5, 6}, {5, 6}, {4, 5}, {4, 5}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {2, 3}, {2, 3}, {2, 3}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {12, 13}, {12, 12}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {11, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 10}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {5, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 4}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {3, 3}, {2, 3}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {12, 12}, {12, 12}, {11, 12}, {11, 11}, {11, 11}, {10, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 5}, {4, 4}, {4, 4}, {3, 4}, {3, 3}, {3, 3}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {11, 12}, {11, 11}, {11, 11}, {10, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 5}, {4, 4}, {4, 4}, {3, 4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {11, 11}, {11, 11}, {10, 11}, {10, 10}, {10, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 5}, {5, 5}, {4, 5}, {4, 4}, {4, 4}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {10, 11}, {10, 11}, {10, 10}, {9, 10}, {9, 10}, {9, 9}, {8, 9}, {8, 9}, {8, 8}, {7, 8}, {7, 7}, {6, 7}, {6, 7}, {6, 6}, {5, 6}, {5, 6}, {5, 5}, {4, 5}, {4, 5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {10, 10}, {9, 10}, {9, 9}, {9, 9}, {8, 9}, {8, 8}, {8, 8}, {7, 8}, {7, 7}, {7, 7}, {6, 7}, {6, 6}, {6, 6}, {5, 6}, {5, 5}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {9, 9}, {9, 9}, {8, 9}, {8, 8}, {8, 8}, {7, 8}, {7, 7}, {7, 7}, {6, 7}, {6, 6}, {6, 6}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
		{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}
	};
}


void Image::DecompressImageRLE_RGBA32(const unsigned_int8 *code, unsigned_int32 codeSize, void *restrict output)
{
	Color4C *restrict destin = static_cast<Color4C *>(output);

	const unsigned_int8 *end = code + codeSize;
	while (code < end)
	{
		unsigned_int8 d = *code++;
		int32 count = (d & 0x7F) + 1;

		if ((d & 0x80) != 0)
		{
			Color4C		c;

			c.Set(code[2], code[1], code[0], code[3]);
			do
			{
				*destin++ = c;
			} while (--count > 0);

			code += 4;
		}
		else
		{
			do
			{
				destin->Set(code[2], code[1], code[0], code[3]);
				destin++;
				code += 4;

			} while (--count > 0);
		}
	}
}

void Image::DecompressImageRLE_XY16(const unsigned_int8 *code, unsigned_int32 codeSize, void *restrict output)
{
	Color2C *restrict destin = static_cast<Color2C *>(output);

	const unsigned_int8 *end = code + codeSize;
	while (code < end)
	{
		unsigned_int8 d = *code++;
		int32 count = (d & 0x7F) + 1;

		if ((d & 0x80) != 0)
		{
			Color2C		c;

			unsigned_int32 x = code[0];
			unsigned_int32 y = code[1];
			code += 2;

			c.Set(x, y);
			do
			{
				*destin++ = c;
			} while (--count > 0);
		}
		else
		{
			do
			{
				unsigned_int32 x = code[0];
				unsigned_int32 y = code[1];
				code += 2;

				destin->Set(x, y);
				destin++;
			} while (--count > 0);
		}
	}
}

void Image::DecompressImageRLE_X8(const unsigned_int8 *code, unsigned_int32 codeSize, void *restrict output)
{
	Color1C *restrict destin = static_cast<Color1C *>(output);

	const unsigned_int8 *end = code + codeSize;
	while (code < end)
	{
		unsigned_int8 d = *code++;
		int32 count = (d & 0x7F) + 1;

		if ((d & 0x80) != 0)
		{
			Color1C p = *code++;
			do
			{
				*destin++ = p;
			} while (--count > 0);
		}
		else
		{
			do
			{
				*destin++ = *code++;
			} while (--count > 0);
		}
	}
}

void Image::DecompressImageRLE_DEPTH16(const unsigned_int8 *code, unsigned_int32 codeSize, void *restrict output)
{
	const unsigned_int16 *source = reinterpret_cast<const unsigned_int16 *>(code);
	unsigned_int16 *restrict destin = static_cast<unsigned_int16 *>(output);

	const unsigned_int16 *end = source + codeSize / 2;
	while (source < end)
	{
		unsigned_int16 d = *source++;
		int32 count = (d & 0x7FFF) + 1;

		if ((d & 0x8000) != 0)
		{
			unsigned_int16 depth = *source++;
			do
			{
				*destin++ = depth;
			} while (--count > 0);
		}
		else
		{
			do
			{
				*destin++ = *source++;
			} while (--count > 0);
		}
	}
}

void Image::DecompressImageRLE_BC1(const unsigned_int8 *code, unsigned_int32 codeSize, void *restrict output)
{
	BC1Block *restrict destin = static_cast<BC1Block *>(output);

	const unsigned_int8 *end = code + codeSize;
	while (code < end)
	{
		unsigned_int8 d = *code++;
		int32 count = (d & 0x7F) + 1;

		if ((d & 0x80) != 0)
		{
			BC1Block	block;

			for (machine i = 0; i < 8; i++)
			{
				block.byteData[i] = code[i];
			}

			do
			{
				*destin++ = block;
			} while (--count > 0);

			code += 8;
		}
		else
		{
			do
			{
				BC1Block *block = destin++;
				for (machine i = 0; i < 8; i++)
				{
					block->byteData[i] = code[i];
				}

				code += 8;
			} while (--count > 0);
		}
	}
}

void Image::DecompressImageRLE_BC3(const unsigned_int8 *code, unsigned_int32 codeSize, void *restrict output)
{
	BC3Block *restrict destin = static_cast<BC3Block *>(output);

	const unsigned_int8 *end = code + codeSize;
	while (code < end)
	{
		unsigned_int8 d = *code++;
		int32 count = (d & 0x7F) + 1;

		if ((d & 0x80) != 0)
		{
			BC3Block	block;

			for (machine i = 0; i < 16; i++)
			{
				block.byteData[i] = code[i];
			}

			do
			{
				*destin++ = block;
			} while (--count > 0);

			code += 16;
		}
		else
		{
			do
			{
				BC3Block *block = destin++;
				for (machine i = 0; i < 16; i++)
				{
					block->byteData[i] = code[i];
				}

				code += 16;
			} while (--count > 0);
		}
	}
}

Vector3D Image::CalculateColorAxis(int32 count, const Point3D *color, const Box3D& bounds)
{
	if (bounds.min == bounds.max)
	{
		return (Vector3D(K::sqrt_3_over_3, K::sqrt_3_over_3, K::sqrt_3_over_3));
	}

	Vector3D axis = Normalize(bounds.max - bounds.min);

	float best = 0.0F;
	for (machine a = 0; a < count; a++)
	{
		Vector3D c = color[a] - bounds.min;
		float d = axis * c;
		best += SquaredMag(c) - d * d;
	}

	Point3D p(bounds.max.x, bounds.min.y, bounds.min.z);
	Point3D q(bounds.min.x, bounds.max.y, bounds.max.z);
	Vector3D v = Normalize(q - p);

	float total = 0.0F;
	for (machine a = 0; a < count; a++)
	{
		Vector3D c = color[a] - p;
		float d = v * c;
		total += SquaredMag(c) - d * d;
	}

	if (total < best)
	{
		best = total;
		axis = v;
	}

	p.Set(bounds.max.x, bounds.max.y, bounds.min.z);
	q.Set(bounds.min.x, bounds.min.y, bounds.max.z);
	v = Normalize(q - p);

	total = 0.0F;
	for (machine a = 0; a < count; a++)
	{
		Vector3D c = color[a] - p;
		float d = v * c;
		total += SquaredMag(c) - d * d;
	}

	if (total < best)
	{
		best = total;
		axis = v;
	}

	p.Set(bounds.min.x, bounds.max.y, bounds.min.z);
	q.Set(bounds.max.x, bounds.min.y, bounds.max.z);
	v = Normalize(q - p);

	total = 0.0F;
	for (machine a = 0; a < count; a++)
	{
		Vector3D c = color[a] - p;
		float d = v * c;
		total += SquaredMag(c) - d * d;
	}

	if (total < best)
	{
		return (v);
	}

	return (axis);
}

void Image::CalculateEndpointCandidates(int32 count, const Point3D *color, int32 *restrict candCount1, int32 *restrict candCount2, unsigned_int16 *restrict cand1, unsigned_int16 *restrict cand2)
{
	Box3D		bounds;

	bounds.Calculate(count, color);
	Vector3D axis = CalculateColorAxis(count, color, bounds);

	float dmin = color[0] * axis;
	float dmax = dmin;
	int32 minIndex = 0;
	int32 maxIndex = 0;

	for (machine a = 1; a < count; a++)
	{
		float d = color[a] * axis;
		if (d < dmin)
		{
			dmin = d;
			minIndex = a;
		}
		else if (d > dmax)
		{
			dmax = d;
			maxIndex = a;
		}
	}

	int32 count1 = 0;
	const Point3D& minColor = color[minIndex];

	for (float d = -K::one_over_32; d <= K::one_over_32; d += K::one_over_64)
	{
		Point3D p = minColor + axis * d;

		int32 red = MaxZero(Min((int32) (p.x * 31.0F + 0.5F), 31));
		int32 green = MaxZero(Min((int32) (p.y * 63.0F + 0.5F), 63));
		int32 blue = MaxZero(Min((int32) (p.z * 31.0F + 0.5F), 31));

		unsigned_int16 candidate = (unsigned_int16) ((red << 11) | (green << 5) | blue);
		for (machine a = 0; a < count1; a++)
		{
			if (cand1[a] == candidate)
			{
				goto next1;
			}
		}

		cand1[count1] = candidate;
		if (++count1 == 8)
		{
			break;
		}

		next1:;
	}

	int32 count2 = 0;
	const Point3D& maxColor = color[maxIndex];

	for (float d = -K::one_over_32; d <= K::one_over_32; d += K::one_over_64)
	{
		Point3D p = maxColor + axis * d;

		int32 red = MaxZero(Min((int32) (p.x * 31.0F + 0.5F), 31));
		int32 green = MaxZero(Min((int32) (p.y * 63.0F + 0.5F), 63));
		int32 blue = MaxZero(Min((int32) (p.z * 31.0F + 0.5F), 31));

		unsigned_int16 candidate = (unsigned_int16) ((red << 11) | (green << 5) | blue);
		for (machine a = 0; a < count2; a++)
		{
			if (cand2[a] == candidate)
			{
				goto next2;
			}
		}

		cand2[count2] = candidate;
		if (++count2 == 8)
		{
			break;
		}

		next2:;
	}

	*candCount1 = count1;
	*candCount2 = count2;
}

float Image::EncodeColorBlock(int32 width, int32 height, unsigned_int16 color0, unsigned_int16 color1, bool black, const Point3D *image, unsigned_int8 *restrict data)
{
	Point3D			encodeColor[4];
	unsigned_int8	encodeIndex[16];

	if (black)
	{
		if (color0 > color1)
		{
			Exchange(color0, color1);
		}
	}
	else
	{
		if (color0 < color1)
		{
			Exchange(color0, color1);
		}
	}

	data[0] = (unsigned_int8) (color0 & 0x00FF);
	data[1] = (unsigned_int8) (color0 >> 8);
	data[2] = (unsigned_int8) (color1 & 0x00FF);
	data[3] = (unsigned_int8) (color1 >> 8);
	data += 4;

	encodeColor[0].Set((float) (color0 >> 11) * K::one_over_31, (float) ((color0 >> 5) & 63) * K::one_over_63, (float) (color0 & 31) * K::one_over_31);
	encodeColor[1].Set((float) (color1 >> 11) * K::one_over_31, (float) ((color1 >> 5) & 63) * K::one_over_63, (float) (color1 & 31) * K::one_over_31);

	if (black)
	{
		encodeColor[2].x = PositiveFloor((encodeColor[0].x + encodeColor[1].x) * 127.5F) * K::one_over_255;
		encodeColor[2].y = PositiveFloor((encodeColor[0].y + encodeColor[1].y) * 127.5F) * K::one_over_255;
		encodeColor[2].z = PositiveFloor((encodeColor[0].z + encodeColor[1].z) * 127.5F) * K::one_over_255;

		encodeColor[3].Set(0.0F, 0.0F, 0.0F);
	}
	else
	{
		encodeColor[2].x = PositiveFloor((encodeColor[0].x * 2.0F + encodeColor[1].x) * (K::one_over_3 * 255.0F)) * K::one_over_255;
		encodeColor[2].y = PositiveFloor((encodeColor[0].y * 2.0F + encodeColor[1].y) * (K::one_over_3 * 255.0F)) * K::one_over_255;
		encodeColor[2].z = PositiveFloor((encodeColor[0].z * 2.0F + encodeColor[1].z) * (K::one_over_3 * 255.0F)) * K::one_over_255;

		encodeColor[3].x = PositiveFloor((encodeColor[0].x + encodeColor[1].x * 2.0F) * (K::one_over_3 * 255.0F)) * K::one_over_255;
		encodeColor[3].y = PositiveFloor((encodeColor[0].y + encodeColor[1].y * 2.0F) * (K::one_over_3 * 255.0F)) * K::one_over_255;
		encodeColor[3].z = PositiveFloor((encodeColor[0].z + encodeColor[1].z * 2.0F) * (K::one_over_3 * 255.0F)) * K::one_over_255;
	}

	for (machine a = 0; a < 4; a++)
	{
		reinterpret_cast<unsigned_int32 *>(encodeIndex)[a] = 0;
	}

	float totalError = 0.0F;
	float worstError = 0.0F;
	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			const Point3D& p = image[j * width + i];
			float best = SquaredMag(p - encodeColor[0]);

			machine k = j * 4 + i;
			for (machine a = 1; a < 4; a++)
			{
				float error = SquaredMag(p - encodeColor[a]);
				if (error < best)
				{
					best = error;
					encodeIndex[k] = (unsigned_int8) a;
				}
			}

			totalError += best;
			worstError = Fmax(worstError, best);
		}
	}

	unsigned_int8 *index = encodeIndex;
	for (machine j = 0; j < 4; j++)
	{
		unsigned_int32 code = 0;
		for (machine i = 0; i < 8; i += 2)
		{
			code |= *index++ << i;
		}

		data[j] = (unsigned_int8) code;
	}

	return (totalError - worstError);
}

void Image::CompressColorBlock(int32 width, int32 height, int32 rowLength, bool alpha, const Color4C *image, unsigned_int8 *restrict data)
{
	Point3D				colorArray[16];
	unsigned_int8		blockData[8];
	int32				candCount1;
	int32				candCount2;
	unsigned_int16		cand1[8];
	unsigned_int16		cand2[8];

	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			const Color4C& c = image[j * rowLength + i];
			colorArray[j * width + i].Set((float) c.GetRed() * K::one_over_255, (float) c.GetGreen() * K::one_over_255, (float) c.GetBlue() * K::one_over_255);
		}
	}

	CalculateEndpointCandidates(width * height, colorArray, &candCount1, &candCount2, cand1, cand2);

	float best = K::infinity;
	for (machine a = 0; a < candCount1; a++)
	{
		unsigned_int16 color0 = cand1[a];

		for (machine b = 0; b < candCount2; b++)
		{
			unsigned_int16 color1 = cand2[b];

			float error = EncodeColorBlock(width, height, color0, color1, false, colorArray, blockData);
			if (error < best)
			{
				best = error;
				for (machine d = 0; d < 8; d++)
				{
					data[d] = blockData[d];
				}
			}

			if (!alpha)
			{
				error = EncodeColorBlock(width, height, color0, color1, true, colorArray, blockData);
				if (error < best)
				{
					best = error;
					for (machine d = 0; d < 8; d++)
					{
						data[d] = blockData[d];
					}
				}
			}
		}
	}
}

void Image::CalculateEndpointCandidates(int32 count, const float *green, int32 *restrict candCount1, int32 *restrict candCount2, unsigned_int16 *restrict cand1, unsigned_int16 *restrict cand2)
{
	float dmin = green[0];
	float dmax = dmin;
	int32 minIndex = 0;
	int32 maxIndex = 0;

	for (machine a = 1; a < count; a++)
	{
		float d = green[a];
		if (d < dmin)
		{
			dmin = d;
			minIndex = a;
		}
		else if (d > dmax)
		{
			dmax = d;
			maxIndex = a;
		}
	}

	int32 count1 = 0;
	float minGreen = green[minIndex];

	for (float d = -K::one_over_32; d <= K::one_over_32; d += K::one_over_64)
	{
		float g = minGreen + d;
		int32 value = MaxZero(Min((int32) (g * 63.0F + 0.5F), 63));

		unsigned_int16 candidate = (unsigned_int16) (value << 5);
		for (machine a = 0; a < count1; a++)
		{
			if (cand1[a] == candidate)
			{
				goto next1;
			}
		}

		cand1[count1] = candidate;
		if (++count1 == 8)
		{
			break;
		}

		next1:;
	}

	int32 count2 = 0;
	float maxGreen = green[maxIndex];

	for (float d = -K::one_over_32; d <= K::one_over_32; d += K::one_over_64)
	{
		float g = maxGreen + d;
		int32 value = MaxZero(Min((int32) (g * 63.0F + 0.5F), 63));

		unsigned_int16 candidate = (unsigned_int16) (value << 5);
		for (machine a = 0; a < count2; a++)
		{
			if (cand2[a] == candidate)
			{
				goto next2;
			}
		}

		cand2[count2] = candidate;
		if (++count2 == 8)
		{
			break;
		}

		next2:;
	}

	*candCount1 = count1;
	*candCount2 = count2;
}

float Image::EncodeGreenBlock(int32 width, int32 height, unsigned_int16 color0, unsigned_int16 color1, const float *image, unsigned_int8 *restrict data)
{
	float			encodeGreen[4];
	unsigned_int8	encodeIndex[16];

	if (color0 < color1)
	{
		Exchange(color0, color1);
	}

	data[0] = (unsigned_int8) (color0 & 0x00FF);
	data[1] = (unsigned_int8) (color0 >> 8);
	data[2] = (unsigned_int8) (color1 & 0x00FF);
	data[3] = (unsigned_int8) (color1 >> 8);
	data += 4;

	encodeGreen[0] = (float) ((color0 >> 5) & 63) * K::one_over_63;
	encodeGreen[1] = (float) ((color1 >> 5) & 63) * K::one_over_63;
	encodeGreen[2] = PositiveFloor((encodeGreen[0] * 2.0F + encodeGreen[1]) * (K::one_over_3 * 255.0F)) * K::one_over_255;
	encodeGreen[3] = PositiveFloor((encodeGreen[0] + encodeGreen[1] * 2.0F) * (K::one_over_3 * 255.0F)) * K::one_over_255;

	for (machine a = 0; a < 4; a++)
	{
		reinterpret_cast<unsigned_int32 *>(encodeIndex)[a] = 0;
	}

	float totalError = 0.0F;
	float worstError = 0.0F;
	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			float g = image[j * width + i];
			float best = g - encodeGreen[0];
			best *= best;

			machine k = j * 4 + i;
			for (machine a = 1; a < 4; a++)
			{
				float error = g - encodeGreen[a];
				error *= error;
				if (error < best)
				{
					best = error;
					encodeIndex[k] = (unsigned_int8) a;
				}
			}

			totalError += best;
			worstError = Fmax(worstError, best);
		}
	}

	unsigned_int8 *index = encodeIndex;
	for (machine j = 0; j < 4; j++)
	{
		unsigned_int32 code = 0;
		for (machine i = 0; i < 8; i += 2)
		{
			code |= *index++ << i;
		}

		data[j] = (unsigned_int8) code;
	}

	return (totalError - worstError);
}

void Image::CompressGreenBlock(int32 width, int32 height, int32 rowLength, const Color4C *image, unsigned_int8 *restrict data)
{
	float				greenArray[16];
	unsigned_int8		blockData[8];
	int32				candCount1;
	int32				candCount2;
	unsigned_int16		cand1[8];
	unsigned_int16		cand2[8];

	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			greenArray[j * width + i] = image[j * rowLength + i].GetGreen() * K::one_over_255;
		}
	}

	CalculateEndpointCandidates(width * height, greenArray, &candCount1, &candCount2, cand1, cand2);

	float best = K::infinity;
	for (machine a = 0; a < candCount1; a++)
	{
		unsigned_int16 color0 = cand1[a];

		for (machine b = 0; b < candCount2; b++)
		{
			unsigned_int16 color1 = cand2[b];

			float error = EncodeGreenBlock(width, height, color0, color1, greenArray, blockData);
			if (error < best)
			{
				best = error;
				for (machine d = 0; d < 8; d++)
				{
					data[d] = blockData[d];
				}
			}
		}
	}
}

float Image::EncodeGrayBlock(int32 width, int32 height, unsigned_int8 gray0, unsigned_int8 gray1, bool black, const float *image, unsigned_int8 *restrict data)
{
	float			encodeGray[8];
	unsigned_int8	encodeIndex[16];

	if (black)
	{
		if (gray0 > gray1)
		{
			Exchange(gray0, gray1);
		}
	}
	else
	{
		if (gray0 < gray1)
		{
			Exchange(gray0, gray1);
		}
	}

	data[0] = gray0;
	data[1] = gray1;
	data += 2;

	if (gray0 == gray1)
	{
		for (machine j = 0; j < 6; j++)
		{
			data[j] = 0;
		}

		return (0.0F);
	}

	encodeGray[0] = (float) gray0 * K::one_over_255;
	encodeGray[1] = (float) gray1 * K::one_over_255;

	if (black)
	{
		encodeGray[2] = (encodeGray[0] * 4.0F + encodeGray[1]) * 0.2F;
		encodeGray[3] = (encodeGray[0] * 3.0F + encodeGray[1] * 2.0F) * 0.2F;
		encodeGray[4] = (encodeGray[0] * 2.0F + encodeGray[1] * 3.0F) * 0.2F;
		encodeGray[5] = (encodeGray[0] + encodeGray[1] * 4.0F) * 0.2F;
		encodeGray[6] = 0.0F;
		encodeGray[7] = 1.0F;
	}
	else
	{
		encodeGray[2] = (encodeGray[0] * 6.0F + encodeGray[1]) * K::one_over_7;
		encodeGray[3] = (encodeGray[0] * 5.0F + encodeGray[1] * 2.0F) * K::one_over_7;
		encodeGray[4] = (encodeGray[0] * 4.0F + encodeGray[1] * 3.0F) * K::one_over_7;
		encodeGray[5] = (encodeGray[0] * 3.0F + encodeGray[1] * 4.0F) * K::one_over_7;
		encodeGray[6] = (encodeGray[0] * 2.0F + encodeGray[1] * 5.0F) * K::one_over_7;
		encodeGray[7] = (encodeGray[0] + encodeGray[1] * 6.0F) * K::one_over_7;
	}

	for (machine a = 0; a < 4; a++)
	{
		reinterpret_cast<unsigned_int32 *>(encodeIndex)[a] = 0;
	}

	float totalError = 0.0F;
	float worstError = 0.0F;
	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			float g = image[j * width + i];
			float dg = g - encodeGray[0];
			float best = dg * dg;

			machine k = j * 4 + i;
			for (machine a = 1; a < 8; a++)
			{
				dg = g - encodeGray[a];
				float error = dg * dg;
				if (error < best)
				{
					best = error;
					encodeIndex[k] = (unsigned_int8) a;
				}
			}

			totalError += best;
			worstError = Fmax(worstError, best);
		}
	}

	unsigned_int8 *index = encodeIndex;
	for (machine j = 0; j < 6; j += 3)
	{
		unsigned_int32 code = 0;
		for (machine i = 0; i < 24; i += 3)
		{
			code |= *index++ << i;
		}

		data[j] = (unsigned_int8) (code & 0x0000FF);
		data[j + 1] = (unsigned_int8) ((code >> 8) & 0x0000FF);
		data[j + 2] = (unsigned_int8) (code >> 16);
	}

	return (totalError - worstError);
}

void Image::CompressGrayBlock(int32 width, int32 height, int32 rowLength, const unsigned_int8 *image, unsigned_int8 *restrict data)
{
	float				grayArray[16];
	unsigned_int8		grayValue[16];
	unsigned_int8		uniqueGray[16];

	for (machine a = 0; a < 4; a++)
	{
		reinterpret_cast<unsigned_int32 *>(grayValue)[a] = 0;
	}

	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			unsigned_int8 gray = image[j * rowLength + i];

			grayArray[j * width + i] = (float) gray * K::one_over_255;
			grayValue[j * 4 + i] = gray;
		}
	}

	int32 uniqueGrayCount = 0;
	for (machine j = 0; j < height; j++)
	{
		for (machine i = 0; i < width; i++)
		{
			unsigned_int8 gray = grayValue[j * 4 + i];
			for (machine a = 0; a < uniqueGrayCount; a++)
			{
				if (uniqueGray[a] == gray)
				{
					goto next;
				}
			}

			uniqueGray[uniqueGrayCount++] = gray;
			next:;
		}
	}

	if (uniqueGrayCount == 1)
	{
		data[0] = uniqueGray[0];
		for (machine a = 1; a < 8; a++)
		{
			data[a] = 0;
		}

		return;
	}

	if (uniqueGrayCount == 2)
	{
		unsigned_int8 gray0 = uniqueGray[0];
		unsigned_int8 gray1 = uniqueGray[1];
		if (gray0 < gray1)
		{
			Exchange(gray0, gray1);
		}

		data[0] = gray0;
		data[1] = gray1;
		for (machine a = 2; a < 8; a++)
		{
			data[a] = 0;
		}

		data += 2;

		const unsigned_int8 *gray = grayValue;
		for (machine j = 0; j < 6; j += 3)
		{
			unsigned_int32 code = 0;
			for (machine i = 0; i < 24; i += 3)
			{
				code |= (*gray++ == gray1) << i;
			}

			data[j] = (unsigned_int8) (code & 0x0000FF);
			data[j + 1] = (unsigned_int8) ((code >> 8) & 0x0000FF);
			data[j + 2] = (unsigned_int8) (code >> 16);
		}

		return;
	}

	float best = K::infinity;
	for (machine a = 0; a < uniqueGrayCount; a++)
	{
		unsigned_int8 gray0 = uniqueGray[a];
		for (machine b = 0; b < uniqueGrayCount; b++)
		{
			unsigned_int8 gray1 = uniqueGray[b];
			if (gray0 > gray1)
			{
				unsigned_int8	blockData[8];

				float error = EncodeGrayBlock(width, height, gray0, gray1, false, grayArray, blockData);
				if (error < best)
				{
					best = error;
					for (machine d = 0; d < 8; d++)
					{
						data[d] = blockData[d];
					}
				}

				error = EncodeGrayBlock(width, height, gray0, gray1, true, grayArray, blockData);
				if (error < best)
				{
					best = error;
					for (machine d = 0; d < 8; d++)
					{
						data[d] = blockData[d];
					}
				}
			}
		}
	}
}

void Image::BleedAlphaTestMap(int32 width, int32 height, const Rect& rect, const Color4C *source, Color4C *restrict destin, unsigned_int32 testValue)
{
	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;

	for (machine y = rect.top; y < rect.bottom; y++)
	{
		for (machine x = rect.left; x < rect.right; x++)
		{
			const Color4C& color = source[y * width + x];
			destin[y * width + x] = color;

			unsigned_int32 alpha = color.GetAlpha();
			if (alpha < testValue)
			{
				const unsigned_int8 *offset = bleedOffsetData;
				for (machine k = 0; k < 213; k++)
				{
					int32 i1 = Min(x + offset[0], widthMinus1);
					int32 i2 = MaxZero(x - offset[0]);
					int32 j1 = Min(y + offset[1], heightMinus1);
					int32 j2 = MaxZero(y - offset[1]);

					const Color4C& c1 = source[j1 * width + i1];
					if (c1.GetAlpha() >= testValue)
					{
						destin[y * width + x].Set(c1.GetRed(), c1.GetGreen(), c1.GetBlue(), alpha);
						break;
					}

					const Color4C& c2 = source[j1 * width + i2];
					if (c2.GetAlpha() >= testValue)
					{
						destin[y * width + x].Set(c2.GetRed(), c2.GetGreen(), c2.GetBlue(), alpha);
						break;
					}

					const Color4C& c3 = source[j2 * width + i1];
					if (c3.GetAlpha() >= testValue)
					{
						destin[y * width + x].Set(c3.GetRed(), c3.GetGreen(), c3.GetBlue(), alpha);
						break;
					}

					const Color4C& c4 = source[j2 * width + i2];
					if (c4.GetAlpha() >= testValue)
					{
						destin[y * width + x].Set(c4.GetRed(), c4.GetGreen(), c4.GetBlue(), alpha);
						break;
					}

					offset += 2;
				}
			}
		}
	}
}

void Image::BleedNormalMap(int32 width, int32 height, const Rect& rect, const Color4C *source, Color4C *restrict destin)
{
	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;

	for (machine y = rect.top; y < rect.bottom; y++)
	{
		for (machine x = rect.left; x < rect.right; x++)
		{
			const Color4C& color = source[y * width + x];
			destin[y * width + x] = color;

			if (color.GetPackedRGBColor() == 0)
			{
				destin[y * width + x].Set(128, 128, 255, 255);

				const unsigned_int8 *offset = bleedOffsetData;
				for (machine k = 0; k < 213; k++)
				{
					int32 i1 = Min(x + offset[0], widthMinus1);
					int32 i2 = MaxZero(x - offset[0]);
					int32 j1 = Min(y + offset[1], heightMinus1);
					int32 j2 = MaxZero(y - offset[1]);

					const Color4C& c1 = source[j1 * width + i1];
					if (c1.GetPackedRGBColor() != 0)
					{
						destin[y * width + x] = c1;
						break;
					}

					const Color4C& c2 = source[j1 * width + i2];
					if (c2.GetPackedRGBColor() != 0)
					{
						destin[y * width + x] = c2;
						break;
					}

					const Color4C& c3 = source[j2 * width + i1];
					if (c3.GetPackedRGBColor() != 0)
					{
						destin[y * width + x] = c3;
						break;
					}

					const Color4C& c4 = source[j2 * width + i2];
					if (c4.GetPackedRGBColor() != 0)
					{
						destin[y * width + x] = c4;
						break;
					}

					offset += 2;
				}
			}
		}
	}
}

void Image::CalculateNormalMap(int32 width, int32 height, const Color4C *source, Color4C *restrict destin, float scale, bool swrap, bool twrap)
{
	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;
	unsigned_int32 xmask = widthMinus1 & -(int32) swrap;
	unsigned_int32 ymask = heightMinus1 & -(int32) twrap;
	scale *= 0.5F;

	for (machine y = 0; y < height; y++)
	{
		Color4C *normal = destin + y * width;

		int32 ym1 = ((y - 1) & ymask) | (MaxZero(y - 1) & ~ymask);
		int32 yp1 = ((y + 1) & ymask) | (Min(y + 1, heightMinus1) & ~ymask);

		const Color4C *rowx = source + y * width;
		const Color4C *rowy1 = source + ym1 * width;
		const Color4C *rowy2 = source + yp1 * width;

		for (machine x = 0; x < width; x++)
		{
			int32 xm1 = ((x - 1) & xmask) | (MaxZero(x - 1) & ~xmask);
			int32 xp1 = ((x + 1) & xmask) | (Min(x + 1, widthMinus1) & ~xmask);

			float h = (float) rowx[xm1].GetRed() * K::one_over_255;
			float dhx = ((float) rowx[xp1].GetRed() * K::one_over_255 - h) * scale;

			h = (float) rowy1[x].GetRed() * K::one_over_255;
			float dhy = ((float) rowy2[x].GetRed() * K::one_over_255 - h) * scale;

			float m = InverseSqrt(dhx * dhx + dhy * dhy + 1.0F) * 127.0F;
			int32 red = Min(Max((int32) (-dhx * m), -127), 127) + 128;
			int32 green = Min(Max((int32) (-dhy * m), -127), 127) + 128;
			int32 blue = Min(Max((int32) m, -127), 127) + 128;
			normal[x].Set(red, green, blue, rowx[x].GetAlpha());
		}
	}
}

void Image::CalculateXYNormalMap(int32 width, int32 height, const Color4C *source, Color4C *restrict destin, float scale, bool swrap, bool twrap)
{
	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;
	unsigned_int32 xmask = widthMinus1 & -(int32) swrap;
	unsigned_int32 ymask = heightMinus1 & -(int32) twrap;
	scale *= 0.5F;

	for (machine y = 0; y < height; y++)
	{
		Color4C *normal = destin + y * width;

		int32 ym1 = ((y - 1) & ymask) | (MaxZero(y - 1) & ~ymask);
		int32 yp1 = ((y + 1) & ymask) | (Min(y + 1, heightMinus1) & ~ymask);

		const Color4C *rowx = source + y * width;
		const Color4C *rowy1 = source + ym1 * width;
		const Color4C *rowy2 = source + yp1 * width;

		for (machine x = 0; x < width; x++)
		{
			int32 xm1 = ((x - 1) & xmask) | (MaxZero(x - 1) & ~xmask);
			int32 xp1 = ((x + 1) & xmask) | (Min(x + 1, widthMinus1) & ~xmask);

			float h = (float) rowx[xm1].GetRed() * K::one_over_255;
			float dhx = ((float) rowx[xp1].GetRed() * K::one_over_255 - h) * scale;

			h = (float) rowy1[x].GetRed() * K::one_over_255;
			float dhy = ((float) rowy2[x].GetRed() * K::one_over_255 - h) * scale;

			float m = InverseSqrt(dhx * dhx + dhy * dhy + 1.0F) * 127.0F;
			int32 alpha = Min(Max((int32) (-dhx * m), -127), 127) + 128;
			int32 green = Min(Max((int32) (-dhy * m), -127), 127) + 128;
			normal[x].Set(0, green, 0, alpha);
		}
	}
}

void Image::CalculateParallaxMap(int32 width, int32 height, const Color4C *source, Color4C *restrict destin, float scale, bool swrap, bool twrap)
{
	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;
	unsigned_int32 xmask = widthMinus1 & -(int32) swrap;
	unsigned_int32 ymask = heightMinus1 & -(int32) twrap;
	scale *= 0.5F;

	for (machine y = 0; y < height; y++)
	{
		Color4C *normal = destin + y * width;

		int32 ym1 = ((y - 1) & ymask) | (MaxZero(y - 1) & ~ymask);
		int32 yp1 = ((y + 1) & ymask) | (Min(y + 1, heightMinus1) & ~ymask);

		const Color4C *rowx = source + y * width;
		const Color4C *rowy1 = source + ym1 * width;
		const Color4C *rowy2 = source + yp1 * width;

		for (machine x = 0; x < width; x++)
		{
			int32 xm1 = ((x - 1) & xmask) | (MaxZero(x - 1) & ~xmask);
			int32 xp1 = ((x + 1) & xmask) | (Min(x + 1, widthMinus1) & ~xmask);

			float h = (float) rowx[xm1].GetRed() * K::one_over_255;
			float dhx = ((float) rowx[xp1].GetRed() * K::one_over_255 - h) * scale;

			h = (float) rowy1[x].GetRed() * K::one_over_255;
			float dhy = ((float) rowy2[x].GetRed() * K::one_over_255 - h) * scale;

			float m = InverseSqrt(dhx * dhx + dhy * dhy + 1.0F) * 127.0F;
			int32 red = Min(Max((int32) (-dhx * m), -127), 127) + 128;
			int32 green = Min(Max((int32) (-dhy * m), -127), 127) + 128;
			int32 blue = Min(Max((int32) m, -127), 127) + 128;

			float z = m * ((float) rowx[x].GetRed() * K::one_over_255 - 0.5F) * 2.0F;
			int32 alpha = Min(Max((int32) z, -127), 127) + 128;

			normal[x].Set(red, green, blue, alpha);
		}
	}
}

void Image::CalculateHorizonMap(int32 index, int32 width, int32 height, const Rect& rect, const Color4C *source, Color4C *restrict destin, float scale, bool swrap, bool twrap)
{
	enum
	{
		kHorizonMapAngleCount = 32
	};

	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;
	unsigned_int32 xmask = widthMinus1 & -(int32) swrap;
	unsigned_int32 ymask = heightMinus1 & -(int32) twrap;

	scale *= K::one_over_255;

	for (machine y = rect.top; y < rect.bottom; y++)
	{
		const Color4C *centerRow = source + y * width;
		for (machine x = rect.left; x < rect.right; x++)
		{
			float	maxSquaredTangent[kHorizonMapAngleCount];

			for (machine a = 0; a < kHorizonMapAngleCount; a++)
			{
				maxSquaredTangent[a] = 0.0F;
			}

			float h0 = (float) centerRow[x].GetRed() * scale;

			for (machine j = -kHorizonMapRadius; j <= kHorizonMapRadius; j++)
			{
				int32 k = (j + kHorizonMapRadius) * (kHorizonMapRadius * 2 + 1) + kHorizonMapRadius;

				int32 ypj = y + j;
				ypj = (ypj & ymask) | (MaxZero(Min(ypj, heightMinus1)) & ~ymask);
				const Color4C *row = source + ypj * width;

				for (machine i = -kHorizonMapRadius; i <= kHorizonMapRadius; i++)
				{
					int32 r2 = i * i + j * j;
					if ((r2 < kHorizonMapRadius * kHorizonMapRadius) && (r2 != 0))
					{
						int32 xpi = x + i;
						xpi = (xpi & xmask) | (MaxZero(Min(xpi, widthMinus1)) & ~xmask);
						float h = (float) row[xpi].GetRed() * scale;
						if (h > h0)
						{
							h -= h0;
							float t = h * h / (float) r2;

							const int8 *range = horizonAngleRange[k + i];
							int32 minAngle = range[0];
							int32 maxAngle = range[1];

							const float *centerDelta = horizonDeltaAngle[k + i];
							float centerAngle = centerDelta[0];
							float deltaAngle = centerDelta[1];

							for (machine n = minAngle; n <= maxAngle; n++)
							{
								float angle = (float) n * K::tau / (float) kHorizonMapAngleCount;
								float f = 1.0F - Fabs(angle - centerAngle) / deltaAngle;

								int32 m = n & (kHorizonMapAngleCount - 1);
								maxSquaredTangent[m] = Fmax(maxSquaredTangent[m], t * f);
							}
						}
					}
				}
			}

			float red = 0.0F;
			float green = 0.0F;
			float blue = 0.0F;
			float alpha = 0.0F;

			int32 start = kHorizonMapAngleCount / 8 - kHorizonMapAngleCount / 16;
			int32 finish = kHorizonMapAngleCount / 8 + kHorizonMapAngleCount / 16;
			if (index != 0)
			{
				start += kHorizonMapAngleCount / 2;
				finish += kHorizonMapAngleCount / 2;
			}

			for (machine a = start; a < finish; a++)
			{
				float t = maxSquaredTangent[(a - kHorizonMapAngleCount / 8) & (kHorizonMapAngleCount - 1)];
				if (t > K::min_float)
				{
					red += InverseSqrt(1.0F / t + 1.0F);
				}

				t = maxSquaredTangent[a];
				if (t > K::min_float)
				{
					green += InverseSqrt(1.0F / t + 1.0F);
				}

				t = maxSquaredTangent[a + kHorizonMapAngleCount / 8];
				if (t > K::min_float)
				{
					blue += InverseSqrt(1.0F / t + 1.0F);
				}

				t = maxSquaredTangent[a + kHorizonMapAngleCount / 4];
				if (t > K::min_float)
				{
					alpha += InverseSqrt(1.0F / t + 1.0F);
				}
			}

			float f = 255.0F / (float) (kHorizonMapAngleCount / 8);
			destin[y * width + x].Set((unsigned_int32) (red * f), (unsigned_int32) (green * f), (unsigned_int32) (blue * f), (unsigned_int32) (alpha * f));
		}
	}
}

void Image::CalculateAmbientOcclusionChannel(int32 width, int32 height, const Rect& rect, const Color4C *source, Color4C *restrict destin, float scale, bool swrap, bool twrap)
{
	enum
	{
		kAmbientOcclusionAngleCount = 32
	};

	int32 widthMinus1 = width - 1;
	int32 heightMinus1 = height - 1;
	unsigned_int32 xmask = widthMinus1 & -(int32) swrap;
	unsigned_int32 ymask = heightMinus1 & -(int32) twrap;

	scale *= K::one_over_255;

	for (machine y = rect.top; y < rect.bottom; y++)
	{
		const Color4C *centerRow = source + y * width;
		for (machine x = rect.left; x < rect.right; x++)
		{
			float	maxSquaredTangent[kAmbientOcclusionAngleCount];

			for (machine a = 0; a < kAmbientOcclusionAngleCount; a++)
			{
				maxSquaredTangent[a] = 0.0F;
			}

			const Color4C& c = centerRow[x];
			float h0 = (float) c.GetAlpha() * scale;

			for (machine j = -kAmbientOcclusionRadius; j <= kAmbientOcclusionRadius; j++)
			{
				int32 k = (j + kAmbientOcclusionRadius) * (kAmbientOcclusionRadius * 2 + 1) + kAmbientOcclusionRadius;

				int32 ypj = y + j;
				ypj = (ypj & ymask) | (MaxZero(Min(ypj, heightMinus1)) & ~ymask);
				const Color4C *row = source + ypj * width;

				for (machine i = -kAmbientOcclusionRadius; i <= kAmbientOcclusionRadius; i++)
				{
					int32 r2 = i * i + j * j;
					if ((r2 < kAmbientOcclusionRadius * kAmbientOcclusionRadius) && (r2 != 0))
					{
						int32 xpi = x + i;
						xpi = (xpi & xmask) | (MaxZero(Min(xpi, widthMinus1)) & ~xmask);
						float h = (float) row[xpi].GetAlpha() * scale;
						if (h > h0)
						{
							h -= h0;
							float t = h * h / (float) r2;

							const int8 *range = ambientOcclusionAngleRange[k + i];
							int32 minAngle = range[0];
							int32 maxAngle = range[1];

							for (machine n = minAngle; n <= maxAngle; n++)
							{
								int32 m = n & (kAmbientOcclusionAngleCount - 1);
								maxSquaredTangent[m] = Fmax(maxSquaredTangent[m], t);
							}
						}
					}
				}
			}

			float sum = 0.0F;
			for (machine a = 0; a < kAmbientOcclusionAngleCount; a++)
			{
				float t = maxSquaredTangent[a];
				if (t > K::min_float)
				{
					sum += InverseSqrt(1.0F / t + 1.0F);
				}
			}

			unsigned_int32 alpha = MaxZero((unsigned_int32) (255.0F - sum * (255.0F / (float) kAmbientOcclusionAngleCount)));
			destin[y * width + x].Set(c.GetRed(), c.GetGreen(), c.GetBlue(), alpha);
		}
	}
}

int32 Image::CalculateMipmapChainSize2D(int32 width, int32 height, int32 *pixelCount)
{
	int32 levelCount = 0;
	int32 size = 0;

	for (;;)
	{
		levelCount++;
		size += width * height;

		if (Max(width, height) == 1)
		{
			break;
		}

		width = Max(width >> 1, 1);
		height = Max(height >> 1, 1);
	}

	*pixelCount = size;
	return (levelCount);
}

int32 Image::CalculateBlockMipmapChainSize2D(int32 width, int32 height, int32 levelCount)
{
	int32 size = 0;
	do
	{
		size += ((width + 3) & ~3) * ((height + 3) & ~3);

		if (Max(width, height) == 1)
		{
			break;
		}

		width = Max(width >> 1, 1);
		height = Max(height >> 1, 1);
	} while (--levelCount > 0);

	return (size);
}

int32 Image::CalculateMipmapChainSize3D(int32 width, int32 height, int32 depth, int32 *pixelCount)
{
	int32 levelCount = 0;
	int32 size = 0;

	for (;;)
	{
		levelCount++;
		size += width * height * depth;

		if (Max(Max(width, height), depth) == 1)
		{
			break;
		}

		width = Max(width >> 1, 1);
		height = Max(height >> 1, 1);
		depth = Max(depth >> 1, 1);
	}

	*pixelCount = size;
	return (levelCount);
}

void Image::GenerateMipmaps2D(int32 count, int32 width, int32 height, Color4C *image, unsigned_int32 flags)
{
	for (machine a = 0; a < count; a++)
	{
		int32 xsize = 1;
		int32 ysize = 1;
		int32 shift = 0;
		Fixed alphaMultiplier = 0x00000100;

		Color4C *restrict mipImage = image + width * height * (count - a);

		for (machine mipWidth = width, mipHeight = height; (mipWidth != 1) || (mipHeight != 1);)
		{
			if (mipWidth != 1)
			{
				mipWidth >>= 1;
				xsize <<= 1;
				shift++;
			}

			if (mipHeight != 1)
			{
				mipHeight >>= 1;
				ysize <<= 1;
				shift++;
			}

			mipImage += mipWidth * mipHeight * a;

			for (machine y = 0; y < mipHeight; y++)
			{
				const Color4C *src = image + y * ysize * width;
				Color4C *dst = mipImage + y * mipWidth;

				for (machine x = 0; x < mipWidth; x++)
				{
					int64 red = 0;
					int64 green = 0;
					int64 blue = 0;
					int64 alpha = 0;

					for (machine j = 0; j < ysize; j++)
					{
						int32 k = j * width + x * xsize;
						for (machine i = 0; i < xsize; i++)
						{
							const Color4C& c = src[k + i];
							red += c.GetRed();
							green += c.GetGreen();
							blue += c.GetBlue();
							alpha += c.GetAlpha();
						}
					}

					red >>= shift;
					green >>= shift;
					blue >>= shift;
					alpha >>= shift;
					alpha = Min64((alpha * alphaMultiplier) >> 8, 255);

					if (flags & kMipmapNormalize)
					{
						float r = (float) (red - 128) * K::one_over_127;
						float g = (float) (green - 128) * K::one_over_127;
						float b = (float) (blue - 128) * K::one_over_127;

						float m = InverseSqrt(r * r + g * g + b * b) * 127.0F;
						red = (int32) (r * m + 0.5F) + 128;
						green = (int32) (g * m + 0.5F) + 128;
						blue = (int32) (b * m + 0.5F) + 128;
					}

					dst[x].Set((unsigned_int32) red, (unsigned_int32) green, (unsigned_int32) blue, (unsigned_int32) alpha);
				}
			}

			mipImage += mipWidth * mipHeight * (count - a);

			if (flags & kMipmapBoostAlpha)
			{
				alphaMultiplier = (alphaMultiplier * 9) >> 3;
			}
			else if (flags & kMipmapDampenAlpha)
			{
				alphaMultiplier >>= 1;
			}
		}

		image += width * height;
	}
}

void Image::GenerateMipmaps2D(int32 count, int32 width, int32 height, Color2C *image)
{
	for (machine a = 0; a < count; a++)
	{
		int32 xsize = 1;
		int32 ysize = 1;
		int32 shift = 0;

		Color2C *restrict mipImage = image + width * height * (count - a);

		for (machine mipWidth = width, mipHeight = height; (mipWidth != 1) || (mipHeight != 1);)
		{
			if (mipWidth != 1)
			{
				mipWidth >>= 1;
				xsize <<= 1;
				shift++;
			}

			if (mipHeight != 1)
			{
				mipHeight >>= 1;
				ysize <<= 1;
				shift++;
			}

			mipImage += mipWidth * mipHeight * a;

			for (machine y = 0; y < mipHeight; y++)
			{
				const Color2C *src = image + y * ysize * width;
				Color2C *dst = mipImage + y * mipWidth;

				for (machine x = 0; x < mipWidth; x++)
				{
					int64 red = 0;
					int64 green = 0;

					for (machine j = 0; j < ysize; j++)
					{
						int32 k = j * width + x * xsize;
						for (machine i = 0; i < xsize; i++)
						{
							const Color2C& c = src[k + i];
							red += c.GetRed();
							green += c.GetGreen();
						}
					}

					red >>= shift;
					green >>= shift;

					dst[x].Set((unsigned_int32) red, (unsigned_int32) green);
				}
			}

			mipImage += mipWidth * mipHeight * (count - a);
		}

		image += width * height;
	}
}

void Image::GenerateMipmaps2D(int32 count, int32 width, int32 height, Color1C *image)
{
	for (machine a = 0; a < count; a++)
	{
		int32 xsize = 1;
		int32 ysize = 1;
		int32 shift = 0;

		Color1C *restrict mipImage = image + width * height * (count - a);

		for (machine mipWidth = width, mipHeight = height; (mipWidth != 1) || (mipHeight != 1);)
		{
			if (mipWidth != 1)
			{
				mipWidth >>= 1;
				xsize <<= 1;
				shift++;
			}

			if (mipHeight != 1)
			{
				mipHeight >>= 1;
				ysize <<= 1;
				shift++;
			}

			mipImage += mipWidth * mipHeight * a;

			for (machine y = 0; y < mipHeight; y++)
			{
				const Color1C *src = image + y * ysize * width;
				Color1C *dst = mipImage + y * mipWidth;

				for (machine x = 0; x < mipWidth; x++)
				{
					int64 lum = 0;

					for (machine j = 0; j < ysize; j++)
					{
						int32 k = j * width + x * xsize;
						for (machine i = 0; i < xsize; i++)
						{
							lum += src[k + i];
						}
					}

					dst[x] = (Color1C) (lum >> shift);
				}
			}

			mipImage += mipWidth * mipHeight * (count - a);
		}

		image += width * height;
	}
}

void Image::GenerateMipmaps3D(int32 width, int32 height, int32 depth, Color4C *image)
{
	int32 xsize = 1;
	int32 ysize = 1;
	int32 zsize = 1;
	int32 shift = 0;

	Color4C *restrict mipImage = image + width * height * depth;

	for (machine mipWidth = width, mipHeight = height, mipDepth = depth; (mipWidth != 1) || (mipHeight != 1) || (mipDepth != 1);)
	{
		if (mipWidth != 1)
		{
			mipWidth >>= 1;
			xsize <<= 1;
			shift++;
		}

		if (mipHeight != 1)
		{
			mipHeight >>= 1;
			ysize <<= 1;
			shift++;
		}

		if (mipDepth != 1)
		{
			mipDepth >>= 1;
			zsize <<= 1;
			shift++;
		}

		for (machine z = 0; z < mipDepth; z++)
		{
			for (machine y = 0; y < mipHeight; y++)
			{
				const Color4C *src = image + (z * zsize * height + y * ysize) * width;
				Color4C *dst = mipImage + (z * mipHeight + y) * mipWidth;

				for (machine x = 0; x < mipWidth; x++)
				{
					int64 red = 0;
					int64 green = 0;
					int64 blue = 0;
					int64 alpha = 0;

					for (machine k = 0; k < zsize; k++)
					{
						for (machine j = 0; j < ysize; j++)
						{
							int32 n = (k * height + j) * width + x * xsize;
							for (machine i = 0; i < xsize; i++)
							{
								const Color4C& c = src[n + i];
								red += c.GetRed();
								green += c.GetGreen();
								blue += c.GetBlue();
								alpha += c.GetAlpha();
							}
						}
					}

					red >>= shift;
					green >>= shift;
					blue >>= shift;
					alpha >>= shift;

					dst[x].Set((unsigned_int32) red, (unsigned_int32) green, (unsigned_int32) blue, (unsigned_int32) alpha);
				}
			}
		}

		mipImage += mipWidth * mipHeight * mipDepth;
	}
}

void Image::GenerateMipmaps3D(int32 width, int32 height, int32 depth, Color2C *image)
{
	int32 xsize = 1;
	int32 ysize = 1;
	int32 zsize = 1;
	int32 shift = 0;

	Color2C *restrict mipImage = image + width * height * depth;

	for (machine mipWidth = width, mipHeight = height, mipDepth = depth; (mipWidth != 1) || (mipHeight != 1) || (mipDepth != 1);)
	{
		if (mipWidth != 1)
		{
			mipWidth >>= 1;
			xsize <<= 1;
			shift++;
		}

		if (mipHeight != 1)
		{
			mipHeight >>= 1;
			ysize <<= 1;
			shift++;
		}

		if (mipDepth != 1)
		{
			mipDepth >>= 1;
			zsize <<= 1;
			shift++;
		}

		for (machine z = 0; z < mipDepth; z++)
		{
			for (machine y = 0; y < mipHeight; y++)
			{
				const Color2C *src = image + (z * zsize * height + y * ysize) * width;
				Color2C *dst = mipImage + (z * mipHeight + y) * mipWidth;

				for (machine x = 0; x < mipWidth; x++)
				{
					int64 red = 0;
					int64 green = 0;

					for (machine k = 0; k < zsize; k++)
					{
						for (machine j = 0; j < ysize; j++)
						{
							int32 n = (k * height + j) * width + x * xsize;
							for (machine i = 0; i < xsize; i++)
							{
								const Color2C& c = src[n + i];
								red += c.GetRed();
								green += c.GetGreen();
							}
						}
					}

					red >>= shift;
					green >>= shift;

					dst[x].Set((unsigned_int32) red, (unsigned_int32) green);
				}
			}
		}

		mipImage += mipWidth * mipHeight * mipDepth;
	}
}

void Image::GenerateMipmaps3D(int32 width, int32 height, int32 depth, Color1C *image)
{
	int32 xsize = 1;
	int32 ysize = 1;
	int32 zsize = 1;
	int32 shift = 0;

	Color1C *restrict mipImage = image + width * height * depth;

	for (machine mipWidth = width, mipHeight = height, mipDepth = depth; (mipWidth != 1) || (mipHeight != 1) || (mipDepth != 1);)
	{
		if (mipWidth != 1)
		{
			mipWidth >>= 1;
			xsize <<= 1;
			shift++;
		}

		if (mipHeight != 1)
		{
			mipHeight >>= 1;
			ysize <<= 1;
			shift++;
		}

		if (mipDepth != 1)
		{
			mipDepth >>= 1;
			zsize <<= 1;
			shift++;
		}

		for (machine z = 0; z < mipDepth; z++)
		{
			for (machine y = 0; y < mipHeight; y++)
			{
				const Color1C *src = image + (z * zsize * height + y * ysize) * width;
				Color1C *dst = mipImage + (z * mipHeight + y) * mipWidth;

				for (machine x = 0; x < mipWidth; x++)
				{
					int64 lum = 0;

					for (machine k = 0; k < zsize; k++)
					{
						for (machine j = 0; j < ysize; j++)
						{
							int32 n = (k * height + j) * width + x * xsize;
							for (machine i = 0; i < xsize; i++)
							{
								lum += src[n + i];
							}
						}
					}

					dst[x] = (Color1C) (lum >> shift);
				}
			}
		}

		mipImage += mipWidth * mipHeight * mipDepth;
	}
}

// ZYUQURM
