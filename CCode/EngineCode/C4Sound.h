 

#ifndef C4Sound_h
#define C4Sound_h


//# \component	Sound Manager
//# \prefix		SoundMgr/


#include "C4Variables.h"
#include "C4Resources.h"
#include "C4Threads.h"

#if C4WINDOWS && C4FASTBUILD

	#include "C4XAudio.h"

#endif


#if !C4WINDOWS

	#define WAVE_FORMAT_PCM		0x0001
	#define WAVE_FORMAT_ADPCM	0x0002

#endif


namespace C4
{
	typedef EngineResult	SoundResult;
	typedef Type			SoundGroupType;
	typedef int16			Sample;


	#if C4WINDOWS || C4LINUX || C4IOS

		typedef Sample OutputSample;

	#elif C4MACOS || C4PS4 || C4PS3

		typedef float OutputSample;

	#endif


	enum : SoundResult
	{
		kSoundOkay				= kEngineOkay,
		kSoundInitFailed		= (kManagerSound << 16) | 0x0001,
		kSoundLoadFailed		= (kManagerSound << 16) | 0x0002,
		kSoundPlayFailed		= (kManagerSound << 16) | 0x0003,
		kSoundFormatInvalid		= (kManagerSound << 16) | 0x0004,
		kSoundTooLarge			= (kManagerSound << 16) | 0x0005
	};


	struct StereoFrame
	{
		Sample	left;
		Sample	right;
	};


	struct StereoMixFrame
	{
		float	left;
		float	right;
	};


	const float kMaxReverbDecayTime = 4000.0F;


	enum
	{
		kMaxSoundCount				= 64,
		kMaxRoomCount				= 4,
		kMaxSoundPathCount			= 4
	};


	enum
	{
		#if C4DESKTOP || C4MOBILE

			kOutputBufferFrameCount		= 1024,

		#elif C4PS4 //[ PS4

			// -- PS4 code hidden --

		#elif C4PS3 //[ PS3

			// -- PS3 code hidden --

		#endif //]

		kRingBufferSliceCount		= 4,
		kRingBufferFrameCount		= kOutputBufferFrameCount * kRingBufferSliceCount,
		kStereoOutputBufferSize		= kOutputBufferFrameCount * sizeof(StereoFrame),
		kRecordBufferSliceCount		= 8, 
		kRecordBufferLogSliceCount	= 3,
		kRecordBufferSampleCount	= kOutputBufferFrameCount * kRecordBufferSliceCount * 2,
		kRecordOutputBufferSize		= kRecordBufferSampleCount / 2 * sizeof(Sample), 
		kSoundReflectionCount		= 6,
		kRoomFeedbackBufferCount	= 4, 
		kSampleHistoryCount			= 64,
		kStreamBufferSize			= 262144
	}; 

 
	enum 
	{
		kSoundOptionReverb			= 1 << 0
	};
 

	enum
	{
		kSoundLoopInfinite			= -1
	};


	enum
	{
		kSoundUpdateVolume			= 1 << 0,
		kSoundUpdateFrequency		= 1 << 1,
		kSoundUpdateReflections		= 1 << 2
	};


	enum
	{
		kSoundVaryingVolume				= 1 << 0,
		kSoundVaryingVolumeStop			= 1 << 1,
		kSoundVaryingVolumeComplete		= 1 << 2,
		kSoundVaryingVolumeMask			= 0x000F,

		kSoundVaryingFrequency			= 1 << 4,
		kSoundVaryingFrequencyStop		= 1 << 5,
		kSoundVaryingFrequencyComplete	= 1 << 6,
		kSoundVaryingFrequencyMask		= 0x00F0
	};


	//# \enum	SoundFlags

	enum
	{
		kSoundPersistent			= 1 << 0,		//## The sound object continues to exist after it finishes playing.
		kSoundSpatialized			= 1 << 1,		//## The sound is localized and 3D spatialization effects are applied. If this flag is not set, then all flags except $kSoundPersistent$ are ignored.
		kSoundDopplerShift			= 1 << 2,		//## The Doppler effect is applied to the sound based on the velocity relative to the listener and the global speed of sound.
		kSoundDistanceDelay			= 1 << 3,		//## The sound is delayed based on distance from the listener and the global speed of sound.
		kSoundReverb				= 1 << 4,		//## Reflection and reverberation effects are applied to the sound based on the room properties associated with the sound.
		kSoundCones					= 1 << 5,		//## The sound is directional, and cone attenuation is applied.
		kSoundStreamExternal		= 1 << 6
	};


	//# \enum	SoundProperty

	enum
	{
		kSoundVolume,					//## The master volume for the sound. All other volumes are relative to this volume. The default value is 1.0.
		kSoundDirectVolume,				//## The volume applied to the sound's direct path. The default value is 1.0, representing no obstruction.
		kSoundDirectHFVolume,			//## High-frequency volume applied to the sound's direct path. A value of 1.0 means no high-frequency damping, and 0.0 means maximum damping. The default value is 1.0, representing no obstruction.
		kSoundReflectionVolume,			//## The volume of reflections (and subsequent reverberation) generated by the sound. The default value is 1.0.
		kSoundReflectionHFVolume,		//## High-frequency volume applied to reflections generated by the sound. A value of 1.0 means no high-frequency damping, and 0.0 means maximum damping. The default value is 1.0.
		kSoundOuterConeVolume,			//## The volume of a directional sound outside the outer cone. The default value is 0.0.
		kSoundOuterConeHFVolume,		//## High-frequency volume applied outside the outer cone. A value of 1.0 means no high-frequency damping, and 0.0 means maximum damping. The default value is 1.0.
		kSoundMinAttenDistance,			//## The distance below which the sound is unattenuated and plays at full volume. This must be greater than or equal to 0.0. The default value is 0.0.
		kSoundMaxAttenDistance,			//## The distance above which the sound is completely silent due to attenuation. This must be greater than the value of $kSoundMinAttenDistance$. The default value is 16.0.
		kSoundInnerConeCosine,			//## The cosine of the inner sound cone's apex angle. This must be in the range [&minus;1.0, 1.0]. The default value is 1.0.
		kSoundOuterConeCosine,			//## The cosine of the outer sound cone's apex angle. This must be in the range [&minus;1.0, 1.0]. The default value is 0.0.
		kSoundFrequency,				//## The relative frequency at which the sound is played. This must be a positive number. A value of 1.0 (the default) means play at the frequency of the source data, a value of 0.5 means play at half the frequency, and so on. Values greater than 1.0 are allowed, but sound quality may be diminished.
		kSoundPropertyCount
	};


	//# \enum	SoundState

	enum SoundState
	{
		kSoundUnloaded,				//## The sound is not loaded.
		kSoundStopping,				//## The sound is in the process of stopping.
		kSoundStopped,				//## The sound is stopped.
		kSoundDelaying,				//## The sound is waiting for a delay period to pass before it plays. This state is only set when the $@Sound::Delay@$ function is called, and not as a result of the $kSoundDistanceDelay$ flag being set.
		kSoundPlaying,				//## The sound is playing.
		kSoundPaused,				//## The sound is paused.
		kSoundDelayPaused,			//## The sound is paused while waiting for a delay period to pass before it plays.
		kSoundCompleted,			//## The sound has completed, but the completion procedure has not yet been called.
		kSoundReleased
	};


	enum
	{
		kSoundStreamerPaused	= 1 << 0
	};


	struct SoundResourceHeader
	{
		int32					endian;
		unsigned_int32			headerDataSize;
	};


	struct AudioChannelData
	{
		unsigned_int32			audioChannelFlags;
		unsigned_int32			audioCodeOffset;
		unsigned_int32			audioCodeSize;
		unsigned_int32			audioDataSize;

		const unsigned_int8 *GetAudioCode(void) const
		{
			return (reinterpret_cast<const unsigned_int8 *>(this) + audioCodeOffset);
		}
	};


	struct AudioBlockHeader
	{
		unsigned_int32			audioBlockFlags;
		AudioChannelData		audioChannelData[1];
	};


	struct AudioBlockData
	{
		unsigned_int32			audioBlockDataOffset;
		unsigned_int32			audioBlockDataSize;
	};


	struct AudioTrackHeader
	{
		unsigned_int32			audioTrackFlags;
		int32					audioBlockCount;
		int32					blockFrameCount;

		int32					audioFrameCount;
		int32					audioChannelCount;
		int32					audioSampleDepth;
		int32					audioSampleFrequency;

		unsigned_int32			maxBlockCodeSize;
		unsigned_int32			maxBlockDataSize;

		AudioBlockData			audioBlockData[1];
	};


	#if C4VISUALC

		#pragma pack(push, 1)

	#endif

	struct __attribute__((packed)) WaveHeader
	{
		unsigned_int16		format;
		unsigned_int16		numChannels;
		unsigned_int32		sampleRate;
		unsigned_int32		bytesPerSec;
		unsigned_int16		blockAlign;
		unsigned_int16		bitsPerSample;
		unsigned_int16		extraSize;
	};

	#if C4VISUALC

		#pragma pack(pop)

	#endif


	struct PredictorCoefficient
	{
		int16	c1;
		int16	c2;
	};


	struct ADPCMWaveHeader : WaveHeader
	{
		unsigned_int16			blockFrameCount;
		unsigned_int16			coefficientCount;
		PredictorCoefficient	coefficient[32];
	};


	struct WaveFileHeader
	{
		unsigned_int32		riffTag;
		unsigned_int32		fileLength;
		unsigned_int32		waveTag;
		unsigned_int32		fmtTag;
		unsigned_int32		fmtLength;
		unsigned_int16		format;
		unsigned_int16		numChannels;
		unsigned_int32		sampleRate;
		unsigned_int32		bytesPerSec;
		unsigned_int16		blockAlign;
		unsigned_int16		bitsPerSample;
		unsigned_int32		dataTag;
		unsigned_int32		dataLength;
	};


	class Sound;
	class SoundRoom;


	struct SoundPathData
	{
		const Point3D		*soundPosition;
		float				soundPathLength;
	};


	struct RoomMixBuffer
	{
		StereoMixFrame		reverbBuffer[kRingBufferFrameCount];
		StereoMixFrame		feedbackBuffer[kRoomFeedbackBufferCount][kRingBufferFrameCount];
	};


	struct SoundMixData
	{
		struct ReflectionData
		{
			SoundRoom		*soundRoom;
			RoomMixBuffer	*roomMixBuffer;

			int32			reflectionDelay[kSoundReflectionCount];
			float			reflectionVolume[kSoundReflectionCount];
			float			reflectionHFVolume[kSoundReflectionCount];
		};

		float				directVolumeCurrent[2];
		float				directVolumeFinal[2];
		float				directVolumeDelta[2];
		float				directHFVolume;

		float				frequencyCurrent;
		float				frequencyFinal;
		float				frequencyAlpha;

		float				reflectionVolumeCurrent;
		float				reflectionVolumeFinal;
		float				reflectionVolumeDelta;
		float				reflectionHFVolume;

		ReflectionData		reflectionData[2];

		unsigned_int32		sampleTableIndex;
		float				sampleTableSum;
		float				sampleTable[kSampleHistoryCount];
	};


	struct StreamBufferHeader
	{
		volatile bool		readyFlag;
		bool				finalFlag;

		unsigned_int32		frameCount;
		int32				loopFrame;

		Sample *GetSampleData(void)
		{
			return (reinterpret_cast<Sample *>(this + 1));
		}

		const Sample *GetSampleData(void) const
		{
			return (reinterpret_cast<const Sample *>(this + 1));
		}
	};


	class AudioCompressor
	{
		private:

			int32					channelCount;

			char					*compressorStorage;

			Sample					*audioChannelData[2];
			Sample					*audioDifferenceData;

			unsigned_int8			*audioChannelCode[2];
			unsigned_int8			*audioDifferenceCode;

			unsigned_int8			*compressedCode;

			static unsigned_int32 EncodeDeltaRun(const Sample *sample, int32 count, int32 level, unsigned_int8 *restrict code);
			static unsigned_int32 CompressAudioChannel(const Sample *audio, int32 frameCount, unsigned_int8 *restrict code);

		public:

			C4API AudioCompressor(const AudioTrackHeader *audioTrackHeader);
			C4API ~AudioCompressor();

			const unsigned_int8 *GetCompressedCode(void) const
			{
				return (compressedCode);
			}

			C4API unsigned_int32 CompressBlock(const Sample *audio, int32 frameCount, AudioBlockHeader *audioBlockHeader);
	};


	class AudioDecompressor
	{
		private:

			int32					channelCount;

			char					*decompressorStorage;

			AudioBlockHeader		*audioBlockHeader;
			unsigned_int8			*audioBlockData;
			Sample					*audioSampleBuffer;

			template <int stride> static void DecompressAudioMono(const unsigned_int8 *code, int32 sampleCount, Sample *restrict audio);
			template <class combiner> static void DecompressAudioStereo(const unsigned_int8 *code, int32 sampleCount, const Sample *channel, Sample *restrict audio);

		public:

			AudioDecompressor(const AudioTrackHeader *audioTrackHeader);
			~AudioDecompressor();

			AudioBlockHeader *GetAudioBlockHeader(void) const
			{
				return (audioBlockHeader);
			}

			void DecompressBlock(Sample *audio, int32 frameCount);
	};


	class SoundResource : public Resource<SoundResource>
	{
		friend class Resource<SoundResource>;

		private:

			static C4API ResourceDescriptor		descriptor;

			const WaveHeader	*waveHeader;
			const Sample		*sampleData;
			unsigned_int32		sampleCount;

			~SoundResource();

			void Preprocess(void) override;

		public:

			C4API SoundResource(const char *name, ResourceCatalog *catalog);

			const WaveHeader *GetWaveHeader(void) const
			{
				return (waveHeader);
			}

			const Sample *GetSampleData(void) const
			{
				return (sampleData);
			}

			unsigned_int32 GetSampleCount(void) const
			{
				return (sampleCount);
			}

			C4API ResourceResult LoadWaveHeader(ResourceLoader *loader, WaveHeader *header) const;

			C4API static bool DetermineStreaming(const char *name);
	};


	class SoundLoader : public ResourceLoader, public ListElement<SoundLoader>
	{
		private:

			SoundResource		*soundResource;

			int32				frameCount;
			int32				startPosition;
			unsigned_int32		waveDataSize;

			ADPCMWaveHeader		adpcmHeader;

		public:

			SoundLoader();
			~SoundLoader();

			int32 GetFrameCount(void) const
			{
				return (frameCount);
			}

			int32 GetStartPosition(void) const
			{
				return (startPosition);
			}

			unsigned_int32 GetWaveDataSize(void) const
			{
				return (waveDataSize);
			}

			const ADPCMWaveHeader *GetADPCMWaveHeader(void) const
			{
				return (&adpcmHeader);
			}

			SoundResult Open(const char *name);
	};


	//# \class	SoundStreamer	The base class for all sound streamer objects.
	//
	//# \def	class SoundStreamer
	//
	//# \ctor	SoundStreamer();
	//
	//# The $SoundStreamer$ constructor has protected access.
	//
	//# \desc
	//# The $SoundStreamer$ class is the base class for all sound streamer objects. A sound stream
	//# is established by instantiating a subclass of $SoundStreamer$ and then passing it to the
	//# $@Sound::Stream@$ function.
	//
	//# \also	$@WaveStreamer@$
	//# \also	$@Sound::Stream@$
	//
	//# \wiki	Sound


	//# \function	SoundStreamer::SetChannelCount		Sets the number of audio channels.
	//
	//# \proto	void SetChannelCount(int32 count);
	//
	//# \param	count	The number of audio channels.
	//
	//# \desc
	//# The $SetChannelCount$ function should be called by each subclass of the $@SoundStreamer@$
	//# class in order to set the number of audio channels. The value of the $count$ parameter
	//# must be 1 or 2.
	//
	//# \also	$@SoundStreamer::SetSampleRate@$


	//# \function	SoundStreamer::SetSampleRate		Sets the audio sampling rate.
	//
	//# \proto	void SetSampleRate(int32 rate);
	//
	//# \param	rate	The audio sampling rate, in Hz.
	//
	//# \desc
	//# The $SetSampleRate$ function should be called by each subclass of the $@SoundStreamer@$
	//# class in order to set the audio sampling rate. The value of the $rate$ parameter
	//# is expressed in Hertz, and it should be in the range [8000,&nbsp;48000].
	//
	//# \also	$@SoundStreamer::SetChannelCount@$


	//# \function	SoundStreamer::GetWorkBufferSize		Returns the size of the work buffer.
	//
	//# \proto	unsigned_int32 GetWorkBufferSize(void) const;
	//
	//# \desc
	//# The $GetWorkBufferSize$ function returns the size of the work buffer that was previously
	//# allocated with the $@SoundStreamer::AllocateStreamMemory@$ function.
	//
	//# \also	$@SoundStreamer::GetWorkBuffer@$
	//# \also	$@SoundStreamer::AllocateStreamMemory@$


	//# \function	SoundStreamer::GetWorkBuffer		Returns a pointer to the work buffer.
	//
	//# \proto	char *GetWorkBuffer(void) const;
	//
	//# \desc
	//# The $GetWorkBuffer$ function returns a pointer to the work buffer that was previously
	//# allocated with the $@SoundStreamer::AllocateStreamMemory@$ function.
	//
	//# \also	$@SoundStreamer::GetWorkBufferSize@$
	//# \also	$@SoundStreamer::AllocateStreamMemory@$


	//# \function	SoundStreamer::AllocateStreamMemory		Allocates memory for use by the streamer object.
	//
	//# \proto	void AllocateStreamMemory(unsigned_int32 workSize, unsigned_int32 streamSize);
	//
	//# \param	workSize	The size of the streamer's work buffer.
	//# \param	streamSize	The size of each decompressed output buffer.
	//
	//# \desc
	//# A streamer object should call the $AllocateStreamMemory$ to allocate the memory that it needs
	//# for streaming. The work buffer is a buffer that can be used by the streamer object for any purpose,
	//# and it's size is specified by the $workSize$ parameter. A streamer object has at least two stream
	//# buffers, and the size of each is specified by the $streamSize$ parameter. The stream buffers are where
	//# the decompressed audio data is written when the Sound Manager calls the $@SoundStreamer::FillBuffer@$ function.
	//
	//# \also	$@SoundStreamer::FillBuffer@$
	//# \also	$@SoundStreamer::GetWorkBufferSize@$
	//# \also	$@SoundStreamer::GetWorkBuffer@$


	//# \function	SoundStreamer::GetStreamFrameCount		Called to retrieve the total frame count for a stream.
	//
	//# \proto	virtual int32 GetStreamFrameCount(void);
	//
	//# \desc
	//# The Sound Manager calls the $GetStreamFrameCount$ function when it needs to know the total number of audio frames
	//# contained in a stream. By default, this function returns zero, which means that the length of the stream is
	//# indefinite. Subclasses of the $SoundStreamer$ class should implement an override of the $GetStreamFrameCount$
	//# function when the length of the audio stream can be determined.


	//# \function	SoundStreamer::StartStream		Called to prepare a stream for playing.
	//
	//# \proto	virtual SoundResult StartStream(void) = 0;
	//
	//# \desc
	//# The Sound Manager calls the $StartStream$ function when the sound to which the streamer is assigned is played.
	//# The $StartStream$ function must be implemented by each subclass of the $SoundStreamer$ class, and it should
	//# do whatever is necessary to prepare the stream for playing. The $StartStream$ function is called before the
	//# first call to $@SoundStreamer::FillBuffer@$ is made.
	//#
	//# The return value should be $kSoundOkay$ if the function is successful.
	//
	//# \also	$@SoundStreamer::StartStreamComponent@$
	//# \also	$@SoundStreamer::FillBuffer@$


	//# \function	SoundStreamer::StartStreamComponent		Called when a stream is looped.
	//
	//# \proto	virtual SoundResult StartStreamComponent(int32 index);
	//
	//# \param	index	The index of the component at which to continue the stream.
	//
	//# \desc
	//# The Sound Manager calls the $StartStreamComponent$ function when the sound to which the streamer is assigned
	//# loops. The $index$ parameter specifies the zero-based index of the component at which the stream should continue
	//# playing and is equal to the value set by the $@Sound::SetLoopIndex@$ function. If the index is greater than or
	//# equal to the number of components, then the stream should restart at the first component. By default, the
	//# $StartStreamComponent$ function simply calls the $@SoundStreamer::StartStream@$ function.
	//#
	//# The return value should be $kSoundOkay$ if the function is successful.
	//
	//# \also	$@SoundStreamer::StartStream@$
	//# \also	$@SoundStreamer::FillBuffer@$


	//# \function	SoundStreamer::FillBuffer		Called when audio data is needed.
	//
	//# \proto	virtual bool FillBuffer(unsigned_int32 bufferSize, Sample *buffer, int32 *count) = 0;
	//
	//# \param	bufferSize		The number of bytes of audio data that is needed.
	//# \param	buffer			A pointer to the buffer that is to receive the audio data.
	//# \param	count			A pointer to an integer that receives the total number of frames written to the buffer.
	//
	//# \desc
	//# The Sound Manager calls the $FillBuffer$ function when audio data is needed from a stream. The streamer
	//# should fill the buffer specified by the $buffer$ parameter with as many audio samples as possible without
	//# exceeding the byte count specified by the $bufferSize$ parameter. Each audio sample is 16 bits in size,
	//# and the data should be stored in little endian byte order.
	//#
	//# The value of $bufferSize$ will never be larger than the value of the $streamSize$ parameter passed to the
	//# $@SoundStreamer::AllocateStreamMemory@$ function. The actual number of audio frames written to the buffer
	//# should be written to the integer pointed to by the $count$ parameter.
	//#
	//# The return value should be $true$ if there is more audio data available in the stream after filling the buffer,
	//# and it should be $false$ if the end of the stream has been reached.
	//
	//# \special
	//# The $FillBuffer$ function can be called in the main thread or in a special streaming thread maintained by the
	//# Sound Manager. The implementation of this function should not make any assumptions about which thread it's
	//# running in, and it should take care to use proper multithreaded synchronization where necessary.
	//
	//# \also	$@SoundStreamer::StartStream@$
	//# \also	$@SoundStreamer::StartStreamComponent@$
	//# \also	$@SoundStreamer::AllocateStreamMemory@$


	class SoundStreamer
	{
		private:

			unsigned_int32			streamerState;

			int32					channelCount;
			int32					sampleRate;

			unsigned_int32			workBufferSize;
			unsigned_int32			streamBufferSize;

			char					*workBuffer;
			StreamBufferHeader		*streamBuffer[2];

		protected:

			C4API SoundStreamer();

			void Pause(void)
			{
				streamerState |= kSoundStreamerPaused;
			}

			void Resume(void)
			{
				streamerState &= ~kSoundStreamerPaused;
			}

			void SetStreamChannelCount(int32 count)
			{
				channelCount = count;
			}

			void SetStreamSampleRate(int32 rate)
			{
				sampleRate = rate;
			}

			unsigned_int32 GetWorkBufferSize(void) const
			{
				return (workBufferSize);
			}

			char *GetWorkBuffer(void) const
			{
				return (workBuffer);
			}

			C4API void AllocateStreamMemory(unsigned_int32 workSize, unsigned_int32 streamSize);
			C4API void ReleaseStreamMemory(void);

		public:

			C4API virtual ~SoundStreamer();

			bool Paused(void) const
			{
				return ((streamerState & kSoundStreamerPaused) != 0);
			}

			int32 GetStreamChannelCount(void) const
			{
				return (channelCount);
			}

			int32 GetStreamSampleRate(void) const
			{
				return (sampleRate);
			}

			unsigned_int32 GetStreamBufferSize(void) const
			{
				return (streamBufferSize);
			}

			StreamBufferHeader *GetStreamBuffer(int32 index) const
			{
				return (streamBuffer[index]);
			}

			C4API virtual int32 GetStreamFrameCount(void);

			C4API virtual SoundResult StartStream(void) = 0;
			C4API virtual SoundResult StartStreamComponent(int32 index);

			C4API virtual bool FillBuffer(unsigned_int32 bufferSize, Sample *buffer, int32 *count) = 0;
	};


	//# \class	WaveStreamer	A sound streamer object that streams audio data from the disk.
	//
	//# \def	class WaveStreamer : public SoundStreamer
	//
	//# \ctor	WaveStreamer();
	//
	//# \desc
	//# The $WaveStreamer$ class represents a streaming sound source that can be used to stream audio
	//# data from a compressed WAV file. Such a stream is composed of one or more resources that are
	//# specified by calling the $@WaveStreamer::AddComponent@$ function. Once a wave streamer object
	//# has been configured, it should be passed to the $@Sound::Stream@$ function.
	//
	//# \base	SoundStreamer	A $WaveStreamer$ is a specific type of sound streamer object.
	//
	//# \also	$@Sound::Stream@$
	//
	//# \wiki	Sound


	//# \function	WaveStreamer::AddComponent		Adds a component to a wave streamer.
	//
	//# \proto	SoundResult AddComponent(const char *name);
	//
	//# \param	name	The name of the sound resource.
	//
	//# \desc
	//# The $AddComponent$ function adds the resource specified by the $name$ parameter to the list of
	//# sound resources that will be streamed. If the resource cannot be opened, then an error is returned.
	//# If the resource is successfully opened, then the return value is $kSoundOkay$.
	//#
	//# Sounds will be played in the order in which they are specified through calls to $AddComponent$.
	//# When the end of one resource is reached, the stream continues immediately at the beginning of the
	//# next resource. The same resource name can be specified for multiple calls to the $AddComponent$
	//# function, if desired.
	//#
	//# Each WAV resource specified for a $WaveStreamer$ object must be stored in compressed 16-bit
	//# ADPCM 4:1 WAV format (mono or stereo). Otherwise, the result code $kSoundFormatInvalid$ is returned.


	class WaveStreamer : public SoundStreamer
	{
		private:

			List<SoundLoader>		soundLoaderList;
			SoundLoader				*currentSoundLoader;

			int32					blockFrameCount;
			int32					bufferBlockCount;
			unsigned_int32			compressedBlockSize;
			unsigned_int32			decompressedBlockSize;

			unsigned_int32			streamPosition;
			int32					frameNumber;
			int32					(*decompressor)(const char *, Sample *, int32, const PredictorCoefficient *);

			static int32 DecompressMonoBlock(const char *input, Sample *output, int32 frameCount, const PredictorCoefficient *coefficient);
			static int32 DecompressStereoBlock(const char *input, Sample *output, int32 frameCount, const PredictorCoefficient *coefficient);

		public:

			C4API WaveStreamer();
			C4API ~WaveStreamer();

			C4API SoundResult AddComponent(const char *name);

			int32 GetStreamFrameCount(void) override;

			SoundResult StartStream(void) override;
			SoundResult StartStreamComponent(int32 index) override;

			bool FillBuffer(unsigned_int32 bufferSize, Sample *buffer, int32 *count) override;
	};


	//# \class	SoundGroup		Represents a sound group.
	//
	//# \def	class SoundGroup : public MapElement<SoundGroup>, public LinkTarget<SoundGroup>
	//
	//# \ctor	SoundGroup(SoundGroupType type, const char *name);
	//
	//# \param	type	The unique type of the sound group.
	//# \param	name	A pointer to the name of the sound group.
	//
	//# \desc
	//# The $SoundGroup$ class represents a group to which sounds may belong. The volume for an entire
	//# group can be modified using the $@SoundGroup::SetVolume@$ function, and this volume is applied
	//# in addition to each sound's internal volume and the Sound Manager's master volume. The frequency
	//# for an entire group can be modified using the $@SoundGroup::SetFrequency@$ function, and this
	//# frequency is applied in addition to each sound's internal frequency.
	//#
	//# Every sound group must have a unique 32-bit identifier specified by the $type$ parameter.
	//# The $name$ parameter specifies the human-readable group name that is displayed in the World Editor.
	//#
	//# A sound group can be registered so that it appears in the World Editor by calling the
	//# $@SoundMgr::RegisterSoundGroup@$ function. A default sound group to which each sound initially
	//# belongs can be set by calling the $@SoundMgr::SetDefaultSoundGroup@$ function.
	//
	//# \base	Utilities/MapElement<SoundGroup>	Sound group objects are stored in a map using the type as a key.
	//# \base	Utilities/LinkTarget<SoundGroup>	Used internally by the Sound Manager.
	//
	//# \also	$@Sound::GetSoundGroup@$
	//# \also	$@Sound::SetSoundGroup@$
	//# \also	$@SoundMgr::GetDefaultSoundGroup@$
	//# \also	$@SoundMgr::SetDefaultSoundGroup@$
	//# \also	$@SoundMgr::RegisterSoundGroup@$


	//# \function	SoundGroup::GetSoundGroupType		Returns the sound group type.
	//
	//# \proto	SoundGroupType GetSoundGroupType(void) const;
	//
	//# \desc
	//# The $GetSoundGroupType$ function returns the unique type of a sound group.
	//
	//# \also	$@SoundGroup::GetSoundGroupName@$


	//# \function	SoundGroup::GetSoundGroupName		Returns the sound group type.
	//
	//# \proto	const char *GetSoundGroupName(void) const;
	//
	//# \desc
	//# The $GetSoundGroupName$ function returns the human-readable name of a sound group.
	//
	//# \also	$@SoundGroup::GetSoundGroupType@$


	//# \function	SoundGroup::GetVolume		Returns the volume of a sound group.
	//
	//# \proto	float GetVolume(void) const;
	//
	//# \desc
	//# The $GetVolume$ function returns the volume applied to all sounds that are members of a sound group.
	//#
	//# A sound is added to or removed from a sound group using the $@Sound::SetSoundGroup@$ function.
	//
	//# \also	$@SoundGroup::SetVolume@$
	//# \also	$@SoundGroup::GetFrequency@$
	//# \also	$@SoundGroup::SetFrequency@$
	//# \also	$@Sound::GetSoundGroup@$
	//# \also	$@Sound::SetSoundGroup@$


	//# \function	SoundGroup::SetVolume		Sets the volume of a sound group.
	//
	//# \proto	void SetVolume(float volume);
	//
	//# \param	volume		The new volume of the sound group. This should normally be in the range [0, 1].
	//
	//# \desc
	//# The $SetVolume$ function sets the volume applied to all sounds that are members of a sound group.
	//# The value specified for the $volume$ parameter multiplies the individual volume for each sound in
	//# a group to produce a final playback volume.
	//#
	//# A sound is added to or removed from a sound group using the $@Sound::SetSoundGroup@$ function.
	//
	//# \also	$@SoundGroup::GetVolume@$
	//# \also	$@SoundGroup::GetFrequency@$
	//# \also	$@SoundGroup::SetFrequency@$
	//# \also	$@Sound::GetSoundGroup@$
	//# \also	$@Sound::SetSoundGroup@$


	//# \function	SoundGroup::GetFrequency	Returns the frequency of a sound group.
	//
	//# \proto	float GetFrequency(void) const;
	//
	//# \desc
	//# The $GetFrequency$ function returns the relative frequency applied to all sounds that are members of a sound group.
	//#
	//# A sound is added to or removed from a sound group using the $@Sound::SetSoundGroup@$ function.
	//
	//# \also	$@SoundGroup::SetFrequency@$
	//# \also	$@SoundGroup::GetVolume@$
	//# \also	$@SoundGroup::SetVolume@$
	//# \also	$@Sound::GetSoundGroup@$
	//# \also	$@Sound::SetSoundGroup@$


	//# \function	SoundGroup::SetFrequency	Sets the frequency of a sound group.
	//
	//# \proto	void SetFrequency(float frequency);
	//
	//# \param	frequency		The new frequency of the sound group. This must be a positive number.
	//
	//# \desc
	//# The $SetFrequency$ function sets the relative frequency applied to all sounds that are members of a sound group.
	//# The value of the $frequency$ parameter multiplies the individual frequency of each sound in a group to produce a
	//# final playback frequency. A value of 1.0 (the default) means play at the frequency of the source data, a value of
	//# 0.5 means play at half the frequency, and so on. Values greater than 1.0 are allowed, but sound quality may
	//# be diminished.
	//#
	//# A sound is added to or removed from a sound group using the $@Sound::SetSoundGroup@$ function.
	//
	//# \also	$@SoundGroup::GetFrequency@$
	//# \also	$@SoundGroup::GetVolume@$
	//# \also	$@SoundGroup::SetVolume@$
	//# \also	$@Sound::GetSoundGroup@$
	//# \also	$@Sound::SetSoundGroup@$


	class SoundGroup : public MapElement<SoundGroup>, public LinkTarget<SoundGroup>
	{
		private:

			SoundGroupType		soundGroupType;
			const char			*soundGroupName;

			float				soundGroupVolume;
			float				soundGroupFrequency;

		public:

			typedef SoundGroupType KeyType;

			C4API SoundGroup(SoundGroupType type, const char *name);
			C4API ~SoundGroup();

			KeyType GetKey(void) const
			{
				return (soundGroupType);
			}

			SoundGroupType GetSoundGroupType(void) const
			{
				return (soundGroupType);
			}

			const char *GetSoundGroupName(void) const
			{
				return (soundGroupName);
			}

			float GetVolume(void) const
			{
				return (soundGroupVolume);
			}

			float GetFrequency(void) const
			{
				return (soundGroupFrequency);
			}

			C4API void SetVolume(float volume);
			C4API void SetFrequency(float frequency);
	};


	class SoundRoom : public LinkTarget<SoundRoom>, public ListElement<SoundRoom>
	{
		friend class SoundMgr;

		private:

			volatile int32		tableIndex;
			int32				roomMixCount;
			int32				maxRoomMixCount;

			Link<SoundRoom>		outputRoom;
			Point3D				roomPosition;
			float				roomVolume[2];

			Vector3D			roomSize;
			float				reflectionVolume;
			float				reflectionHFVolume;
			float				mediumHFAbsorption;
			float				reverbVolume;

			~SoundRoom();

		public:

			C4API SoundRoom(const Vector3D& size);

			SoundRoom *GetOutputRoom(void) const
			{
				return (outputRoom);
			}

			void SetOutputRoom(SoundRoom *room)
			{
				outputRoom = room;
			}

			const Point3D& GetRoomPosition(void) const
			{
				return (roomPosition);
			}

			const Vector3D& GetRoomSize(void) const
			{
				return (roomSize);
			}

			void SetRoomSize(const Vector3D& size)
			{
				roomSize = size;
			}

			float GetReflectionVolume(void) const
			{
				return (reflectionVolume);
			}

			void SetReflectionVolume(float volume)
			{
				reflectionVolume = volume;
			}

			float GetReflectionHFVolume(void) const
			{
				return (reflectionHFVolume);
			}

			void SetReflectionHFVolume(float volume)
			{
				reflectionHFVolume = volume;
			}

			float GetMediumHFAbsorption(void) const
			{
				return (mediumHFAbsorption);
			}

			void SetMediumHFAbsorption(float absorption)
			{
				mediumHFAbsorption = absorption;
			}

			C4API void Release(void);

			C4API void SetReverbDecayTime(float time);
			C4API void SetRoomPosition(const Point3D& position);
	};


	//# \class	Sound	Encapsulates functionality for a sound.
	//
	//# \def	class Sound : public Completable<Sound>, public ListElement<Sound>, public Memory<Sound>
	//
	//# \ctor	Sound();
	//
	//# \desc
	//# The $Sound$ class represents an audio source within the Sound Manager. The constructor simply initializes
	//# the internal state of the sound to default values and does nothing else. After a new $Sound$ object is
	//# constructed, either the $@Sound::Load@$ function should be called to load a sound resource or the
	//# $@Sound::Stream@$ function should be called to establish a streaming source for the sound.
	//#
	//# Sound objects cannot be explicitly destroyed by using the $delete$ operator. Sound objects should
	//# be released by calling the $@Sound::Release@$ function.
	//
	//# \note
	//# For sound effects placed in a 3D world, the high-level functionality provided by the
	//# $@WorldMgr/Source@$ node class is what an application should ordinarily use. The World Manager
	//# performs additional processing on $@WorldMgr/Source@$ nodes that is not available to sounds
	//# created with the low-level $Sound$ class. However, the $Sound$ class should be used for music
	//# and ambient sound effects that are not placed in 3D space.
	//
	//# \base	Utilities/Completable<Sound>	The completion procedure is called when the sound finishes playing.
	//# \base	Utilities/ListElement<Sound>	Used internally by the Sound Manager.
	//# \base	MemoryMgr/Memory<Sound>			Sound objects are allocated in a dedicated heap.
	//
	//# \also	$@WorldMgr/Source@$
	//
	//# \wiki	Sound


	//# \function	Sound::Load		Loads a sound resource into a $Sound$ object.
	//
	//# \proto	SoundResult Load(const char *name);
	//
	//# \param	name	The name of the sound resource.
	//
	//# \desc
	//# The $Load$ function loads the sound resource specified by the $name$ parameter into memory. The WAV
	//# resource must be stored in uncompressed 16-bit PCM WAV format (mono or stereo). Otherwise, the result
	//# code $kSoundFormatInvalid$ is be returned.
	//#
	//# A sound resource loaded into memory with the $Load$ function must contain fewer than 2<sup>21</sup> frames
	//# of audio data. For a mono sound, this means that the audio data must be smaller than 4 MB in size, and for
	//# a stereo sound, the audio data must be smaller than 8 MB in size. If this limit is exceeded, then the
	//# $Load$ function returns $kSoundTooLarge$.
	//#
	//# A sound is made nonpersistent when the $Load$ function is called, meaning that it will destroy itself
	//# once it has finished playing.
	//
	//# \also	$@Sound::Stream@$


	//# \function	Sound::Stream	Establishes a streaming source for a $Sound$ object.
	//
	//# \proto	SoundResult Stream(SoundStreamer *streamer);
	//
	//# \param	streamer	The streamer object to associate with the sound.
	//
	//# \desc
	//# The $Stream$ function assigns the $@SoundStreamer@$ object specified by the $streamer$ parameter to a
	//# sound object. The sound streamer should be allocated on the heap before calling this function, but
	//# once $Stream$ has been called, the sound object owns the sound streamer and will delete it automatically
	//# at the appropriate time.
	//#
	//# A sound is made persistent when the $Stream$ function is called, meaning that it must be explicitly
	//# destroyed when it is no longer in use.
	//
	//# \also	$@Sound::Load@$
	//# \also	$@SoundStreamer@$
	//# \also	$@WaveStreamer@$


	//# \div
	//# \function	Sound::GetSoundFlags		Returns the sound flags.
	//
	//# \proto	unsigned_int32 GetSoundFlags(void) const;
	//
	//# \desc
	//# The $GetSoundFlags$ function returns the sound flags, which can be a combination (through logical OR)
	//# of the following constants.
	//
	//# \table	SoundFlags
	//
	//# \also	$@Sound::SetSoundFlags@$


	//# \function	Sound::SetSoundFlags		Sets the sound flags.
	//
	//# \proto	void SetSoundFlags(unsigned_int32 flags);
	//
	//# \param	flags	The new sound flags.
	//
	//# \desc
	//# The $SetSoundFlags$ function sets the sound flags to the value specified by the $type$ parameter,
	//# which can be a combination (through logical OR) of the following constants.
	//
	//# \table	SoundFlags
	//
	//# \also	$@Sound::GetSoundFlags@$


	//# \function	Sound::GetSoundState	Returns a sound's current state.
	//
	//# \proto	SoundState GetSoundState(void) const;
	//
	//# \desc
	//# The $GetSoundState$ function returns a sound state code which indicates the whether the sound is
	//# stopped, playing, paused, etc. The code returned can be one of the following constants.
	//
	//# \table	SoundState
	//
	//# Upon construction, a sound object's initial state is $kSoundUnloaded$. After a successful call to
	//# the $@Sound::Load@$ function, the sound object's state is $kSoundStopped$.
	//
	//# \also	$@Sound::Play@$
	//# \also	$@Sound::Stop@$
	//# \also	$@Sound::Pause@$
	//# \also	$@Sound::Resume@$
	//# \also	$@Sound::Delay@$


	//# \div
	//# \function	Sound::Play		Plays a sound.
	//
	//# \proto	SoundResult Play(void);
	//
	//# \desc
	//# Calling the $Play$ function causes the sound to begin playing immediately. If the sound is
	//# already playing, then calling $Play$ again has no effect.
	//#
	//# If the sound is spatialized and has distance delay enabled (see $@Sound::SetSoundFlags@$), then
	//# the sound begins playing after a travel delay determined by the position of the listener. If the
	//# Doppler effect is also enabled, then the delay can be modified by the motion of both the sound
	//# and the listener so that the sound becomes audible at the correct time.
	//#
	//# When the sound finishes playing, its completion procedure is invoked. A completion procedure
	//# can be installed by using the $@Utilities/Completable::SetCompletionProc@$ function.
	//#
	//# The $Play$ function returns one of the following sound result codes.
	//
	//# \value	kSoundOkay 			The sound has successfully begun playing.
	//# \value	kSoundPlayFailed 	There are too many sounds playing. In this case, the sound object
	//#								behaves as if it had played through and completed. The completion
	//#								procedure is still invoked, and nonpersistent sounds are still destroyed.
	//
	//# \special
	//# If a sound object is nonpersistent (the default for non-streamed sounds), then it should never
	//# be referenced after the $Play$ function has been called for it. Nonpersistent sound objects
	//# automatically self-destruct when they have finished playing, making any subsequent references
	//# to the object illegal.
	//
	//# \also		$@Sound::Stop@$
	//# \also		$@Sound::Pause@$


	//# \function	Sound::Stop		Stops a sound.
	//
	//# \proto	void Stop(void);
	//
	//# \desc
	//# Calling the $Stop$ function stops the sound immediately. If the sound is not playing, then calling
	//# $Stop$ has no effect. When a sound is explicitly stopped by using the $Stop$ function, its
	//# completion procedure is not invoked.
	//
	//# \special
	//# If a sound object is nonpersistent (the default for non-streamed sounds), then calling $Stop$
	//# causes it to be destroyed. The $Stop$ function should be called for nonpersistent sound objects
	//# only if they are known to be playing. The only way to be absolutely sure that a sound object is
	//# still playing is to set its loop count to $kSoundLoopInfinite$ using the $@Sound::SetLoopCount@$ function
	//# before it is played.
	//
	//# \also		$@Sound::Play@$
	//# \also		$@Sound::Pause@$


	//# \function	Sound::Delay		Plays a sound after a given delay time.
	//
	//# \proto	void Delay(int32 time);
	//
	//# \param	time	The delay time, in milliseconds.
	//
	//# \desc
	//# Calling $Delay$ schedules the sound object to be played after $time$ milliseconds have elapsed.
	//# Once the delay period has passed, the sound is played just as if the $@Sound::Play@$ function had been called.
	//#
	//# If the $@Sound::Stop@$ function is called for a sound that is scheduled to play because the $Delay$ function
	//# was previously called, then the play command is canceled. If the $@Sound::Pause@$ function is called for a
	//# sound that is scheduled to play, then the time between the first $@Sound::Pause@$ call and the balancing
	//# $@Sound::Resume@$ call is not counted against the delay time. That is, the delay is paused as if
	//# the sound was playing silence until it was scheduled to begin playing.
	//
	//# \also		$@Sound::Play@$
	//# \also		$@Sound::Pause@$


	//# \function	Sound::Pause		Pauses a sound.
	//
	//# \proto	void Pause(void);
	//
	//# \desc
	//# The $Pause$ function pauses a sound at its current position. The sound can be resumed by calling
	//# the $@Sound::Resume@$ function. If the sound is not playing, then the $Pause$ function has no effect.
	//#
	//# If the $Pause$ function is called multiple times for the same sound, then each call must be
	//# balanced by a call to the $@Sound::Resume@$ function before the sound will continue playing
	//# (i.e., the sound keeps track of an internal pause count).
	//#
	//# If the $Pause$ function is called for a sound that is scheduled to play because the $@Sound::Delay@$
	//# function was previously called, then the time between the first $Pause$ call and the balancing
	//# $@Sound::Resume@$ call is not counted against the delay time. That is, the delay is paused as if
	//# the sound was playing silence until it was scheduled to begin playing.
	//
	//# \also		$@Sound::Resume@$
	//# \also		$@Sound::Stop@$


	//# \function	Sound::Resume		Resumes a sound.
	//
	//# \proto	void Resume(void);
	//
	//# \desc
	//# The $Resume$ function resumes a previously paused sound. If the sound is not paused, then
	//# the $Resume$ function has no effect. A sound will not resume playing until the $Resume$ function
	//# has been called to balance each previous call to the $@Sound::Pause@$ function
	//# (i.e., the sound keeps track of an internal pause count).
	//
	//# \also		$@Sound::Pause@$


	//# \function	Sound::Release		Releases a sound.
	//
	//# \proto	void Release(void);
	//
	//# \desc
	//# The $Release$ function should be called when the sound object is no longer being used.
	//# Sound objects cannot be destroyed using the $delete$ operator. If the sound is playing when
	//# $Release$ is called, then the sound is immediately stopped.


	//# \div
	//# \function	Sound::VaryVolume		Varies the volume of a sound over a specific time period.
	//
	//# \proto	void VaryVolume(float volume, int32 time, bool stop = false);
	//
	//# \param	volume		The new volume to which the sound should be gradually changed.
	//# \param	time		The time interval, in milliseconds, over which the variation should occur.
	//# \param	stop		Indicates whether the sound should be stopped at the end of the variation.
	//
	//# \desc
	//# The $VaryVolume$ function varies the volume of a sound to that given by the $volume$ parameter over
	//# the time interval given by the $time$ parameter.
	//#
	//# If the $stop$ parameter is $true$, then the sound is stopped at the end of the variation period, and the
	//# volume variation completion procedure is called, if any. If the sound is nonpersistent, then it is released at this point.
	//#
	//# If the $time$ parameter is less than or equal to zero, then the sound's volume is set to $volume$
	//# immediately. If the $stop$ parameter is $true$ in this case, then the sound is stopped before the
	//# $VaryVolume$ function returns.
	//#
	//# It can be determined whether a sound's volume is currently being varied by calling the $@Sound::VolumeVarying@$ function.
	//
	//# \also		$@Sound::VolumeVarying@$
	//# \also		$@Sound::SetVolumeVariationCompletionProc@$
	//# \also		$@Sound::VaryFrequency@$


	//# \function	Sound::VaryFrequency	Varies the frequency of a sound over a specific time period.
	//
	//# \proto	void VaryFrequency(float frequency, int32 time, bool stop = false);
	//
	//# \param	frequency	The new frequency to which the sound should be gradually changed.
	//# \param	time		The time interval, in milliseconds, over which the variation should occur.
	//# \param	stop		Indicates whether the sound should be stopped at the end of the variation.
	//
	//# \desc
	//# The $VaryFrequency$ function varies the frequency of a sound to that given by the $frequency$ parameter over
	//# the time interval given by the $time$ parameter.
	//#
	//# If the $stop$ parameter is $true$, then the sound is stopped at the end of the variation period, and the
	//# frequency variation completion procedure is called, if any. If the sound is nonpersistent, then it is released at this point.
	//#
	//# If the $time$ parameter is less than or equal to zero, then the sound's frequency is set to $frequency$
	//# immediately. If the $stop$ parameter is $true$ in this case, then the sound is stopped before the
	//# $VaryFrequency$ function returns.
	//#
	//# It can be determined whether a sound's frequency is currently being varied by calling the $@Sound::FrequencyVarying@$ function.
	//
	//# \also		$@Sound::FrequencyVarying@$
	//# \also		$@Sound::SetFrequencyVariationCompletionProc@$
	//# \also		$@Sound::VaryVolume@$


	//# \function	Sound::VolumeVarying		Returns a boolean value indicating whether a sound's volume is being varied.
	//
	//# \proto	bool VolumeVarying(void) const;
	//
	//# \desc
	//# The $VolumeVarying$ function returns $true$ if the sound's volume is currently being varied; otherwise it returns $false$.
	//# If the sound is not playing, then the $VolumeVarying$ function always returns $false$.
	//
	//# \also		$@Sound::VaryVolume@$
	//# \also		$@Sound::FrequencyVarying@$


	//# \function	Sound::FrequencyVarying		Returns a boolean value indicating whether a sound's frequency is being varied.
	//
	//# \proto	bool FrequencyVarying(void) const;
	//
	//# \desc
	//# The $FrequencyVarying$ function returns $true$ if the sound's frequency is currently being varied; otherwise it returns $false$.
	//# If the sound is not playing, then the $FrequencyVarying$ function always returns $false$.
	//
	//# \also		$@Sound::VaryFrequency@$
	//# \also		$@Sound::VolumeVarying@$


	//# \function	Sound::SetVolumeVariationCompletionProc		Installs a callback procedure that is invoked when a volume variation has completed.
	//
	//# \proto	void SetVolumeVariationCompletionProc(VariationProc *proc, void *cookie = nullptr);
	//
	//# \param	proc	The volume variation callback procedure. This parameter may be $nullptr$, in which case the sound has no volume variation callback procedure.
	//# \param	cookie	The cookie that is passed to the volume variation callback procedure as its last parameter.
	//
	//# \desc
	//# The $SetVolumeVariationCompletionProc$ function installs a callback procedure that is invoked every time that a
	//# volume variation operation completes for the sound for which it is installed. The $VariationProc$ type is defined as follows.
	//
	//# \code	typedef void VariationProc(Sound *, void *);
	//
	//# When the function pointed to by the $proc$ parameter is called, the pointer to the sound object and the value supplied
	//# in the $cookie$ parameter are passed to it. By default, there is no volume variation callback procedure installed.
	//
	//# \also		$@Sound::VaryVolume@$
	//# \also		$@Sound::VolumeVarying@$
	//# \also		$@Sound::SetFrequencyVariationCompletionProc@$


	//# \function	Sound::SetFrequencyVariationCompletionProc		Installs a callback procedure that is invoked when a frequency variation has completed.
	//
	//# \proto	void SetFrequencyVariationCompletionProc(VariationProc *proc, void *cookie = nullptr);
	//
	//# \param	proc	The frequency variation callback procedure. This parameter may be $nullptr$, in which case the sound has no frequency variation callback procedure.
	//# \param	cookie	The cookie that is passed to the frequency variation callback procedure as its last parameter.
	//
	//# \desc
	//# The $SetFrequencyVariationCompletionProc$ function installs a callback procedure that is invoked every time that a
	//# frequency variation operation completes for the sound for which it is installed. The $VariationProc$ type is defined as follows.
	//
	//# \code	typedef void VariationProc(Sound *, void *);
	//
	//# When the function pointed to by the $proc$ parameter is called, the pointer to the sound object and the value supplied
	//# in the $cookie$ parameter are passed to it. By default, there is no frequency variation callback procedure installed.
	//
	//# \also		$@Sound::VaryFrequency@$
	//# \also		$@Sound::FrequencyVarying@$
	//# \also		$@Sound::SetVolumeVariationCompletionProc@$


	//# \div
	//# \function	Sound::GetDuration		Returns the duration of a sound.
	//
	//# \proto	int32 GetDuration(void) const;
	//
	//# \desc
	//# The $GetDuration$ function returns the duration of a sound in milliseconds. If the sound is
	//# streaming and has multiple resources in its play list, then the $GetDuration$ function returns
	//# the sum of the durations of those resources.


	//# \function	Sound::GetSoundProperty		Returns a sound property.
	//
	//# \proto	float GetSoundProperty(int32 property) const;
	//
	//# \param	property	The identifier of the property to return.
	//
	//# \desc
	//# The $GetSoundProperty$ function returns one of the sound properties listed below.
	//
	//# \table	SoundProperty
	//
	//# \also	$@Sound::SetSoundProperty@$


	//# \function	Sound::SetSoundProperty		Sets a sound property.
	//
	//# \proto	void SetSoundProperty(int32 property, float value);
	//
	//# \param	property	The identifier of the property to set.
	//# \param	value		The new value of the property.
	//
	//# \desc
	//# The $SetSoundProperty$ function sets one of the sound properties listed below.
	//
	//# \table	SoundProperty
	//
	//# Values for volume-related properties are typically in the range [0, 1], but values outside this
	//# range are acceptable. The $kSoundVolume$ property is a master volume for the sound, and all other
	//# volumes are relative to it. The final volume of a sound is further modified by the master volume
	//# set in the Sound Manager (see $@SoundMgr::SetMasterVolume@$) and the volume set for the sound's
	//# group, if any (see $@SoundGroup::SetVolume@$).
	//#
	//# The $kSoundFrequency$ property is a multiplier that affects the playback frequency of a sound.
	//# A value of 1.0 means that the sound is played back at its native frequency. If the Doppler shift is
	//# enabled for a sound (see $@Sound::SetSoundFlags@$), then it is applied in addition to the frequency property.
	//#
	//# Properties having to do with sound cones are applied only if the $kSoundCones$ flag is set.
	//
	//# \also	$@Sound::GetSoundProperty@$
	//# \also	$@Sound::GetSoundFlags@$
	//# \also	$@Sound::SetSoundFlags@$
	//# \also	$@SoundGroup::GetVolume@$
	//# \also	$@SoundGroup::SetVolume@$
	//# \also	$@SoundMgr::GetMasterVolume@$
	//# \also	$@SoundMgr::SetMasterVolume@$


	//# \function	Sound::GetLoopCount		Returns the number of times that a sound will loop.
	//
	//# \proto	int32 GetLoopCount(void) const;
	//
	//# \desc
	//# The $GetLoopCount$ function returns the number of times that the sound will loop when it is played.
	//# If the sound is set to loop forever, the constant $kSoundLoopInfinite$ is returned. The loop count can be
	//# set by calling the $@Sound::SetLoopCount@$ function.
	//#
	//# A sound's initial loop count is 1.
	//
	//# \also	$@Sound::SetLoopCount@$
	//# \also	$@Sound::GetLoopIndex@$
	//# \also	$@Sound::SetLoopIndex@$
	//# \also	$@Sound::SetLoopProc@$


	//# \function	Sound::SetLoopCount		Sets the number of times that a sound will loop.
	//
	//# \proto	void SetLoopCount(int32 count);
	//
	//# \param	count	The loop count. The constant $kSoundLoopInfinite$ causes the sound to loop forever.
	//
	//# \desc
	//# The $SetLoopCount$ function sets the number of times that the sound will loop when it is played
	//# to the value specified by the $count$ parameter. The constant $kSoundLoopInfinite$ may be used to cause
	//# a sound to loop indefinitely.
	//#
	//# When a sound loops, its loop callback procedure is invoked, if one has been installed using the
	//# $@Sound::SetLoopProc@$ function.
	//#
	//# Streamed sounds may have multiple resources concatenated and played in succession. When the end of
	//# the last resource in the list is reached, the sound may loop to any of the resources in the list. The
	//# index of the resource which will begin playing when the sound loops is set using the
	//# $@Sound::SetLoopIndex@$ function.
	//
	//# \also	$@Sound::GetLoopCount@$
	//# \also	$@Sound::GetLoopIndex@$
	//# \also	$@Sound::SetLoopIndex@$
	//# \also	$@Sound::SetLoopProc@$


	//# \function	Sound::GetLoopIndex		Returns the index of the resource in a streaming sound's play list which will be played when the sound loops.
	//
	//# \proto	int32 GetLoopIndex(void) const;
	//
	//# \desc
	//# Streamed sounds may have multiple resources concatenated and played in succession. When the end of
	//# the last resource in the list is reached, the sound may loop to any of the resources in the list.
	//# The $GetLoopIndex$ function returns the zero-based index of the resource which will begin playing
	//# when the sound loops.
	//#
	//# A sound's initial loop index is 0.
	//
	//# \also	$@Sound::SetLoopIndex@$
	//# \also	$@Sound::GetLoopCount@$
	//# \also	$@Sound::SetLoopCount@$
	//# \also	$@Sound::SetLoopProc@$


	//# \function	Sound::SetLoopIndex		Sets the index of the resource in a streaming sound's play list which will be played when the sound loops.
	//
	//# \proto	void SetLoopIndex(int32 index);
	//
	//# \param	index	The zero-based index of the resource which should be replayed when the sound loops.
	//
	//# \desc
	//# Streamed sounds may have multiple resources concatenated and played in succession. When the end of
	//# the last resource in the list is reached, the sound may loop to any of the resources in the list.
	//# The $SetLoopIndex$ function sets the index of the resource which will begin playing when the sound
	//# loops to that given by the $index$ parameter.
	//
	//# \also	$@Sound::GetLoopIndex@$
	//# \also	$@Sound::GetLoopCount@$
	//# \also	$@Sound::SetLoopCount@$
	//# \also	$@Sound::SetLoopProc@$


	//# \function	Sound::SetLoopProc		Installs a callback procedure which is invoked when a sound loops.
	//
	//# \proto	void SetLoopProc(LoopProc *proc, void *cookie = nullptr);
	//
	//# \param	proc	The loop callback procedure. This parameter may be $nullptr$, in which case
	//#					the sound has no loop callback procedure.
	//# \param	cookie	The cookie that is passed to the loop callback procedure as its last parameter.
	//
	//# \desc
	//# The $SetLoopProc$ function sets the callback procedure which is invoked when the sound loops to
	//# that given by the $proc$ parameter. The $LoopProc$ type is defined as
	//
	//# \code	typedef void LoopProc(Sound *, void *);
	//
	//# When the function pointed to by the $proc$ parameter is called, the pointer to the sound object
	//# and the value supplied in the $cookie$ parameter are passed to it. By default, there is no loop
	//# callback procedure installed.
	//#
	//# If the proc parameter is $nullptr$, then no callback is made when the sound loops.
	//
	//# \also	$@Sound::GetLoopCount@$
	//# \also	$@Sound::SetLoopCount@$
	//# \also	$@Sound::GetLoopIndex@$
	//# \also	$@Sound::SetLoopIndex@$


	//# \div
	//# \function	Sound::GetSoundGroup		Returns a sound's group.
	//
	//# \proto	SoundGroup *GetSoundGroup(void) const;
	//
	//# \desc
	//# The $GetSoundGroup$ function returns a pointer to the sound's group. If the sound if not a member of
	//# a group, then the return value is $nullptr$.
	//
	//# \also	$@Sound::SetSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \function	Sound::SetSoundGroup		Sets a sound's group.
	//
	//# \proto	void SetSoundGroup(SoundGroup *group);
	//
	//# \param	group	The group to which the sound should be made a member. This can be $nullptr$.
	//
	//# \desc
	//# The $SetSoundGroup$ function sets a sound's group to that given by the $group$ parameter. If the
	//# $group$ parameter is $nullptr$, then the sound is not a member of any group.
	//#
	//# When a sound is loaded using the $@Sound::Load@$ function, it is added to the default sound group,
	//# specified with the $@SoundMgr::SetDefaultSoundGroup@$ function.
	//
	//# \also	$@Sound::GetSoundGroup@$
	//# \also	$@SoundMgr::SetDefaultSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \div
	//# \function	Sound::GetTransformable		Returns a sound's 3D transform.
	//
	//# \proto	const Transformable *GetTransformable(void) const;
	//
	//# \desc
	//# The $GetTransformable$ function returns a pointer to a sound's 3D transform.
	//# The 3D transform is used when performing spatialization for the sound. Initially, a sound
	//# has no 3D transform and the pointer returned by the $GetTransformable$ function is $nullptr$.
	//
	//# \also	$@Sound::SetTransformable@$
	//# \also	$@Utilities/Transformable@$


	//# \function	Sound::SetTransformable		Sets a sound's 3D transform.
	//
	//# \proto	void SetTransformable(const Transformable *transformable);
	//
	//# \param	transformable	A pointer to the sound's 3D transform. This may be $nullptr$, in which case
	//#							the transform is the identity.
	//
	//# \desc
	//# The $SetTransformable$ function sets a sound's 3D transform. The 3D transform is necessary
	//# for proper 3D spatialization and must be set if the $kSoundSpatialized$ flag is set (see $@Sound::SetSoundFlags@$).
	//# The transform pointed to by the $transformable$ parameter must remain valid while the sound
	//# object refers to it&mdash;the transform is not copied.
	//#
	//# The transform represents the transformation from the sound's local coordinate system to world space.
	//# The fourth column of the world transform represents the world-space position of the sound, and the
	//# first column (corresponding to the local <i>x</i> axis) represents the world-space direction of
	//# the sound.
	//
	//# \also	$@Sound::GetTransformable@$
	//# \also	$@Utilities/Transformable@$


	//# \function	Sound::GetVelocity		Returns a sound's 3D velocity.
	//
	//# \proto	const Vector3D& GetVelocity(void) const;
	//
	//# \desc
	//# The $GetVelocity$ function returns the world-space velocity of the sound in units of meters per second.
	//# The listener's velocity is subtracted from the sound's velocity in order to calculate the Doppler effect.
	//# The initial velocity is the zero vector.
	//
	//# \also	$@Sound::SetVelocity@$
	//# \also	$@SoundMgr::GetListenerVelocity@$
	//# \also	$@SoundMgr::SetListenerVelocity@$


	//# \function	Sound::SetVelocity		Sets a sound's 3D velocity.
	//
	//# \proto	void SetVelocity(const Vector3D& velocity);
	//
	//# \param	velocity		The 3D velocity, in units of meters per second.
	//
	//# \desc
	//# The $SetVelocity$ function sets the world-space velocity of the sound to the vector given by the
	//# $velocity$ parameter. The velocity is measured in units of meters per second. The listener's velocity
	//# is subtracted from the sound's velocity in order to calculate the Doppler effect.
	//
	//# \also	$@Sound::GetVelocity@$
	//# \also	$@SoundMgr::GetListenerVelocity@$
	//# \also	$@SoundMgr::SetListenerVelocity@$


	class Sound : public Completable<Sound>, public ListElement<Sound>, public EngineMemory<Sound>
	{
		friend class SoundMgr;
		friend class SoundLoader;
		friend class SoundGroup;

		public:

			typedef void LoopProc(Sound *, void *);
			typedef void VariationProc(Sound *, void *);

		private:

			struct VariationParams
			{
				float			targetValue;
				float			deltaValue;
				VariationProc	*completionProc;
				void			*completionCookie;
			};

			unsigned_int32				soundFlags;
			int32						soundPriority;

			int32						tableIndex;
			volatile SoundState			soundState;

			volatile bool				mainReleaseFlag;
			volatile bool				mixerReleaseFlag;
			volatile bool				streamReleaseFlag;

			volatile bool				mixFlag;
			volatile bool				loopFlag;
			volatile int32				waitMixStamp;

			SoundResource				*soundResource;
			SoundStreamer				*soundStreamer;

			const Sample				*soundSampleData;
			int32						soundFrameCount;

			int32						playFrame;
			int32						playBuffer;

			int32						channelCount;
			int32						sampleRate;
			float						sampleFrequency;

			unsigned_int32				updateFlags;
			int32						delayTime;
			int32						startTime;
			int32						pauseCount;

			Link<SoundGroup>			soundGroup;
			float						soundProperty[kSoundPropertyCount];

			int32						loopCount;
			int32						loopIndex;
			LoopProc					*loopProc;
			void						*loopCookie;

			unsigned_int32				variationState;
			VariationParams				volumeVariationParams;
			VariationParams				frequencyVariationParams;

			const Transformable			*soundTransformable;
			Vector3D					soundVelocity;

			int32						soundPathCount;
			SoundPathData				soundPathData[kMaxSoundPathCount];

			Link<SoundRoom>				soundRoom;
			SoundMixData				soundMixData;

			~Sound();

			void FillStreamBuffer(SoundStreamer *streamer, StreamBufferHeader *buffer);

			float CalculateVolume(float distance) const;

			void UpdateVolume(void);
			void UpdateFrequency(void);
			void UpdateReflections(void);

		public:

			C4API Sound();

			unsigned_int32 GetSoundFlags(void) const
			{
				return (soundFlags);
			}

			void SetSoundFlags(unsigned_int32 flags)
			{
				soundFlags = flags;
			}

			SoundState GetSoundState(void) const
			{
				return (soundState);
			}

			int32 GetSoundPriority(void) const
			{
				return (soundPriority);
			}

			void SetSoundPriority(int32 priority)
			{
				soundPriority = priority;
			}

			const SoundResource *GetSoundResource(void) const
			{
				return (soundResource);
			}

			SoundStreamer *GetSoundStreamer(void) const
			{
				return (soundStreamer);
			}

			const Sample *GetSampleData(void) const
			{
				return (soundSampleData);
			}

			int32 GetFrameCount(void) const
			{
				return (soundFrameCount);
			}

			int32 GetPlayFrame(void) const
			{
				return (playFrame);
			}

			int32 GetPlayBuffer(void) const
			{
				return (playBuffer);
			}

			int32 GetChannelCount(void) const
			{
				return (channelCount);
			}

			int32 GetSampleRate(void) const
			{
				return (sampleRate);
			}

			bool Streaming(void) const
			{
				return (soundStreamer != nullptr);
			}

			int32 GetStartTime(void) const
			{
				return (startTime);
			}

			void SetStartTime(int32 time)
			{
				startTime = time;
			}

			SoundGroup *GetSoundGroup(void) const
			{
				return (soundGroup);
			}

			void SetSoundGroup(SoundGroup *group)
			{
				soundGroup = group;
				updateFlags |= kSoundUpdateVolume;
			}

			float GetSoundProperty(int32 property) const
			{
				return (soundProperty[property]);
			}

			void SetSoundProperty(int32 property, float value)
			{
				soundProperty[property] = value;
				updateFlags |= kSoundUpdateVolume | kSoundUpdateFrequency;
			}

			int32 GetLoopCount(void) const
			{
				return (loopCount);
			}

			void SetLoopCount(int32 count)
			{
				loopCount = count;
			}

			int32 GetLoopIndex(void) const
			{
				return (loopIndex);
			}

			void SetLoopIndex(int32 index)
			{
				loopIndex = index;
			}

			void SetLoopProc(LoopProc *proc, void *cookie = nullptr)
			{
				loopProc = proc;
				loopCookie = cookie;
			}

			bool VolumeVarying(void) const
			{
				return ((variationState & kSoundVaryingVolume) != 0);
			}

			bool FrequencyVarying(void) const
			{
				return ((variationState & kSoundVaryingFrequency) != 0);
			}

			void SetVolumeVariationCompletionProc(VariationProc *proc, void *cookie = nullptr)
			{
				volumeVariationParams.completionProc = proc;
				volumeVariationParams.completionCookie = cookie;
			}

			void SetFrequencyVariationCompletionProc(VariationProc *proc, void *cookie = nullptr)
			{
				frequencyVariationParams.completionProc = proc;
				frequencyVariationParams.completionCookie = cookie;
			}

			const Transformable *GetTransformable(void) const
			{
				return (soundTransformable);
			}

			void SetTransformable(const Transformable *transformable)
			{
				soundTransformable = transformable;
			}

			const Vector3D& GetVelocity(void) const
			{
				return (soundVelocity);
			}

			void SetVelocity(const Vector3D& velocity)
			{
				soundVelocity = velocity;
			}

			void SetSoundPathCount(int32 count)
			{
				soundPathCount = count;
			}

			void SetSoundPathData(int32 index, const Point3D *position, float length)
			{
				soundPathData[index].soundPosition = position;
				soundPathData[index].soundPathLength = length;
			}

			SoundRoom *GetSoundRoom(void) const
			{
				return (soundRoom);
			}

			C4API void Release(void);

			void SetSoundRoom(SoundRoom *room);

			C4API SoundResult Load(const char *name);
			C4API SoundResult Stream(SoundStreamer *streamer, bool external = false);

			C4API SoundResult Play(void);
			C4API void Stop(void);
			C4API void Delay(int32 time);
			C4API void Pause(void);
			C4API void Resume(void);

			C4API void VaryVolume(float volume, int32 time, bool stop = false);
			C4API void VaryFrequency(float frequency, int32 time, bool stop = false);

			C4API int32 GetDuration(void) const;
	};


	//# \class	SoundMgr	The Sound Manager class.
	//
	//# \def	class SoundMgr : public Manager<SoundMgr>
	//
	//# \desc
	//# The $SoundMgr$ class encapsulates the sound and music functionality of the C4 Engine.
	//# The single instance of the Sound Manager is constructed during an application's initialization
	//# and destroyed at termination.
	//#
	//# The Sound Manager's member functions are accessed through the global pointer $TheSoundMgr$.
	//
	//# \also	$@Sound@$


	//# \function	SoundMgr::GetMasterVolume		Returns the master volume that is applied to all sounds.
	//
	//# \proto	float GetMasterVolume(void) const;
	//
	//# \desc
	//# The $GetMasterVolume$ function returns the master volume that is applied to all sounds.
	//# The volume of any particular sound is determined by multiplying the master volume by the sound's
	//# group volume, if any, and by the volume of the sound itself.
	//
	//# \also	$@SoundMgr::SetMasterVolume@$
	//# \also	$@SoundGroup::GetVolume@$
	//# \also	$@SoundGroup::SetVolume@$
	//# \also	$@Sound::GetSoundProperty@$
	//# \also	$@Sound::SetSoundProperty@$


	//# \function	SoundMgr::SetMasterVolume		Sets the master volume that is applied to all sounds.
	//
	//# \proto	void SetMasterVolume(float volume);
	//
	//# \param	volume		The new master volume.
	//
	//# \desc
	//# The $SetMasterVolume$ function sets the master volume that is applied to all sounds.
	//# The volume of any particular sound is determined by multiplying the master volume by the sound's
	//# group volume, if any, and by the volume of the sound itself.
	//#
	//# A volume setting of 1.0 represents full intensity and a volume setting of 0.0 represents silence.
	//# The master volume is initially set to 1.0.
	//
	//# \also	$@SoundMgr::GetMasterVolume@$
	//# \also	$@SoundGroup::GetVolume@$
	//# \also	$@SoundGroup::SetVolume@$
	//# \also	$@Sound::GetSoundProperty@$
	//# \also	$@Sound::SetSoundProperty@$


	//# \function	SoundMgr::GetGlobalSoundSpeed		Returns the global speed of sound.
	//
	//# \proto	float GetGlobalSoundSpeed(void) const;
	//
	//# \desc
	//# The $GetGlobalSoundSpeed$ function returns the global speed. This speed is used in calculations
	//# involving the Doppler effect and distance delays. The return value is in units of meters per second.
	//# The default speed of sound is 343.0&nbsp;m/s.
	//
	//# \also	$@SoundMgr::SetGlobalSoundSpeed@$
	//# \also	$@Sound::SetSoundFlags@$


	//# \function	SoundMgr::SetGlobalSoundSpeed		Sets the global speed of sound.
	//
	//# \proto	void SetGlobalSoundSpeed(float speed);
	//
	//# \param	speed		The new speed of sound, in units of meters per second.
	//
	//# \desc
	//# The $SetGlobalSoundSpeed$ function sets the global speed of sound. This speed is used in calculations
	//# involving the Doppler effect and distance delays. The default speed of sound is 343.0&nbsp;m/s.
	//
	//# \also	$@SoundMgr::GetGlobalSoundSpeed@$
	//# \also	$@Sound::SetSoundFlags@$


	//# \function	SoundMgr::GetListenerTransformable		Returns the listener's 3D transform.
	//
	//# \proto	const Transformable *GetListenerTransformable(void) const;
	//
	//# \desc
	//# The $GetListenerTransformable$ function returns a pointer to the listener's 3D transform.
	//# The 3D transform is used when performing spatialization for all sounds that are placed in 3D space.
	//# Initially, the listener has no 3D transform, and the pointer returns by the $GetListenerTransformable$
	//# function is $nullptr$.
	//
	//# \also	$@SoundMgr::SetListenerTransformable@$
	//# \also	$@Sound::GetTransformable@$
	//# \also	$@Sound::SetTransformable@$
	//# \also	$@Utilities/Transformable@$


	//# \function	SoundMgr::SetListenerTransformable		Sets the listener's 3D transform.
	//
	//# \proto	void SetListenerTransformable(const Transformable *transformable);
	//
	//# \param	transformable	A pointer to the listener's 3D transform. This may be $nullptr$, in which
	//#							case the transform is the identity.
	//
	//# \desc
	//# The $SetListenerTransformable$ function sets the listener's 3D transform. This transform represents
	//# the position and orientation of the listener and is used to place sounds in 3D space. The transform
	//# pointed to by the $transformable$ parameter must remain valid while being used by the Sound
	//# Manager&mdash;the transform is not copied.
	//#
	//# The transform represents the transformation from the listener's local coordinate system to world space.
	//# The fourth column of the world transform represents the world-space position of the listener, and the
	//# third column (corresponding to the local <i>z</i> axis) represents the world-space direction in
	//# which the listener is facing. The first and second columns (corresponding to the local <i>x</i> and
	//# <i>y</i> axes) represent the right direction and down direction, respectively. This configuration
	//# is identical to the camera space used by the $@WorldMgr/Camera@$ class.
	//
	//# \also	$@SoundMgr::GetListenerTransformable@$
	//# \also	$@Sound::GetTransformable@$
	//# \also	$@Sound::SetTransformable@$
	//# \also	$@Utilities/Transformable@$


	//# \function	SoundMgr::GetListenerVelocity		Returns the listener's 3D velocity.
	//
	//# \proto	const Vector3D& GetListenerVelocity(void) const;
	//
	//# \desc
	//# The $GetListenerVelocity$ function returns the listener's 3D velocity in world space coordinates.
	//# The listener's velocity is subtracted from the velocity of each sound when the doppler effect is calculated.
	//# The listener's velocity is measured in units of meters per second and is initially set to the zero vector.
	//
	//# \also	$@SoundMgr::SetListenerVelocity@$
	//# \also	$@Sound::GetVelocity@$
	//# \also	$@Sound::SetVelocity@$


	//# \function	SoundMgr::SetListenerVelocity		Sets the listener's 3D velocity.
	//
	//# \proto	void SetListenerVelocity(const Vector3D& velocity);
	//
	//# \param	velocity	The listener's velocity in units of meters per second.
	//
	//# \desc
	//# The $SetListenerVelocity$ function sets the listener's 3D velocity in world space coordinates to
	//# the vector given by the $velocity$ parameter. The listener's velocity is subtracted from the
	//# velocity of each sound when the doppler effect is calculated. The listener's velocity is measured
	//# in units of meters per second and is initially set to the zero vector.
	//
	//# \also	$@SoundMgr::GetListenerVelocity@$
	//# \also	$@Sound::GetVelocity@$
	//# \also	$@Sound::SetVelocity@$


	//# \div
	//# \function	SoundMgr::StopAllSounds		Stops all sounds which are currently playing.
	//
	//# \proto	void StopAllSounds(void);
	//
	//# \desc
	//# The $StopAllSounds$ function stops all sounds which are currently playing, paused, or scheduled to
	//# be played. Any of these sounds that are nonpersistent are released.
	//
	//# \also	$@SoundMgr::PauseAllSounds@$
	//# \also	$@SoundMgr::ResumeAllSounds@$
	//# \also	$@Sound::Stop@$


	//# \function	SoundMgr::PauseAllSounds	Pauses all sounds which are currently playing.
	//
	//# \proto	void PauseAllSounds(void);
	//
	//# \desc
	//# The $PauseAllSounds$ function pauses all sounds which are currently playing. The pause count of
	//# any sound which is already paused is incremented, so calling $@SoundMgr::ResumeAllSounds@$ returns
	//# the sound to its previous state.
	//
	//# \also	$@SoundMgr::ResumeAllSounds@$
	//# \also	$@SoundMgr::StopAllSounds@$
	//# \also	$@Sound::Pause@$


	//# \function	SoundMgr::ResumeAllSounds	Resumes all sounds which are currently paused.
	//
	//# \proto	void ResumeAllSounds(void);
	//
	//# \desc
	//# The $ResumeAllSounds$ function resumes all sounds which are currently paused. This function is
	//# normally called to balance a previous call to $@SoundMgr::PauseAllSounds@$.
	//
	//# \also	$@SoundMgr::PauseAllSounds@$
	//# \also	$@SoundMgr::StopAllSounds@$
	//# \also	$@Sound::Resume@$


	//# \div
	//# \function	SoundMgr::RegisterSoundGroup	Registers a sound group with the Sound Manager.
	//
	//# \proto	void RegisterSoundGroup(SoundGroup *group);
	//
	//# \param	group	A pointer to the sound group to register.
	//
	//# \desc
	//# The $RegisterSoundGroup$ function registers a sound group with the Sound Manager. A sound group
	//# does not need to be registered in order to be used, but registration causes the group's name to
	//# appear in the World Editor.
	//
	//# \also	$@SoundMgr::GetFirstSoundGroup@$
	//# \also	$@SoundMgr::FindSoundGroup@$
	//# \also	$@SoundMgr::GetDefaultSoundGroup@$
	//# \also	$@SoundMgr::SetDefaultSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \function	SoundMgr::GetFirstSoundGroup	Returns the first registered sound group.
	//
	//# \proto	SoundGroup *GetFirstSoundGroup(void) const;
	//
	//# \desc
	//# The $GetFirstSoundGroup$ function returns the first sound group in the list maintained by the Sound
	//# Manager. If no groups are registered, then the return value is $nullptr$. Iteration through the entire
	//# list of registered sound groups can be accomplished using the $@Utilities/MapElement::Next@$ function
	//# on a $@SoundGroup@$ object.
	//
	//# \also	$@SoundMgr::RegisterSoundGroup@$
	//# \also	$@SoundMgr::FindSoundGroup@$
	//# \also	$@SoundMgr::GetDefaultSoundGroup@$
	//# \also	$@SoundMgr::SetDefaultSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \function	SoundMgr::FindSoundGroup	Finds a registered sound group.
	//
	//# \proto	SoundGroup *FindSoundGroup(SoundGroupType type) const;
	//
	//# \param	type	The type of the sound group to return.
	//
	//# \desc
	//# The $FindSoundGroup$ function returns the sound group having the type specified by the $type$ parameter.
	//# If no sound group with that type is registered, then the return value is $nullptr$.
	//
	//# \also	$@SoundMgr::RegisterSoundGroup@$
	//# \also	$@SoundMgr::GetFirstSoundGroup@$
	//# \also	$@SoundMgr::GetDefaultSoundGroup@$
	//# \also	$@SoundMgr::SetDefaultSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \function	SoundMgr::GetDefaultSoundGroup		Returns the default sound group.
	//
	//# \proto	SoundGroup *GetDefaultSoundGroup(void) const;
	//
	//# \desc
	//# The $GetDefaultSoundGroup$ function returns a pointer to the default sound group. If there is no
	//# default sound group, then the return value is $nullptr$. When a default sound group exists, each sound
	//# is automatically added to that group when the $@Sound::Load@$ function is called.
	//
	//# \also	$@SoundMgr::SetDefaultSoundGroup@$
	//# \also	$@SoundMgr::RegisterSoundGroup@$
	//# \also	$@SoundMgr::GetFirstSoundGroup@$
	//# \also	$@SoundMgr::FindSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \function	SoundMgr::SetDefaultSoundGroup		Returns the default sound group.
	//
	//# \proto	void SetDefaultSoundGroup(SoundGroup *group);
	//
	//# \param	group	A pointer to the new default sound group. This can be $nullptr$.
	//
	//# \desc
	//# The $SetDefaultSoundGroup$ function sets the default sound group to the group specified by the $group$
	//# parameter. If $nullptr$ is specified, then there is no default sound group. When a default sound group
	//# exists, each sound is automatically added to that group when the $@Sound::Load@$ function is called.
	//
	//# \also	$@SoundMgr::GetDefaultSoundGroup@$
	//# \also	$@SoundMgr::RegisterSoundGroup@$
	//# \also	$@SoundMgr::GetFirstSoundGroup@$
	//# \also	$@SoundMgr::FindSoundGroup@$
	//# \also	$@SoundGroup@$


	//# \div
	//# \function	SoundMgr::StartRecording		Starts recording audio output to a wave file.
	//
	//# \proto	EngineResult StartRecording(const char *name);
	//
	//# \param	name	The base name (including directory path) of the wave file that will be generated, without any extension.
	//
	//# \desc
	//# The $StartRecording$ function starts recording the final audio output of the engine to the single wave file specified by
	//# the $name$ parameter. The $.wav$ extension is added by the Sound Manager and should not be included in the name.
	//#
	//# If the call to the $StartRecording$ function is successful, then the return value is $kEngineOkay$. Otherwise, a nonzero
	//# result code is returned. If the $StartRecording$ function is called while recording is already in progress, then the function
	//# has no effect, and the return value is $kEngineOkay$.
	//#
	//# The Sound Manager continues recording audio until the $@SoundMgr::StopRecording@$ function is called.
	//
	//# \also	$@SoundMgr::StopRecording@$
	//# \also	$@MovieMgr/MovieMgr::StartRecording@$
	//# \also	$@MovieMgr/MovieMgr::StopRecording@$


	//# \function	SoundMgr::StopRecording		Stops recording audio output.
	//
	//# \proto	void StopRecording(void);
	//
	//# \desc
	//# The $StopRecording$ function stops audio output recording that was previously started with the $@SoundMgr::StartRecording@$ function.
	//# If audio recording is not in progress when the $StopRecording$ function is called, then the function has no effect.
	//
	//# \also	$@SoundMgr::StartRecording@$
	//# \also	$@MovieMgr/MovieMgr::StartRecording@$
	//# \also	$@MovieMgr/MovieMgr::StopRecording@$


	class SoundMgr : public Manager<SoundMgr>
	{
		friend class Sound;
		friend class SoundGroup;
		friend class SoundRoom;

		private:

			typedef int32 (SoundMgr::*MixProc)(SoundMixData *, const Sample *, int32, int32&, int32, int32);

			#if C4XAUDIO

				struct VoiceCallback : IXAudio2VoiceCallback
				{
					SoundMgr	*soundMgr;

					void STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32);
					void STDMETHODCALLTYPE OnVoiceProcessingPassEnd(void);
					void STDMETHODCALLTYPE OnStreamEnd(void);
					void STDMETHODCALLTYPE OnBufferStart(void *context);
					void STDMETHODCALLTYPE OnBufferEnd(void *context);
					void STDMETHODCALLTYPE OnLoopEnd(void *context);
					void STDMETHODCALLTYPE OnVoiceError(void *context, HRESULT);
				};

				friend struct SoundMgr::VoiceCallback;

				IXAudio2				*xaudioObject;
				IXAudio2MasteringVoice	*masteringVoice;
				IXAudio2SourceVoice		*sourceVoice;

				Storage<Signal>			soundSignal;
				Storage<Thread>			soundThread;

				VoiceCallback			voiceCallback;
				XAUDIO2_BUFFER			sourceBuffer[2];
				OutputSample			*playBuffer[2];

				static void SoundThread(const Thread *thread, void *cookie);

			#elif C4MACOS

				AUGraph					audioGraph;
				AUNode					audioNode;
				AudioUnit				audioUnit;

				unsigned_int32			playFrameIndex;
				OutputSample			*playBuffer[2];

				static OSStatus SoundCallback(void *inRefCon, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData);

			#elif C4LINUX

				snd_pcm_t				*soundHandle;

				Storage<Thread>			soundThread;
				volatile bool			soundExitFlag;

				OutputSample			*playBuffer;

				static void SoundThread(const Thread *thread, void *cookie);

			#elif C4IOS //[ MOBILE

				// -- Mobile code hidden --

			#elif C4PS4 //[ PS4

				// -- PS4 code hidden --

			#elif C4PS3 //[ PS3

				// -- PS3 code hidden --

			#endif //]

			Storage<Signal>					streamSignal;
			Storage<Thread>					streamThread;

			unsigned_int32					soundOptionFlags;

			float							masterVolume;
			float							globalSoundSpeed;
			float							unitDistanceFrameCount;

			const Transformable				*listenerTransformable;
			Vector3D						listenerVelocity;
			Link<SoundRoom>					listenerRoom;

			Map<SoundGroup>					soundGroupMap;
			Link<SoundGroup>				defaultSoundGroup;

			volatile int32					soundMixStamp;

			int32							ringBufferSliceIndex;
			StereoMixFrame					*stereoRingBuffer;
			RoomMixBuffer					*roomMixBuffer[kMaxRoomCount];

			List<Sound>						loadedSoundList;
			List<SoundRoom>					releasedRoomList;

			Sound							*activeSoundTable[kMaxSoundCount];
			SoundRoom						*activeRoomTable[kMaxRoomCount];

			VariableObserver<SoundMgr>		soundReverbObserver;

			#if C4RECORDABLE

				volatile bool				recordFlag;
				volatile bool				recordBufferFull[2];
				volatile int32				recordSliceIndex;
				Sample						*recordBuffer;

				Storage<Signal>				recordSignal;
				Storage<Thread>				recordThread;

				Storage<File>				recordFile;
				WaveFileHeader				recordHeader;

				static void RecordThread(const Thread *thread, void *cookie);

			#endif

			void HandleSoundReverbEvent(Variable *variable);

			int32 MixStereoSamples_Mono_Constant(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Mono_Variable(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Mono_Constant_Dry(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Mono_Constant_Wet(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Mono_Variable_Dry(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Mono_Variable_Wet(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Stereo_Constant(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);
			int32 MixStereoSamples_Stereo_Variable(SoundMixData *mixData, const Sample *input, int32 inputFrameCount, int32& inputOffset, int32 outputFrameCount, int32 outputOffset);

			void MixSoundMono(Sound *sound, int32 outputOffset);
			void MixSoundStereo(Sound *sound, int32 outputOffset);
			void MixSoundStreamMono(Sound *sound, int32 outputOffset);
			void MixSoundStreamStereo(Sound *sound, int32 outputOffset);

			void MixRoomEffects(const SoundRoom *soundRoom, RoomMixBuffer *mixBuffer, int32 outputOffset);

			void AllocateListenerRoomMixBuffer(SoundRoom *soundRoom);
			int32 AllocateSoundRoomMixBuffer(SoundRoom *soundRoom);

			void MixSounds(OutputSample *outputSample);
			void OutputSoundData(float *inputSample, OutputSample *outputSample);

			static void StreamThread(const Thread *thread, void *cookie);

			int32 AddSound(Sound *sound);

		public:

			SoundMgr(int);
			~SoundMgr();

			EngineResult Construct(void);
			void Destruct(void);

			unsigned_int32 GetSoundOptionFlags(void) const
			{
				return (soundOptionFlags);
			}

			void SetSoundOptionFlags(unsigned_int32 flags)
			{
				soundOptionFlags = flags;
			}

			float GetMasterVolume(void) const
			{
				return (masterVolume);
			}

			float GetGlobalSoundSpeed(void) const
			{
				return (globalSoundSpeed);
			}

			const Transformable *GetListenerTransformable(void) const
			{
				return (listenerTransformable);
			}

			void SetListenerTransformable(const Transformable *transformable)
			{
				listenerTransformable = transformable;
			}

			const Vector3D& GetListenerVelocity(void) const
			{
				return (listenerVelocity);
			}

			void SetListenerVelocity(const Vector3D& velocity)
			{
				listenerVelocity = velocity;
			}

			SoundRoom *GetListenerRoom(void) const
			{
				return (listenerRoom);
			}

			void RegisterSoundGroup(SoundGroup *group)
			{
				soundGroupMap.Insert(group);
			}

			SoundGroup *GetFirstSoundGroup(void) const
			{
				return (soundGroupMap.First());
			}

			SoundGroup *FindSoundGroup(SoundGroupType type) const
			{
				return (soundGroupMap.Find(type));
			}

			SoundGroup *GetDefaultSoundGroup(void) const
			{
				return (defaultSoundGroup);
			}

			void SetDefaultSoundGroup(SoundGroup *group)
			{
				defaultSoundGroup = group;
			}

			bool Recording(void) const
			{
				#if C4RECORDABLE

					return (recordFlag);

				#else

					return (false);

				#endif
			}

			C4API void SetMasterVolume(float volume);

			C4API void StopAllSounds(void);
			C4API void PauseAllSounds(void);
			C4API void ResumeAllSounds(void);

			C4API void SetGlobalSoundSpeed(float speed);
			C4API void SetListenerRoom(SoundRoom *room);

			C4API EngineResult StartRecording(const char *name);
			C4API void StopRecording(void);

			C4API void SoundTask(void);
	};


	C4API extern SoundMgr *TheSoundMgr;
}


#endif

// ZYUQURM
