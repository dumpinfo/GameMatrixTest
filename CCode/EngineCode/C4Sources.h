 

#ifndef C4Sources_h
#define C4Sources_h


//# \component	World Manager
//# \prefix		WorldMgr/


#include "C4Node.h"
#include "C4Sound.h"
#include "C4Time.h"


namespace C4
{
	typedef Type	SourceType;


	enum : ObjectType
	{
		kObjectSource			= 'SORC'
	};


	//# \enum	SourceType

	enum : SourceType
	{
		kSourceAmbient			= 'AMBT',		//## Ambient sound source.
		kSourceOmni				= 'OMNI',		//## Omnidirectional sound source.
		kSourceDirected			= 'DRCT'		//## Directed sound source.
	};


	//# \enum	SourceFlags

	enum
	{
		kSourceRandom			= 1 << 0,		//## The source starts playing at a random position when it becomes audible. (Ignored if the $kSourceStream$ flag is set or if the $kSourceLoop$ flag is not set.)
		kSourceStream			= 1 << 1,		//## The source is streamed from disk.
		kSourceInitialPlay		= 1 << 2,		//## The source is initially playing.
		kSourceLoop				= 1 << 3,		//## The source is looping.
		kSourceDopplerShift		= 1 << 4,		//## The Doppler effect is applied to the source.
		kSourceDistanceDelay	= 1 << 5,		//## Distance delay is applied to the source.
		kSourceReverb			= 1 << 6,		//## Reflections and reverberation are generated by the source.
		kSourceObstruction		= 1 << 7		//## The source can be obstructed by geometry.
	};


	enum
	{
		kSourcePersistent		= 1 << 0,
		kSourcePlaying			= 1 << 1,
		kSourceStopped			= 1 << 2,
		kSourceInitialized		= 1 << 7,
		kSourceEngaged			= 1 << 8,
		kSourceAudible			= 1 << 9
	};


	class Source;
	class OmniSource;
	class Zone;
	class Portal;


	class SoundData : public ListElement<SoundData>
	{
		private:

			ResourceName	soundName;

		public:

			C4API SoundData(const char *name);
			C4API ~SoundData();

			const ResourceName& GetSoundName(void) const
			{
				return (soundName);
			}

			void SetSoundName(const char *name)
			{
				soundName = name;
			}
	};


	class SoundConduit
	{
		public:

			SoundConduit() = default;
			virtual ~SoundConduit() = default;

			virtual Sound *LoadSound(Source *source);
			virtual void UnloadSound(Sound *sound);

			virtual void PlaySound(Sound *sound);
			virtual void StopSound(Sound *sound); 

			virtual void SetSoundVolume(Sound *sound, float volume);
			virtual void SetSoundFrequency(Sound *sound, float frequency); 
	};
 

	class SourceRegion : public ListElement<SourceRegion>, public Tree<SourceRegion>, public EngineMemory<SourceRegion>
	{ 
		private:
 
			OmniSource			*regionSource; 
			SourceRegion		*primaryRegion;

			Zone				*regionZone;
 
			const Portal		*permeatedPortal;
			Point3D				permeatedPosition;
			float				permeatedPathLength;

			SourceRegion		*audibleSubregion;
			Point3D				audiblePosition;
			float				audiblePathLength;

		public:

			SourceRegion(OmniSource *source, Zone *zone);
			~SourceRegion();

			using ListElement<SourceRegion>::Previous;
			using ListElement<SourceRegion>::Next;

			OmniSource *GetSource(void) const
			{
				return (regionSource);
			}

			SourceRegion *GetPrimaryRegion(void) const
			{
				return (primaryRegion);
			}

			void SetPrimaryRegion(SourceRegion *region)
			{
				primaryRegion = region;
			}

			Zone *GetZone(void) const
			{
				return (regionZone);
			}

			const Portal *GetPermeatedPortal(void) const
			{
				return (permeatedPortal);
			}

			void SetPermeatedPortal(const Portal *portal, const Point3D& position, float length)
			{
				permeatedPortal = portal;
				permeatedPosition = position;
				permeatedPathLength = length;
			}

			const Point3D& GetPermeatedPosition(void) const
			{
				return (permeatedPosition);
			}

			float GetPermeatedPathLength(void) const
			{
				return (permeatedPathLength);
			}

			SourceRegion *GetAudibleSubregion(void) const
			{
				return (audibleSubregion);
			}

			void SetAudibleSubregion(SourceRegion *region)
			{
				audibleSubregion = region;
			}

			const Point3D& GetAudiblePosition(void) const
			{
				return (audiblePosition);
			}

			float GetAudiblePathLength(void) const
			{
				return (audiblePathLength);
			}

			void SetAudiblePosition(const Point3D& position, float length)
			{
				audiblePosition = position;
				audiblePathLength = length;
			}

			void InvertAudiblePathLength(float length)
			{
				audiblePathLength = length - audiblePathLength;
			}
	};


	class RootSourceRegion : public SourceRegion, public ListElement<RootSourceRegion>
	{
		public:

			RootSourceRegion(OmniSource *source, Zone *zone) : SourceRegion(source, zone)
			{
			}

			using ListElement<RootSourceRegion>::Previous;
			using ListElement<RootSourceRegion>::Next;
	};


	//# \class	SourceObject	Encapsulates data pertaining to a sound source.
	//
	//# The $SourceObject$ class encapsulates data pertaining to a sound source.
	//
	//# \def	class SourceObject : public Object
	//
	//# \ctor	SourceObject(SourceType type, const char *name);
	//
	//# The constructor has protected access. The $SourceObject$ class can only exist as the base class for another class.
	//
	//# \param	type	The type of the sound source. See below for a list of possible types.
	//# \param	name	The name of the sound resource associated with the source.
	//
	//# \desc
	//# The $SourceObject$ class is the base class for objects that hold information about sound sources.
	//
	//# \base	Object		A source object is an object that can be shared by multiple source nodes.
	//
	//# \also	$@Source@$
	//
	//# \wiki	Sources


	//# \function	SourceObject::GetSourceType		Returns the specific type of a source.
	//
	//# \proto	SourceType GetSourceType(void) const;
	//
	//# \desc
	//# The $GetSourceType$ function returns the specific source type, which can be one of the following constants.
	//
	//# \table	SourceType


	//# \function	SourceObject::GetSourceFlags		Returns the source flags.
	//
	//# \proto	unsigned_int32 GetSourceFlags(void) const;
	//
	//# \desc
	//# The $GetSourceFlags$ function returns the source flags, which can be a combination (through logical OR)
	//# of the following constants.
	//
	//# \table	SourceFlags
	//
	//# The default flags value for a new source object is $kSourceInitialPlay$.
	//
	//# \also	$@SourceObject::SetSourceFlags@$


	//# \function	SourceObject::SetSourceFlags		Sets the source flags.
	//
	//# \proto	void SetSourceFlags(unsigned_int32 flags);
	//
	//# \desc
	//# The $SetSourceFlags$ function sets the source flags to the value specified by the $flags$ parameter,
	//# which can be a combination (through logical OR) of the following constants.
	//
	//# \table	SourceFlags
	//
	//# The default flags value for a new source object is $kSourceInitialPlay$.
	//
	//# \also	$@SourceObject::GetSourceFlags@$


	class SourceObject : public Object
	{
		friend class WorldMgr;

		private:

			SourceType			sourceType;
			unsigned_int32		sourceFlags;

			float				initialSourceVolume;
			float				initialSourceFrequency;

			SoundGroupType		soundGroupType;

			List<SoundData>		soundList;

			static SourceObject *Create(Unpacker& data, unsigned_int32 unpackFlags);

		protected:

			SourceObject(SourceType type);
			SourceObject(SourceType type, const char *name);
			~SourceObject();

		public:

			SourceType GetSourceType(void) const
			{
				return (sourceType);
			}

			unsigned_int32 GetSourceFlags(void) const
			{
				return (sourceFlags);
			}

			void SetSourceFlags(unsigned_int32 flags)
			{
				sourceFlags = flags;
			}

			float GetInitialSourceVolume(void) const
			{
				return (initialSourceVolume);
			}

			void SetInitialSourceVolume(float volume)
			{
				initialSourceVolume = volume;
			}

			float GetInitialSourceFrequency(void) const
			{
				return (initialSourceFrequency);
			}

			void SetInitialSourceFrequency(float frequency)
			{
				initialSourceFrequency = frequency;
			}

			SoundGroupType GetSoundGroupType(void) const
			{
				return (soundGroupType);
			}

			void SetSoundGroupType(SoundGroupType type)
			{
				soundGroupType = type;
			}

			SoundData *GetFirstSound(void) const
			{
				return (soundList.First());
			}

			void AddSound(const char *name)
			{
				soundList.Append(new SoundData(name));
			}

			void PurgeSounds(void)
			{
				soundList.Purge();
			}

			void PackType(Packer& data) const override;
			void Pack(Packer& data, unsigned_int32 packFlags) const override;
			void Unpack(Unpacker& data, unsigned_int32 unpackFlags) override;
			bool UnpackChunk(const ChunkHeader *chunkHeader, Unpacker& data, unsigned_int32 unpackFlags);
			void *BeginSettingsUnpack(void) override;

			int32 GetCategoryCount(void) const override;
			Type GetCategoryType(int32 index, const char **title) const override;
			int32 GetCategorySettingCount(Type category) const override;
			Setting *GetCategorySetting(Type category, int32 index, unsigned_int32 flags) const override;
			void SetCategorySetting(Type category, const Setting *setting) override;
	};


	//# \class	AmbientSourceObject		Encapsulates data pertaining to an ambient sound source.
	//
	//# The $AmbientSourceObject$ class encapsulates data pertaining to an ambient sound source.
	//
	//# \def	class AmbientSourceObject final : public SourceObject
	//
	//# \ctor	AmbientSourceObject(const char *sound);
	//
	//# \param	sound	The name of the sound resource associated with the source.
	//
	//# \desc
	//
	//# \base	SourceObject		An $AmbientSourceObject$ is a specific type of source object.
	//
	//# \also	$@AmbientSource@$


	class AmbientSourceObject final : public SourceObject
	{
		friend class SourceObject;

		private:

			int32		fadeTime;
			int32		loopIndex;

			AmbientSourceObject();
			~AmbientSourceObject();

		public:

			AmbientSourceObject(const char *sound);

			int32 GetFadeTime(void) const
			{
				return (fadeTime);
			}

			void SetFadeTime(int32 time)
			{
				fadeTime = time;
			}

			int32 GetLoopIndex(void) const
			{
				return (loopIndex);
			}

			void SetLoopIndex(int32 index)
			{
				loopIndex = index;
			}

			void Pack(Packer& data, unsigned_int32 packFlags) const override;
			void Unpack(Unpacker& data, unsigned_int32 unpackFlags) override;
			bool UnpackChunk(const ChunkHeader *chunkHeader, Unpacker& data, unsigned_int32 unpackFlags);

			int32 GetCategorySettingCount(Type category) const override;
			Setting *GetCategorySetting(Type category, int32 index, unsigned_int32 flags) const override;
			void SetCategorySetting(Type category, const Setting *setting) override;
	};


	//# \class	OmniSourceObject	Encapsulates data pertaining to an omnidirectional sound source.
	//
	//# The $OmniSourceObject$ class encapsulates data pertaining to an omnidirectional sound source.
	//
	//# \def	class OmniSourceObject : public SourceObject
	//
	//# \ctor	OmniSourceObject(const char *sound, float range);
	//
	//# \param	sound	The name of the sound resource associated with the source.
	//# \param	range	The range of the sound source.
	//
	//# \desc
	//
	//# \base	SourceObject		An $OmniSourceObject$ is a specific type of source object.
	//
	//# \also	$@OmniSource@$


	//# \function	OmniSourceObject::GetSourceRange		Returns the source range.
	//
	//# \proto	float GetSourceRange(void) const;
	//
	//# \desc
	//
	//# \also	$@OmniSourceObject::SetSourceRange@$


	//# \function	OmniSourceObject::SetSourceRange		Sets the source range.
	//
	//# \proto	void SetSourceRange(float range);
	//
	//# \param	range	The new range of the source.
	//
	//# \desc
	//
	//# \also	$@OmniSourceObject::GetSourceRange@$


	class OmniSourceObject : public SourceObject
	{
		friend class SourceObject;

		private:

			float		sourceRange;

			float		reflectionVolume;
			float		reflectionHFVolume;

			OmniSourceObject();

		protected:

			OmniSourceObject(SourceType type);
			OmniSourceObject(SourceType type, const char *sound, float range);
			~OmniSourceObject();

		public:

			OmniSourceObject(const char *sound, float range);

			float GetSourceRange(void) const
			{
				return (sourceRange);
			}

			void SetSourceRange(float range)
			{
				sourceRange = range;
			}

			float GetReflectionVolume(void) const
			{
				return (reflectionVolume);
			}

			void SetReflectionVolume(float volume)
			{
				reflectionVolume = volume;
			}

			float GetReflectionHFVolume(void) const
			{
				return (reflectionHFVolume);
			}

			void SetReflectionHFVolume(float volume)
			{
				reflectionHFVolume = volume;
			}

			void Pack(Packer& data, unsigned_int32 packFlags) const override;
			void Unpack(Unpacker& data, unsigned_int32 unpackFlags) override;
			bool UnpackChunk(const ChunkHeader *chunkHeader, Unpacker& data, unsigned_int32 unpackFlags);

			int32 GetCategorySettingCount(Type category) const override;
			Setting *GetCategorySetting(Type category, int32 index, unsigned_int32 flags) const override;
			void SetCategorySetting(Type category, const Setting *setting) override;

			int32 GetObjectSize(float *size) const override;
			void SetObjectSize(const float *size) override;
	};


	//# \class	DirectedSourceObject	Encapsulates data pertaining to a directed sound source.
	//
	//# The $DirectedSourceObject$ class encapsulates data pertaining to a directed sound source.
	//
	//# \def	class DirectedSourceObject final : public OmniSourceObject
	//
	//# \ctor	DirectedSourceObject(const char *sound, float range, float apex);
	//
	//# \param	sound	The name of the sound resource associated with the source.
	//# \param	range	The range of the sound source.
	//# \param	apex	The tangent of half the apex angle for the sound source.
	//
	//# \desc
	//
	//# \base	OmniSourceObject	A $DirectedSourceObject$ is a specific type of omnidirectional source object.
	//
	//# \also	$@DirectedSource@$


	//# \function	DirectedSourceObject::GetApexTangent		Returns the tangent of half the apex angle for a sound source.
	//
	//# \proto	float GetApexTangent(void) const;
	//
	//# \desc
	//
	//# \also	$@DirectedSourceObject::SetApexTangent@$


	//# \function	DirectedSourceObject::SetApexTangent		Sets the tangent of half the apex angle for a sound source.
	//
	//# \proto	void SetApexTangent(float apex);
	//
	//# \param	apex	The tangent of half the apex angle for the sound source.
	//
	//# \desc
	//
	//# \also	$@DirectedSourceObject::GetApexTangent@$


	class DirectedSourceObject final : public OmniSourceObject
	{
		friend class SourceObject;

		private:

			float		apexTangent;

			float		outerConeVolume;
			float		outerConeHFVolume;

			DirectedSourceObject();
			~DirectedSourceObject();

		public:

			DirectedSourceObject(const char *sound, float range, float apex);

			float GetApexTangent(void) const
			{
				return (apexTangent);
			}

			void SetApexTangent(float apex)
			{
				apexTangent = apex;
			}

			float GetOuterConeVolume(void) const
			{
				return (outerConeVolume);
			}

			void SetOuterConeVolume(float volume)
			{
				outerConeVolume = volume;
			}

			float GetOuterConeHFVolume(void) const
			{
				return (outerConeHFVolume);
			}

			void SetOuterConeHFVolume(float volume)
			{
				outerConeHFVolume = volume;
			}

			void Pack(Packer& data, unsigned_int32 packFlags) const override;
			void Unpack(Unpacker& data, unsigned_int32 unpackFlags) override;
			bool UnpackChunk(const ChunkHeader *chunkHeader, Unpacker& data, unsigned_int32 unpackFlags);

			int32 GetCategorySettingCount(Type category) const override;
			Setting *GetCategorySetting(Type category, int32 index, unsigned_int32 flags) const override;
			void SetCategorySetting(Type category, const Setting *setting) override;

			int32 GetObjectSize(float *size) const override;
			void SetObjectSize(const float *size) override;
	};


	//# \class	Source		Represents a sound source node in a world.
	//
	//# The $Source$ class represents a sound source node in a world.
	//
	//# \def	class Source : public Node, public Completable<Source>
	//
	//# \ctor	Source(SourceType type, bool persistent);
	//
	//# The constructor has protected access. A $Source$ class can only exist as the base class for a more specific type of sound source.
	//
	//# \param	type		The type of the sound source. See below for a list of possible types.
	//# \param	persistent	A boolean value indicating whether the sound source persists after it plays.
	//
	//# \desc
	//#
	//# \table	SourceType
	//
	//# \base	Node							A $Source$ node is a scene graph node.
	//# \base	Utilities/Completable<Source>	The completion procedure is called when the sound finishes playing.
	//
	//# \also	$@SourceObject@$
	//
	//# \wiki	Sources


	//# \function	Source::GetSourceType		Returns the specific type of a sound source.
	//
	//# \proto	SourceType GetSourceType(void) const;
	//
	//# \desc
	//# The $GetSourceType$ function returns the specific sound source type, which can be one of the following constants.
	//
	//# \table	SourceType


	class Source : public Node, public Completable<Source>
	{
		friend class Node;
		friend class World;

		private:

			SourceType			sourceType;

			int32				sourcePriority;
			float				sourceVolume;
			float				sourceFrequency;

			float				varyVolumeValue;
			int32				varyVolumeTime;
			bool				varyVolumeStop;

			float				varyFrequencyValue;
			int32				varyFrequencyTime;
			bool				varyFrequencyStop;

			SoundConduit		*soundConduit;
			SoundConduit		sourceSoundConduit;

			DeferredTask		playTask;
			DeferredTask		volumeTask;
			DeferredTask		frequencyTask;

			static Source *Create(Unpacker& data, unsigned_int32 unpackFlags);

			static void PlayTask(DeferredTask *task, void *cookie);
			static void VolumeTask(DeferredTask *task, void *cookie);
			static void FrequencyTask(DeferredTask *task, void *cookie);
			static void SoundComplete(Sound *sound, void *cookie);

		protected:

			unsigned_int32		sourceState;
			Sound				*soundObject;

			Source(SourceType type);
			Source(SourceType type, bool persistent);
			Source(const Source& source);

			void LoadSound(void);
			void UnloadSound(void);

			void PlaySound(void);
			void StopSound(void);

			virtual void InitializeSound(void);
			virtual void ResetSource(void);

		public:

			virtual ~Source();

			SourceType GetSourceType(void) const
			{
				return (sourceType);
			}

			SourceObject *GetObject(void) const
			{
				return (static_cast<SourceObject *>(Node::GetObject()));
			}

			bool Playing(void) const
			{
				return ((sourceState & kSourcePlaying) != 0);
			}

			int32 GetSourcePriority(void) const
			{
				return (sourcePriority);
			}

			void SetSourcePriority(int32 priority)
			{
				sourcePriority = priority;
			}

			float GetSourceVolume(void) const
			{
				return (sourceVolume);
			}

			float GetSourceFrequency(void) const
			{
				return (sourceFrequency);
			}

			void PackType(Packer& data) const override;
			void Pack(Packer& data, unsigned_int32 packFlags) const override;
			void Unpack(Unpacker& data, unsigned_int32 unpackFlags) override;
			bool UnpackChunk(const ChunkHeader *chunkHeader, Unpacker& data, unsigned_int32 unpackFlags);

			void Preprocess(void) override;
			void Neutralize(void) override;

			void SetSoundConduit(SoundConduit *conduit);

			C4API virtual void Play(void) = 0;
			C4API virtual void Stop(void) = 0;

			C4API void SetSourceVolume(float volume);
			C4API void SetSourceFrequency(float frequency);

			C4API void VaryVolume(float volume, int32 time, bool stop = false);
			C4API void VaryFrequency(float frequency, int32 time, bool stop = false);
	};


	//# \class	AmbientSource	Represents an ambient sound source node in a world.
	//
	//# The $AmbientSource$ class represents an ambient sound source node in a world.
	//
	//# \def	class AmbientSource final : public Source
	//
	//# \ctor	AmbientSource(const char *name, bool persistent = false);
	//
	//# \param	name		The name of the sound resource associated with the source.
	//# \param	persistent	A boolean value indicating whether the sound source persists after it plays.
	//
	//# \desc
	//#
	//
	//# \base	Source		An $AmbientSource$ node is a specific type of source.
	//
	//# \also	$@AmbientSourceObject@$


	class AmbientSource final : public Source
	{
		friend class Source;

		private:

			AmbientSource();
			AmbientSource(const AmbientSource& ambientSource);

			Node *Replicate(void) const override;

		public:

			C4API AmbientSource(const char *name, bool persistent = false);
			C4API ~AmbientSource();

			AmbientSourceObject *GetObject(void) const
			{
				return (static_cast<AmbientSourceObject *>(Node::GetObject()));
			}

			void Play(void);
			void Stop(void);

			C4API Sound *ExtractSound(void);
	};


	//# \class	OmniSource		Represents an omnidirectional sound source node in a world.
	//
	//# The $OmniSource$ class represents an omnidirectional sound source node in a world.
	//
	//# \def	class OmniSource : public Source, public ListElement<OmniSource>
	//
	//# \ctor	OmniSource(const char *name, float range, bool persistent = false);
	//
	//# \param	name		The name of the sound resource associated with the source.
	//# \param	range		The range of the sound source.
	//# \param	persistent	A boolean value indicating whether the sound source persists after it plays.
	//
	//# \desc
	//#
	//
	//# \base	Source								An $OmniSource$ node is a specific type of source.
	//# \base	Utilities/ListElement<OmniSource>	Used internally by the World Manager.
	//
	//# \also	$@OmniSourceObject@$


	class OmniSource : public Source, public ListElement<OmniSource>
	{
		friend class Source;

		private:

			float						sourceRange;
			Vector3D					sourceVelocity;

			int32						sourceDuration;
			int32						sourceLifeTime;

			SoundRoom					*sourceRoom;
			const AcousticsProperty		*sourceObstruction;

			List<RootSourceRegion>		rootRegionList;

			int32						playRegionCount;
			const SourceRegion			*playRegion[kMaxSoundPathCount];

			OmniSource();

			Node *Replicate(void) const override;

			void CalculatePermeation(SourceRegion *region);
			bool EstablishRootRegions(Zone *zone, int32 maxDepth, int32 forcedDepth);

			void HandlePostprocessUpdate(void) override;

			void DetectObstruction(void);

		protected:

			OmniSource(SourceType type);
			OmniSource(SourceType type, bool persistent);
			OmniSource(const OmniSource& omniSource);

			void ResetSource(void);
			void InitializeSound(void);

		public:

			C4API OmniSource(const char *name, float range, bool persistent = false);
			C4API ~OmniSource();

			using ListElement<OmniSource>::Previous;
			using ListElement<OmniSource>::Next;

			OmniSourceObject *GetObject(void) const
			{
				return (static_cast<OmniSourceObject *>(Node::GetObject()));
			}

			float GetSourceRange(void) const
			{
				return (sourceRange);
			}

			const Vector3D& GetSourceVelocity(void) const
			{
				return (sourceVelocity);
			}

			void InvalidateSourceRegions(void)
			{
				Invalidate();
			}

			void Pack(Packer& data, unsigned_int32 packFlags) const override;
			void Unpack(Unpacker& data, unsigned_int32 unpackFlags) override;
			bool UnpackChunk(const ChunkHeader *chunkHeader, Unpacker& data, unsigned_int32 unpackFlags);

			void Preprocess(void) override;

			C4API void SetSourceVelocity(const Vector3D& velocity);

			void Play(void);
			void Stop(void);

			bool Engage(void);
			void Disengage(void);

			void BeginUpdate(void);
			void EndUpdate(void);

			void Move(void);
			void AddPlayRegion(SourceRegion *region, const Point3D& listenerPosition);
	};


	//# \class	DirectedSource		Represents a directed sound source node in a world.
	//
	//# The $DirectedSource$ class represents a directed sound source node in a world.
	//
	//# \def	class DirectedSource final : public OmniSource
	//
	//# \ctor	DirectedSource(const char *name, float range, float apex, bool persistent = false);
	//
	//# \param	name		The name of the sound resource associated with the source.
	//# \param	range		The range of the sound source.
	//# \param	apex		The tangent of half the apex angle for the sound source.
	//# \param	persistent	A boolean value indicating whether the sound source persists after it plays.
	//
	//# \desc
	//#
	//
	//# \base	OmniSource		A $DirectedSource$ node is a specific type of omnidirectional source.
	//
	//# \also	$@DirectedSourceObject@$


	class DirectedSource final : public OmniSource
	{
		friend class Source;

		private:

			DirectedSource();
			DirectedSource(const DirectedSource& directedSource);

			Node *Replicate(void) const override;

			void InitializeSound(void);

		public:

			C4API DirectedSource(const char *name, float range, float apex, bool persistent = false);
			C4API ~DirectedSource();

			DirectedSourceObject *GetObject(void) const
			{
				return (static_cast<DirectedSourceObject *>(Node::GetObject()));
			}
	};
}


#endif

// ZYUQURM
