//=============================================================
//
// C4 Engine version 4.5
// Copyright 1999-2015, by Terathon Software LLC
//
// This file is part of the C4 Engine and is provided under the
// terms of the license agreement entered by the registed user.
//
// Unauthorized redistribution of source code is strictly
// prohibited. Violators will be prosecuted.
//
//=============================================================


#include "C4VolumeManipulators.h"
#include "C4EditorViewports.h"
#include "C4Regions.h"


using namespace C4;


SharedVertexBuffer PlateVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D PlateVolumeManipulator::interiorPosition[4] =
{
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F}
};

const ConstPoint3D PlateVolumeManipulator::outlinePosition[8] =
{
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F}
};


SharedVertexBuffer DiskVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer DiskVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D DiskVolumeManipulator::interiorPosition[16] =
{
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F}
};

const Triangle DiskVolumeManipulator::interiorTriangle[14] =
{
	{{0, 1, 15}}, {{1, 2, 15}}, {{2, 14, 15}}, {{2, 3, 14}},
	{{3, 13, 14}}, {{3, 4, 13}}, {{4, 12, 13}}, {{4, 5, 12}},
	{{5, 11, 12}}, {{5, 6, 11}}, {{6, 10, 11}}, {{6, 7, 10}},
	{{7, 9, 10}}, {{7, 8,  9}}
};

const ConstPoint3D DiskVolumeManipulator::outlinePosition[32] =
{
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},

	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-1.0F, 0.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},

	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {1.0F, 0.0F, 0.0F}
};


SharedVertexBuffer BoxVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D BoxVolumeManipulator::interiorPosition[24] =
{
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 1.0F}, {1.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F}, {0.0F, 1.0F, 1.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F}, {1.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 0.0F, 1.0F}, {1.0F, 0.0F, 1.0F}, {1.0F, 1.0F, 1.0F}, {0.0F, 1.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 0.0F}
};

const ConstPoint3D BoxVolumeManipulator::outlinePosition[24] =
{
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F},

	{0.0F, 0.0F, 1.0F}, {1.0F, 0.0F, 1.0F},
	{1.0F, 0.0F, 1.0F}, {1.0F, 1.0F, 1.0F},
	{1.0F, 1.0F, 1.0F}, {0.0F, 1.0F, 1.0F},
	{0.0F, 1.0F, 1.0F}, {0.0F, 0.0F, 1.0F},

	{0.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F},
	{1.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F}
};


SharedVertexBuffer PyramidVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer PyramidVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);
 
const ConstPoint3D PyramidVolumeManipulator::interiorPosition[16] =
{
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {0.5F, 0.5F, 1.0F}, 
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F}, {0.5F, 0.5F, 1.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F}, {0.5F, 0.5F, 1.0F}, 
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {0.5F, 0.5F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 0.0F}
}; 

const Triangle PyramidVolumeManipulator::interiorTriangle[6] = 
{ 
	{{0, 1, 2}}, {{3, 4, 5}}, {{6, 7, 8}}, {{9, 10, 11}},
	{{12, 13, 14}}, {{12, 14, 15}}
};
 
const ConstPoint3D PyramidVolumeManipulator::outlinePosition[16] =
{
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F},

	{0.0F, 0.0F, 0.0F}, {0.5F, 0.5F, 1.0F},
	{1.0F, 0.0F, 0.0F}, {0.5F, 0.5F, 1.0F},
	{1.0F, 1.0F, 0.0F}, {0.5F, 0.5F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.5F, 0.5F, 1.0F}
};


SharedVertexBuffer CylinderVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer CylinderVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D CylinderVolumeManipulator::interiorPosition[66] =
{
	{1.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826834F, 1.0F}, {0.7071068F, 0.7071068F, 1.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.0F, 1.0F, 1.0F}, {-0.3826834F, 0.9238795F, 1.0F}, {-0.7071068F, 0.7071068F, 1.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-1.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826834F, 1.0F}, {-0.7071068F, -0.7071068F, 1.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{0.0F, -1.0F, 1.0F}, {0.3826834F, -0.9238795F, 1.0F}, {0.7071068F, -0.7071068F, 1.0F}, {0.9238795F, -0.3826834F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.9238795F, 0.3826834F, 1.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.7071068F, 0.7071068F, 1.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.3826834F, 0.9238795F, 1.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.7071068F, 0.7071068F, 1.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 1.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.9238795F, -0.3826834F, 1.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.7071068F, -0.7071068F, 1.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -1.0F, 1.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.3826834F, -0.9238795F, 1.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.7071068F, -0.7071068F, 1.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {0.9238795F, -0.3826834F, 1.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F}
};

const Triangle CylinderVolumeManipulator::interiorTriangle[60] =
{
	{{0, 1, 15}}, {{1, 2, 15}}, {{2, 14, 15}}, {{2, 3, 14}},
	{{3, 13, 14}}, {{3, 4, 13}}, {{4, 12, 13}}, {{4, 5, 12}},
	{{5, 11, 12}}, {{5, 6, 11}}, {{6, 10, 11}}, {{6, 7, 10}},
	{{7, 9, 10}}, {{7, 8, 9}},

	{{16, 31, 17}}, {{17, 31, 18}}, {{18, 31, 30}}, {{18, 30, 19}},
	{{19, 30, 29}}, {{19, 29, 20}}, {{20, 29, 28}}, {{20, 28, 21}},
	{{21, 28, 27}}, {{21, 27, 22}}, {{22, 27, 26}}, {{22, 26, 23}},
	{{23, 26, 25}}, {{23, 25, 24}},

	{{32, 34, 33}}, {{34, 35, 33}}, {{34, 36, 35}}, {{36, 37, 35}},
	{{36, 38, 37}}, {{38, 39, 37}}, {{38, 40, 39}}, {{40, 41, 39}},
	{{40, 42, 41}}, {{42, 43, 41}}, {{42, 44, 43}}, {{44, 45, 43}},
	{{44, 46, 45}}, {{46, 47, 45}}, {{46, 48, 47}}, {{48, 49, 47}},
	{{48, 50, 49}}, {{50, 51, 49}}, {{50, 52, 51}}, {{52, 53, 51}},
	{{52, 54, 53}}, {{54, 55, 53}}, {{54, 56, 55}}, {{56, 57, 55}},
	{{56, 58, 57}}, {{58, 59, 57}}, {{58, 60, 59}}, {{60, 61, 59}},
	{{60, 62, 61}}, {{62, 63, 61}}, {{62, 64, 63}}, {{64, 65, 63}}
};

const ConstPoint3D CylinderVolumeManipulator::outlinePosition[72] =
{
	{1.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826834F, 1.0F},
	{0.9238795F, 0.3826834F, 1.0F}, {0.7071068F, 0.7071068F, 1.0F},
	{0.7071068F, 0.7071068F, 1.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.3826834F, 0.9238795F, 1.0F}, {0.0F, 1.0F, 1.0F},

	{0.0F, 1.0F, 1.0F}, {-0.3826834F, 0.9238795F, 1.0F},
	{-0.3826834F, 0.9238795F, 1.0F}, {-0.7071068F, 0.7071068F, 1.0F},
	{-0.7071068F, 0.7071068F, 1.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-0.9238795F, 0.3826834F, 1.0F}, {-1.0F, 0.0F, 1.0F},

	{-1.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826834F, 1.0F},
	{-0.9238795F, -0.3826834F, 1.0F}, {-0.7071068F, -0.7071068F, 1.0F},
	{-0.7071068F, -0.7071068F, 1.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{-0.3826834F, -0.9238795F, 1.0F}, {0.0F, -1.0F, 1.0F},

	{0.0F, -1.0F, 1.0F}, {0.3826834F, -0.9238795F, 1.0F},
	{0.3826834F, -0.9238795F, 1.0F}, {0.7071068F, -0.7071068F, 1.0F},
	{0.7071068F, -0.7071068F, 1.0F}, {0.9238795F, -0.3826834F, 1.0F},
	{0.9238795F, -0.3826834F, 1.0F}, {1.0F, 0.0F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},

	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-1.0F, 0.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},

	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {1.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -1.0F, 1.0F}
};


SharedVertexBuffer ConeVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer ConeVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D ConeVolumeManipulator::interiorPosition[49] =
{
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{1.0F, 0.0F, 0.0F}
};

const Triangle ConeVolumeManipulator::interiorTriangle[30] =
{
	{{0, 15, 1}}, {{1, 15, 2}}, {{2, 15, 14}}, {{2, 14, 3}},
	{{3, 14, 13}}, {{3, 13, 4}}, {{4, 13, 12}}, {{4, 12, 5}},
	{{5, 12, 11}}, {{5, 11, 6}}, {{6, 11, 10}}, {{6, 10, 7}},
	{{7, 10, 9}}, {{7, 9, 8}},

	{{16, 18, 17}}, {{18, 20, 19}}, {{20, 22, 21}}, {{22, 24, 23}},
	{{24, 26, 25}}, {{26, 28, 27}}, {{28, 30, 29}}, {{30, 32, 31}},
	{{32, 34, 33}}, {{34, 36, 35}}, {{36, 38, 37}}, {{38, 40, 39}},
	{{40, 42, 41}}, {{42, 44, 43}}, {{44, 46, 45}}, {{46, 48, 47}}
};

const ConstPoint3D ConeVolumeManipulator::outlinePosition[40] =
{
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},

	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-1.0F, 0.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},

	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {1.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, 0.0F, 1.0F}
};


SharedVertexBuffer SphereVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer SphereVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D SphereVolumeManipulator::interiorPosition[151] =
{
	{0.7071067F, 0.0F, -0.7071067F}, {0.6532814F, 0.270598F, -0.7071067F}, {0.5F, 0.5F, -0.7071067F}, {0.270598F, 0.6532814F, -0.7071067F}, {0.0F, 0.7071067F, -0.7071067F}, {-0.270598F, 0.6532814F, -0.7071067F}, {-0.5F, 0.5F, -0.7071067F}, {-0.6532814F, 0.270598F, -0.7071067F}, {-0.7071067F, 0.0F, -0.7071067F}, {-0.6532814F, -0.270598F, -0.7071067F}, {-0.5F, -0.5F, -0.7071067F}, {-0.270598F, -0.6532814F, -0.7071067F}, {0.0F, -0.7071067F, -0.7071067F}, {0.270598F, -0.6532814F, -0.7071067F}, {0.5F, -0.5F, -0.7071067F}, {0.6532814F, -0.270598F, -0.7071067F}, {0.7071067F, 0.0F, -0.7071067F},
	{0.9238795F, 0.0F, -0.3826833F}, {0.8535532F, 0.3535534F, -0.3826833F}, {0.6532814F, 0.6532814F, -0.3826833F}, {0.3535532F, 0.8535532F, -0.3826833F}, {0.0F, 0.9238795F, -0.3826833F}, {-0.3535532F, 0.8535532F, -0.3826833F}, {-0.6532814F, 0.6532814F, -0.3826833F}, {-0.8535532F, 0.3535534F, -0.3826833F}, {-0.9238795F, 0.0F, -0.3826833F}, {-0.8535532F, -0.3535534F, -0.3826833F}, {-0.6532814F, -0.6532814F, -0.3826833F}, {-0.3535532F, -0.8535532F, -0.3826833F}, {0.0F, -0.9238795F, -0.3826833F}, {0.3535532F, -0.8535532F, -0.3826833F}, {0.6532814F, -0.6532814F, -0.3826833F}, {0.8535532F, -0.3535534F, -0.3826833F}, {0.9238795F, 0.0F, -0.3826833F},
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826833F, 0.0F}, {0.7071067F, 0.7071067F, 0.0F}, {0.3826833F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F}, {-0.3826833F, 0.9238795F, 0.0F}, {-0.7071067F, 0.7071067F, 0.0F}, {-0.9238795F, 0.3826833F, 0.0F}, {-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826833F, 0.0F}, {-0.7071067F, -0.7071067F, 0.0F}, {-0.3826833F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F}, {0.3826833F, -0.9238795F, 0.0F}, {0.7071067F, -0.7071067F, 0.0F}, {0.9238795F, -0.3826833F, 0.0F}, {1.0F, 0.0F, 0.0F},
	{0.9238795F, 0.0F, 0.3826833F}, {0.8535532F, 0.3535534F, 0.3826833F}, {0.6532814F, 0.6532814F, 0.3826833F}, {0.3535532F, 0.8535532F, 0.3826833F}, {0.0F, 0.9238795F, 0.3826833F}, {-0.3535532F, 0.8535532F, 0.3826833F}, {-0.6532814F, 0.6532814F, 0.3826833F}, {-0.8535532F, 0.3535534F, 0.3826833F}, {-0.9238795F, 0.0F, 0.3826833F}, {-0.8535532F, -0.3535534F, 0.3826833F}, {-0.6532814F, -0.6532814F, 0.3826833F}, {-0.3535532F, -0.8535532F, 0.3826833F}, {0.0F, -0.9238795F, 0.3826833F}, {0.3535532F, -0.8535532F, 0.3826833F}, {0.6532814F, -0.6532814F, 0.3826833F}, {0.8535532F, -0.3535534F, 0.3826833F}, {0.9238795F, 0.0F, 0.3826833F},
	{0.7071067F, 0.0F, 0.7071067F}, {0.6532814F, 0.270598F, 0.7071067F}, {0.5F, 0.5F, 0.7071067F}, {0.270598F, 0.6532814F, 0.7071067F}, {0.0F, 0.7071067F, 0.7071067F}, {-0.270598F, 0.6532814F, 0.7071067F}, {-0.5F, 0.5F, 0.7071067F}, {-0.6532814F, 0.270598F, 0.7071067F}, {-0.7071067F, 0.0F, 0.7071067F}, {-0.6532814F, -0.270598F, 0.7071067F}, {-0.5F, -0.5F, 0.7071067F}, {-0.270598F, -0.6532814F, 0.7071067F}, {0.0F, -0.7071067F, 0.7071067F}, {0.270598F, -0.6532814F, 0.7071067F}, {0.5F, -0.5F, 0.7071067F}, {0.6532814F, -0.270598F, 0.7071067F}, {0.7071067F, 0.0F, 0.7071067F},

	{0.7071067F, 0.0F, 0.7071067F}, {0.6532814F, 0.270598F, 0.7071067F}, {0.5F, 0.5F, 0.7071067F}, {0.270598F, 0.6532814F, 0.7071067F}, {0.0F, 0.7071067F, 0.7071067F}, {-0.270598F, 0.6532814F, 0.7071067F}, {-0.5F, 0.5F, 0.7071067F}, {-0.6532814F, 0.270598F, 0.7071067F}, {-0.7071067F, 0.0F, 0.7071067F}, {-0.6532814F, -0.270598F, 0.7071067F}, {-0.5F, -0.5F, 0.7071067F}, {-0.270598F, -0.6532814F, 0.7071067F}, {0.0F, -0.7071067F, 0.7071067F}, {0.270598F, -0.6532814F, 0.7071067F}, {0.5F, -0.5F, 0.7071067F}, {0.6532814F, -0.270598F, 0.7071067F},
	{0.3826833F, 0.0F, 0.9238795F}, {0.3535532F, 0.1464465F, 0.9238795F}, {0.270598F, 0.270598F, 0.9238795F}, {0.1464465F, 0.3535532F, 0.9238795F}, {0.0F, 0.3826833F, 0.9238795F}, {-0.1464465F, 0.3535532F, 0.9238795F}, {-0.270598F, 0.270598F, 0.9238795F}, {-0.3535532F, 0.1464465F, 0.9238795F}, {-0.3826833F, 0.0F, 0.9238795F}, {-0.3535532F, -0.1464465F, 0.9238795F}, {-0.270598F, -0.270598F, 0.9238795F}, {-0.1464465F, -0.3535532F, 0.9238795F}, {0.0F, -0.3826833F, 0.9238795F}, {0.1464465F, -0.3535532F, 0.9238795F}, {0.270598F, -0.270598F, 0.9238795F}, {0.3535532F, -0.1464465F, 0.9238795F},
	{0.0F, 0.0F, 1.0F},

	{0.7071067F, 0.0F, -0.7071067F}, {0.6532814F, 0.270598F, -0.7071067F}, {0.5F, 0.5F, -0.7071067F}, {0.270598F, 0.6532814F, -0.7071067F}, {0.0F, 0.7071067F, -0.7071067F}, {-0.270598F, 0.6532814F, -0.7071067F}, {-0.5F, 0.5F, -0.7071067F}, {-0.6532814F, 0.270598F, -0.7071067F}, {-0.7071067F, 0.0F, -0.7071067F}, {-0.6532814F, -0.270598F, -0.7071067F}, {-0.5F, -0.5F, -0.7071067F}, {-0.270598F, -0.6532814F, -0.7071067F}, {0.0F, -0.7071067F, -0.7071067F}, {0.270598F, -0.6532814F, -0.7071067F}, {0.5F, -0.5F, -0.7071067F}, {0.6532814F, -0.270598F, -0.7071067F},
	{0.3826833F, 0.0F, -0.9238795F}, {0.3535532F, 0.1464465F, -0.9238795F}, {0.270598F, 0.270598F, -0.9238795F}, {0.1464465F, 0.3535532F, -0.9238795F}, {0.0F, 0.3826833F, -0.9238795F}, {-0.1464465F, 0.3535532F, -0.9238795F}, {-0.270598F, 0.270598F, -0.9238795F}, {-0.3535532F, 0.1464465F, -0.9238795F}, {-0.3826833F, 0.0F, -0.9238795F}, {-0.3535532F, -0.1464465F, -0.9238795F}, {-0.270598F, -0.270598F, -0.9238795F}, {-0.1464465F, -0.3535532F, -0.9238795F}, {0.0F, -0.3826833F, -0.9238795F}, {0.1464465F, -0.3535532F, -0.9238795F}, {0.270598F, -0.270598F, -0.9238795F}, {0.3535532F, -0.1464465F, -0.9238795F},
	{0.0F, 0.0F, -1.0F}
};

const Triangle SphereVolumeManipulator::interiorTriangle[224] =
{
	{{0, 1, 17}}, {{1, 18, 17}}, {{1, 2, 18}}, {{2, 19, 18}}, {{2, 3, 19}}, {{3, 20, 19}}, {{3, 4, 20}}, {{4, 21, 20}}, {{4, 5, 21}}, {{5, 22, 21}}, {{5, 6, 22}}, {{6, 23, 22}}, {{6, 7, 23}}, {{7, 24, 23}}, {{7, 8, 24}}, {{8, 25, 24}}, {{8, 9, 25}}, {{9, 26, 25}}, {{9, 10, 26}}, {{10, 27, 26}}, {{10, 11, 27}}, {{11, 28, 27}}, {{11, 12, 28}}, {{12, 29, 28}}, {{12, 13, 29}}, {{13, 30, 29}}, {{13, 14, 30}}, {{14, 31, 30}}, {{14, 15, 31}}, {{15, 32, 31}}, {{15, 16, 32}}, {{16, 33, 32}},
	{{17, 18, 34}}, {{18, 35, 34}}, {{18, 19, 35}}, {{19, 36, 35}}, {{19, 20, 36}}, {{20, 37, 36}}, {{20, 21, 37}}, {{21, 38, 37}}, {{21, 22, 38}}, {{22, 39, 38}}, {{22, 23, 39}}, {{23, 40, 39}}, {{23, 24, 40}}, {{24, 41, 40}}, {{24, 25, 41}}, {{25, 42, 41}}, {{25, 26, 42}}, {{26, 43, 42}}, {{26, 27, 43}}, {{27, 44, 43}}, {{27, 28, 44}}, {{28, 45, 44}}, {{28, 29, 45}}, {{29, 46, 45}}, {{29, 30, 46}}, {{30, 47, 46}}, {{30, 31, 47}}, {{31, 48, 47}}, {{31, 32, 48}}, {{32, 49, 48}}, {{32, 33, 49}}, {{33, 50, 49}},
	{{34, 35, 51}}, {{35, 52, 51}}, {{35, 36, 52}}, {{36, 53, 52}}, {{36, 37, 53}}, {{37, 54, 53}}, {{37, 38, 54}}, {{38, 55, 54}}, {{38, 39, 55}}, {{39, 56, 55}}, {{39, 40, 56}}, {{40, 57, 56}}, {{40, 41, 57}}, {{41, 58, 57}}, {{41, 42, 58}}, {{42, 59, 58}}, {{42, 43, 59}}, {{43, 60, 59}}, {{43, 44, 60}}, {{44, 61, 60}}, {{44, 45, 61}}, {{45, 62, 61}}, {{45, 46, 62}}, {{46, 63, 62}}, {{46, 47, 63}}, {{47, 64, 63}}, {{47, 48, 64}}, {{48, 65, 64}}, {{48, 49, 65}}, {{49, 66, 65}}, {{49, 50, 66}}, {{50, 67, 66}},
	{{51, 52, 68}}, {{52, 69, 68}}, {{52, 53, 69}}, {{53, 70, 69}}, {{53, 54, 70}}, {{54, 71, 70}}, {{54, 55, 71}}, {{55, 72, 71}}, {{55, 56, 72}}, {{56, 73, 72}}, {{56, 57, 73}}, {{57, 74, 73}}, {{57, 58, 74}}, {{58, 75, 74}}, {{58, 59, 75}}, {{59, 76, 75}}, {{59, 60, 76}}, {{60, 77, 76}}, {{60, 61, 77}}, {{61, 78, 77}}, {{61, 62, 78}}, {{62, 79, 78}}, {{62, 63, 79}}, {{63, 80, 79}}, {{63, 64, 80}}, {{64, 81, 80}}, {{64, 65, 81}}, {{65, 82, 81}}, {{65, 66, 82}}, {{66, 83, 82}}, {{66, 67, 83}}, {{67, 84, 83}},

	{{85, 86, 101}}, {{86, 102, 101}}, {{86, 87, 102}}, {{87, 103, 102}}, {{87, 88, 103}}, {{88, 104, 103}}, {{88, 89, 104}}, {{89, 105, 104}}, {{89, 90, 105}}, {{90, 106, 105}}, {{90, 91, 106}}, {{91, 107, 106}}, {{91, 92, 107}}, {{92, 108, 107}}, {{92, 93, 108}}, {{93, 109, 108}}, {{93, 94, 109}}, {{94, 110, 109}}, {{94, 95, 110}}, {{95, 111, 110}}, {{95, 96, 111}}, {{96, 112, 111}}, {{96, 97, 112}}, {{97, 113, 112}}, {{97, 98, 113}}, {{98, 114, 113}}, {{98, 99, 114}}, {{99, 115, 114}}, {{99, 100, 115}}, {{100, 116, 115}}, {{100, 85, 116}}, {{85, 101, 116}},
	{{101, 102, 117}}, {{102, 103, 117}}, {{103, 104, 117}}, {{104, 105, 117}}, {{105, 106, 117}}, {{106, 107, 117}}, {{107, 108, 117}}, {{108, 109, 117}}, {{109, 110, 117}}, {{110, 111, 117}}, {{111, 112, 117}}, {{112, 113, 117}}, {{113, 114, 117}}, {{114, 115, 117}}, {{115, 116, 117}}, {{116, 101, 117}},

	{{134, 135, 118}}, {{135, 119, 118}}, {{135, 136, 119}}, {{136, 120, 119}}, {{136, 137, 120}}, {{137, 121, 120}}, {{137, 138, 121}}, {{138, 122, 121}}, {{138, 139, 122}}, {{139, 123, 122}}, {{139, 140, 123}}, {{140, 124, 123}}, {{140, 141, 124}}, {{141, 125, 124}}, {{141, 142, 125}}, {{142, 126, 125}}, {{142, 143, 126}}, {{143, 127, 126}}, {{143, 144, 127}}, {{144, 128, 127}}, {{144, 145, 128}}, {{145, 129, 128}}, {{145, 146, 129}}, {{146, 130, 129}}, {{146, 147, 130}}, {{147, 131, 130}}, {{147, 148, 131}}, {{148, 132, 131}}, {{148, 149, 132}}, {{149, 133, 132}}, {{149, 134, 133}}, {{134, 118, 133}},
	{{135, 134, 150}}, {{136, 135, 150}}, {{137, 136, 150}}, {{138, 137, 150}}, {{139, 138, 150}}, {{140, 139, 150}}, {{141, 140, 150}}, {{142, 141, 150}}, {{143, 142, 150}}, {{144, 143, 150}}, {{145, 144, 150}}, {{146, 145, 150}}, {{147, 146, 150}}, {{148, 147, 150}}, {{149, 148, 150}}, {{134, 149, 150}}
};

const ConstPoint3D SphereVolumeManipulator::outlinePosition[96] =
{
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.9238795F, 0.3826833F},
	{0.0F, 0.9238795F, 0.3826833F}, {0.0F, 0.7071067F, 0.7071067F},
	{0.0F, 0.7071067F, 0.7071067F}, {0.0F, 0.3826833F, 0.9238795F},
	{0.0F, 0.3826833F, 0.9238795F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 0.0F, 1.0F}, {0.0F, -0.3826833F, 0.9238795F},
	{0.0F, -0.3826833F, 0.9238795F}, {0.0F, -0.7071067F, 0.7071067F},
	{0.0F, -0.7071067F, 0.7071067F}, {0.0F, -0.9238795F, 0.3826833F},
	{0.0F, -0.9238795F, 0.3826833F}, {0.0F, -1.0F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -0.9238795F, -0.3826833F},
	{0.0F, -0.9238795F, -0.3826833F}, {0.0F, -0.7071067F, -0.7071067F},
	{0.0F, -0.7071067F, -0.7071067F}, {0.0F, -0.3826833F, -0.9238795F},
	{0.0F, -0.3826833F, -0.9238795F}, {0.0F, 0.0F, -1.0F},
	{0.0F, 0.0F, -1.0F}, {0.0F, 0.3826833F, -0.9238795F},
	{0.0F, 0.3826833F, -0.9238795F}, {0.0F, 0.7071067F, -0.7071067F},
	{0.0F, 0.7071067F, -0.7071067F}, {0.0F, 0.9238795F, -0.3826833F},
	{0.0F, 0.9238795F, -0.3826833F}, {0.0F, 1.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, 0.0F, 0.3826833F},
	{-0.9238795F, 0.0F, 0.3826833F}, {-0.7071067F, 0.0F, 0.7071067F},
	{-0.7071067F, 0.0F, 0.7071067F}, {-0.3826833F, 0.0F, 0.9238795F},
	{-0.3826833F, 0.0F, 0.9238795F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 0.0F, 1.0F}, {0.3826833F, 0.0F, 0.9238795F},
	{0.3826833F, 0.0F, 0.9238795F}, {0.7071067F, 0.0F, 0.7071067F},
	{0.7071067F, 0.0F, 0.7071067F}, {0.9238795F, 0.0F, 0.3826833F},
	{0.9238795F, 0.0F, 0.3826833F}, {1.0F, 0.0F, 0.0F},
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.0F, -0.3826833F},
	{0.9238795F, 0.0F, -0.3826833F}, {0.7071067F, 0.0F, -0.7071067F},
	{0.7071067F, 0.0F, -0.7071067F}, {0.3826833F, 0.0F, -0.9238795F},
	{0.3826833F, 0.0F, -0.9238795F}, {0.0F, 0.0F, -1.0F},
	{0.0F, 0.0F, -1.0F}, {-0.3826833F, 0.0F, -0.9238795F},
	{-0.3826833F, 0.0F, -0.9238795F}, {-0.7071067F, 0.0F, -0.7071067F},
	{-0.7071067F, 0.0F, -0.7071067F}, {-0.9238795F, 0.0F, -0.3826833F},
	{-0.9238795F, 0.0F, -0.3826833F}, {-1.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826833F, 0.0F},
	{0.9238795F, 0.3826833F, 0.0F}, {0.7071067F, 0.7071067F, 0.0F},
	{0.7071067F, 0.7071067F, 0.0F}, {0.3826833F, 0.9238795F, 0.0F},
	{0.3826833F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826833F, 0.9238795F, 0.0F},
	{-0.3826833F, 0.9238795F, 0.0F}, {-0.7071067F, 0.7071067F, 0.0F},
	{-0.7071067F, 0.7071067F, 0.0F}, {-0.9238795F, 0.3826833F, 0.0F},
	{-0.9238795F, 0.3826833F, 0.0F}, {-1.0F, 0.0F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826833F, 0.0F},
	{-0.9238795F, -0.3826833F, 0.0F}, {-0.7071067F, -0.7071067F, 0.0F},
	{-0.7071067F, -0.7071067F, 0.0F}, {-0.3826833F, -0.9238795F, 0.0F},
	{-0.3826833F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826833F, -0.9238795F, 0.0F},
	{0.3826833F, -0.9238795F, 0.0F}, {0.7071067F, -0.7071067F, 0.0F},
	{0.7071067F, -0.7071067F, 0.0F}, {0.9238795F, -0.3826833F, 0.0F},
	{0.9238795F, -0.3826833F, 0.0F}, {1.0F, 0.0F, 0.0F}
};


SharedVertexBuffer DomeVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer DomeVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D DomeVolumeManipulator::interiorPosition[100] =
{
	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826833F, 0.0F}, {0.7071067F, 0.7071067F, 0.0F}, {0.3826833F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F}, {-0.3826833F, 0.9238795F, 0.0F}, {-0.7071067F, 0.7071067F, 0.0F}, {-0.9238795F, 0.3826833F, 0.0F}, {-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826833F, 0.0F}, {-0.7071067F, -0.7071067F, 0.0F}, {-0.3826833F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F}, {0.3826833F, -0.9238795F, 0.0F}, {0.7071067F, -0.7071067F, 0.0F}, {0.9238795F, -0.3826833F, 0.0F}, {1.0F, 0.0F, 0.0F},
	{0.9238795F, 0.0F, 0.3826833F}, {0.8535532F, 0.3535534F, 0.3826833F}, {0.6532814F, 0.6532814F, 0.3826833F}, {0.3535532F, 0.8535532F, 0.3826833F}, {0.0F, 0.9238795F, 0.3826833F}, {-0.3535532F, 0.8535532F, 0.3826833F}, {-0.6532814F, 0.6532814F, 0.3826833F}, {-0.8535532F, 0.3535534F, 0.3826833F}, {-0.9238795F, 0.0F, 0.3826833F}, {-0.8535532F, -0.3535534F, 0.3826833F}, {-0.6532814F, -0.6532814F, 0.3826833F}, {-0.3535532F, -0.8535532F, 0.3826833F}, {0.0F, -0.9238795F, 0.3826833F}, {0.3535532F, -0.8535532F, 0.3826833F}, {0.6532814F, -0.6532814F, 0.3826833F}, {0.8535532F, -0.3535534F, 0.3826833F}, {0.9238795F, 0.0F, 0.3826833F},
	{0.7071067F, 0.0F, 0.7071067F}, {0.6532814F, 0.270598F, 0.7071067F}, {0.5F, 0.5F, 0.7071067F}, {0.270598F, 0.6532814F, 0.7071067F}, {0.0F, 0.7071067F, 0.7071067F}, {-0.270598F, 0.6532814F, 0.7071067F}, {-0.5F, 0.5F, 0.7071067F}, {-0.6532814F, 0.270598F, 0.7071067F}, {-0.7071067F, 0.0F, 0.7071067F}, {-0.6532814F, -0.270598F, 0.7071067F}, {-0.5F, -0.5F, 0.7071067F}, {-0.270598F, -0.6532814F, 0.7071067F}, {0.0F, -0.7071067F, 0.7071067F}, {0.270598F, -0.6532814F, 0.7071067F}, {0.5F, -0.5F, 0.7071067F}, {0.6532814F, -0.270598F, 0.7071067F}, {0.7071067F, 0.0F, 0.7071067F},

	{0.7071067F, 0.0F, 0.7071067F}, {0.6532814F, 0.270598F, 0.7071067F}, {0.5F, 0.5F, 0.7071067F}, {0.270598F, 0.6532814F, 0.7071067F}, {0.0F, 0.7071067F, 0.7071067F}, {-0.270598F, 0.6532814F, 0.7071067F}, {-0.5F, 0.5F, 0.7071067F}, {-0.6532814F, 0.270598F, 0.7071067F}, {-0.7071067F, 0.0F, 0.7071067F}, {-0.6532814F, -0.270598F, 0.7071067F}, {-0.5F, -0.5F, 0.7071067F}, {-0.270598F, -0.6532814F, 0.7071067F}, {0.0F, -0.7071067F, 0.7071067F}, {0.270598F, -0.6532814F, 0.7071067F}, {0.5F, -0.5F, 0.7071067F}, {0.6532814F, -0.270598F, 0.7071067F},
	{0.3826833F, 0.0F, 0.9238795F}, {0.3535532F, 0.1464465F, 0.9238795F}, {0.270598F, 0.270598F, 0.9238795F}, {0.1464465F, 0.3535532F, 0.9238795F}, {0.0F, 0.3826833F, 0.9238795F}, {-0.1464465F, 0.3535532F, 0.9238795F}, {-0.270598F, 0.270598F, 0.9238795F}, {-0.3535532F, 0.1464465F, 0.9238795F}, {-0.3826833F, 0.0F, 0.9238795F}, {-0.3535532F, -0.1464465F, 0.9238795F}, {-0.270598F, -0.270598F, 0.9238795F}, {-0.1464465F, -0.3535532F, 0.9238795F}, {0.0F, -0.3826833F, 0.9238795F}, {0.1464465F, -0.3535532F, 0.9238795F}, {0.270598F, -0.270598F, 0.9238795F}, {0.3535532F, -0.1464465F, 0.9238795F},
	{0.0F, 0.0F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F}
};

const Triangle DomeVolumeManipulator::interiorTriangle[126] =
{
	{{0, 1, 17}}, {{1, 18, 17}}, {{1, 2, 18}}, {{2, 19, 18}}, {{2, 3, 19}}, {{3, 20, 19}}, {{3, 4, 20}}, {{4, 21, 20}}, {{4, 5, 21}}, {{5, 22, 21}}, {{5, 6, 22}}, {{6, 23, 22}}, {{6, 7, 23}}, {{7, 24, 23}}, {{7, 8, 24}}, {{8, 25, 24}}, {{8, 9, 25}}, {{9, 26, 25}}, {{9, 10, 26}}, {{10, 27, 26}}, {{10, 11, 27}}, {{11, 28, 27}}, {{11, 12, 28}}, {{12, 29, 28}}, {{12, 13, 29}}, {{13, 30, 29}}, {{13, 14, 30}}, {{14, 31, 30}}, {{14, 15, 31}}, {{15, 32, 31}}, {{15, 16, 32}}, {{16, 33, 32}},
	{{17, 18, 34}}, {{18, 35, 34}}, {{18, 19, 35}}, {{19, 36, 35}}, {{19, 20, 36}}, {{20, 37, 36}}, {{20, 21, 37}}, {{21, 38, 37}}, {{21, 22, 38}}, {{22, 39, 38}}, {{22, 23, 39}}, {{23, 40, 39}}, {{23, 24, 40}}, {{24, 41, 40}}, {{24, 25, 41}}, {{25, 42, 41}}, {{25, 26, 42}}, {{26, 43, 42}}, {{26, 27, 43}}, {{27, 44, 43}}, {{27, 28, 44}}, {{28, 45, 44}}, {{28, 29, 45}}, {{29, 46, 45}}, {{29, 30, 46}}, {{30, 47, 46}}, {{30, 31, 47}}, {{31, 48, 47}}, {{31, 32, 48}}, {{32, 49, 48}}, {{32, 33, 49}}, {{33, 50, 49}},

	{{51, 52, 67}}, {{52, 68, 67}}, {{52, 53, 68}}, {{53, 69, 68}}, {{53, 54, 69}}, {{54, 70, 69}}, {{54, 55, 70}}, {{55, 71, 70}}, {{55, 56, 71}}, {{56, 72, 71}}, {{56, 57, 72}}, {{57, 73, 72}}, {{57, 58, 73}}, {{58, 74, 73}}, {{58, 59, 74}}, {{59, 75, 74}}, {{59, 60, 75}}, {{60, 76, 75}}, {{60, 61, 76}}, {{61, 77, 76}}, {{61, 62, 77}}, {{62, 78, 77}}, {{62, 63, 78}}, {{63, 79, 78}}, {{63, 64, 79}}, {{64, 80, 79}}, {{64, 65, 80}}, {{65, 81, 80}}, {{65, 66, 81}}, {{66, 82, 81}}, {{66, 51, 82}}, {{51, 67, 82}},
	{{67, 68, 83}}, {{68, 69, 83}}, {{69, 70, 83}}, {{70, 71, 83}}, {{71, 72, 83}}, {{72, 73, 83}}, {{73, 74, 83}}, {{74, 75, 83}}, {{75, 76, 83}}, {{76, 77, 83}}, {{77, 78, 83}}, {{78, 79, 83}}, {{79, 80, 83}}, {{80, 81, 83}}, {{81, 82, 83}}, {{82, 67, 83}},

	{{84, 99, 85}}, {{85, 99, 86}}, {{86, 99, 98}}, {{86, 98, 87}},
	{{87, 98, 97}}, {{87, 97, 88}}, {{88, 97, 96}}, {{88, 96, 89}},
	{{89, 96, 95}}, {{89, 95, 90}}, {{90, 95, 94}}, {{90, 94, 91}},
	{{91, 94, 93}}, {{91, 93, 92}}
};

const ConstPoint3D DomeVolumeManipulator::outlinePosition[64] =
{
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.9238795F, 0.3826833F},
	{0.0F, 0.9238795F, 0.3826833F}, {0.0F, 0.7071067F, 0.7071067F},
	{0.0F, 0.7071067F, 0.7071067F}, {0.0F, 0.3826833F, 0.9238795F},
	{0.0F, 0.3826833F, 0.9238795F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 0.0F, 1.0F}, {0.0F, -0.3826833F, 0.9238795F},
	{0.0F, -0.3826833F, 0.9238795F}, {0.0F, -0.7071067F, 0.7071067F},
	{0.0F, -0.7071067F, 0.7071067F}, {0.0F, -0.9238795F, 0.3826833F},
	{0.0F, -0.9238795F, 0.3826833F}, {0.0F, -1.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, 0.0F, 0.3826833F},
	{-0.9238795F, 0.0F, 0.3826833F}, {-0.7071067F, 0.0F, 0.7071067F},
	{-0.7071067F, 0.0F, 0.7071067F}, {-0.3826833F, 0.0F, 0.9238795F},
	{-0.3826833F, 0.0F, 0.9238795F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 0.0F, 1.0F}, {0.3826833F, 0.0F, 0.9238795F},
	{0.3826833F, 0.0F, 0.9238795F}, {0.7071067F, 0.0F, 0.7071067F},
	{0.7071067F, 0.0F, 0.7071067F}, {0.9238795F, 0.0F, 0.3826833F},
	{0.9238795F, 0.0F, 0.3826833F}, {1.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826833F, 0.0F},
	{0.9238795F, 0.3826833F, 0.0F}, {0.7071067F, 0.7071067F, 0.0F},
	{0.7071067F, 0.7071067F, 0.0F}, {0.3826833F, 0.9238795F, 0.0F},
	{0.3826833F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826833F, 0.9238795F, 0.0F},
	{-0.3826833F, 0.9238795F, 0.0F}, {-0.7071067F, 0.7071067F, 0.0F},
	{-0.7071067F, 0.7071067F, 0.0F}, {-0.9238795F, 0.3826833F, 0.0F},
	{-0.9238795F, 0.3826833F, 0.0F}, {-1.0F, 0.0F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826833F, 0.0F},
	{-0.9238795F, -0.3826833F, 0.0F}, {-0.7071067F, -0.7071067F, 0.0F},
	{-0.7071067F, -0.7071067F, 0.0F}, {-0.3826833F, -0.9238795F, 0.0F},
	{-0.3826833F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826833F, -0.9238795F, 0.0F},
	{0.3826833F, -0.9238795F, 0.0F}, {0.7071067F, -0.7071067F, 0.0F},
	{0.7071067F, -0.7071067F, 0.0F}, {0.9238795F, -0.3826833F, 0.0F},
	{0.9238795F, -0.3826833F, 0.0F}, {1.0F, 0.0F, 0.0F}
};


SharedVertexBuffer CapsuleVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);

const ConstVector4D CapsuleVolumeManipulator::prototypeInteriorPosition[168] =
{
	{0.7071067F, 0.0F, -0.7071067F, 0.0F}, {0.6532814F, 0.270598F, -0.7071067F, 0.0F}, {0.5F, 0.5F, -0.7071067F, 0.0F}, {0.270598F, 0.6532814F, -0.7071067F, 0.0F}, {0.0F, 0.7071067F, -0.7071067F, 0.0F}, {-0.270598F, 0.6532814F, -0.7071067F, 0.0F}, {-0.5F, 0.5F, -0.7071067F, 0.0F}, {-0.6532814F, 0.270598F, -0.7071067F, 0.0F}, {-0.7071067F, 0.0F, -0.7071067F, 0.0F}, {-0.6532814F, -0.270598F, -0.7071067F, 0.0F}, {-0.5F, -0.5F, -0.7071067F, 0.0F}, {-0.270598F, -0.6532814F, -0.7071067F, 0.0F}, {0.0F, -0.7071067F, -0.7071067F, 0.0F}, {0.270598F, -0.6532814F, -0.7071067F, 0.0F}, {0.5F, -0.5F, -0.7071067F, 0.0F}, {0.6532814F, -0.270598F, -0.7071067F, 0.0F}, {0.7071067F, 0.0F, -0.7071067F, 0.0F},
	{0.9238795F, 0.0F, -0.3826833F, 0.0F}, {0.8535532F, 0.3535534F, -0.3826833F, 0.0F}, {0.6532814F, 0.6532814F, -0.3826833F, 0.0F}, {0.3535532F, 0.8535532F, -0.3826833F, 0.0F}, {0.0F, 0.9238795F, -0.3826833F, 0.0F}, {-0.3535532F, 0.8535532F, -0.3826833F, 0.0F}, {-0.6532814F, 0.6532814F, -0.3826833F, 0.0F}, {-0.8535532F, 0.3535534F, -0.3826833F, 0.0F}, {-0.9238795F, 0.0F, -0.3826833F, 0.0F}, {-0.8535532F, -0.3535534F, -0.3826833F, 0.0F}, {-0.6532814F, -0.6532814F, -0.3826833F, 0.0F}, {-0.3535532F, -0.8535532F, -0.3826833F, 0.0F}, {0.0F, -0.9238795F, -0.3826833F, 0.0F}, {0.3535532F, -0.8535532F, -0.3826833F, 0.0F}, {0.6532814F, -0.6532814F, -0.3826833F, 0.0F}, {0.8535532F, -0.3535534F, -0.3826833F, 0.0F}, {0.9238795F, 0.0F, -0.3826833F, 0.0F},
	{1.0F, 0.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826833F, 0.0F, 0.0F}, {0.7071067F, 0.7071067F, 0.0F, 0.0F}, {0.3826833F, 0.9238795F, 0.0F, 0.0F}, {0.0F, 1.0F, 0.0F, 0.0F}, {-0.3826833F, 0.9238795F, 0.0F, 0.0F}, {-0.7071067F, 0.7071067F, 0.0F, 0.0F}, {-0.9238795F, 0.3826833F, 0.0F, 0.0F}, {-1.0F, 0.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826833F, 0.0F, 0.0F}, {-0.7071067F, -0.7071067F, 0.0F, 0.0F}, {-0.3826833F, -0.9238795F, 0.0F, 0.0F}, {0.0F, -1.0F, 0.0F, 0.0F}, {0.3826833F, -0.9238795F, 0.0F, 0.0F}, {0.7071067F, -0.7071067F, 0.0F, 0.0F}, {0.9238795F, -0.3826833F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F, 0.0F},
	{1.0F, 0.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826833F, 0.0F, 1.0F}, {0.7071067F, 0.7071067F, 0.0F, 1.0F}, {0.3826833F, 0.9238795F, 0.0F, 1.0F}, {0.0F, 1.0F, 0.0F, 1.0F}, {-0.3826833F, 0.9238795F, 0.0F, 1.0F}, {-0.7071067F, 0.7071067F, 0.0F, 1.0F}, {-0.9238795F, 0.3826833F, 0.0F, 1.0F}, {-1.0F, 0.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826833F, 0.0F, 1.0F}, {-0.7071067F, -0.7071067F, 0.0F, 1.0F}, {-0.3826833F, -0.9238795F, 0.0F, 1.0F}, {0.0F, -1.0F, 0.0F, 1.0F}, {0.3826833F, -0.9238795F, 0.0F, 1.0F}, {0.7071067F, -0.7071067F, 0.0F, 1.0F}, {0.9238795F, -0.3826833F, 0.0F, 1.0F}, {1.0F, 0.0F, 0.0F, 1.0F},
	{0.9238795F, 0.0F, 0.3826833F, 1.0F}, {0.8535532F, 0.3535534F, 0.3826833F, 1.0F}, {0.6532814F, 0.6532814F, 0.3826833F, 1.0F}, {0.3535532F, 0.8535532F, 0.3826833F, 1.0F}, {0.0F, 0.9238795F, 0.3826833F, 1.0F}, {-0.3535532F, 0.8535532F, 0.3826833F, 1.0F}, {-0.6532814F, 0.6532814F, 0.3826833F, 1.0F}, {-0.8535532F, 0.3535534F, 0.3826833F, 1.0F}, {-0.9238795F, 0.0F, 0.3826833F, 1.0F}, {-0.8535532F, -0.3535534F, 0.3826833F, 1.0F}, {-0.6532814F, -0.6532814F, 0.3826833F, 1.0F}, {-0.3535532F, -0.8535532F, 0.3826833F, 1.0F}, {0.0F, -0.9238795F, 0.3826833F, 1.0F}, {0.3535532F, -0.8535532F, 0.3826833F, 1.0F}, {0.6532814F, -0.6532814F, 0.3826833F, 1.0F}, {0.8535532F, -0.3535534F, 0.3826833F, 1.0F}, {0.9238795F, 0.0F, 0.3826833F, 1.0F},
	{0.7071067F, 0.0F, 0.7071067F, 1.0F}, {0.6532814F, 0.270598F, 0.7071067F, 1.0F}, {0.5F, 0.5F, 0.7071067F, 1.0F}, {0.270598F, 0.6532814F, 0.7071067F, 1.0F}, {0.0F, 0.7071067F, 0.7071067F, 1.0F}, {-0.270598F, 0.6532814F, 0.7071067F, 1.0F}, {-0.5F, 0.5F, 0.7071067F, 1.0F}, {-0.6532814F, 0.270598F, 0.7071067F, 1.0F}, {-0.7071067F, 0.0F, 0.7071067F, 1.0F}, {-0.6532814F, -0.270598F, 0.7071067F, 1.0F}, {-0.5F, -0.5F, 0.7071067F, 1.0F}, {-0.270598F, -0.6532814F, 0.7071067F, 1.0F}, {0.0F, -0.7071067F, 0.7071067F, 1.0F}, {0.270598F, -0.6532814F, 0.7071067F, 1.0F}, {0.5F, -0.5F, 0.7071067F, 1.0F}, {0.6532814F, -0.270598F, 0.7071067F, 1.0F}, {0.7071067F, 0.0F, 0.7071067F, 1.0F},

	{0.7071067F, 0.0F, 0.7071067F, 1.0F}, {0.6532814F, 0.270598F, 0.7071067F, 1.0F}, {0.5F, 0.5F, 0.7071067F, 1.0F}, {0.270598F, 0.6532814F, 0.7071067F, 1.0F}, {0.0F, 0.7071067F, 0.7071067F, 1.0F}, {-0.270598F, 0.6532814F, 0.7071067F, 1.0F}, {-0.5F, 0.5F, 0.7071067F, 1.0F}, {-0.6532814F, 0.270598F, 0.7071067F, 1.0F}, {-0.7071067F, 0.0F, 0.7071067F, 1.0F}, {-0.6532814F, -0.270598F, 0.7071067F, 1.0F}, {-0.5F, -0.5F, 0.7071067F, 1.0F}, {-0.270598F, -0.6532814F, 0.7071067F, 1.0F}, {0.0F, -0.7071067F, 0.7071067F, 1.0F}, {0.270598F, -0.6532814F, 0.7071067F, 1.0F}, {0.5F, -0.5F, 0.7071067F, 1.0F}, {0.6532814F, -0.270598F, 0.7071067F, 1.0F},
	{0.3826833F, 0.0F, 0.9238795F, 1.0F}, {0.3535532F, 0.1464465F, 0.9238795F, 1.0F}, {0.270598F, 0.270598F, 0.9238795F, 1.0F}, {0.1464465F, 0.3535532F, 0.9238795F, 1.0F}, {0.0F, 0.3826833F, 0.9238795F, 1.0F}, {-0.1464465F, 0.3535532F, 0.9238795F, 1.0F}, {-0.270598F, 0.270598F, 0.9238795F, 1.0F}, {-0.3535532F, 0.1464465F, 0.9238795F, 1.0F}, {-0.3826833F, 0.0F, 0.9238795F, 1.0F}, {-0.3535532F, -0.1464465F, 0.9238795F, 1.0F}, {-0.270598F, -0.270598F, 0.9238795F, 1.0F}, {-0.1464465F, -0.3535532F, 0.9238795F, 1.0F}, {0.0F, -0.3826833F, 0.9238795F, 1.0F}, {0.1464465F, -0.3535532F, 0.9238795F, 1.0F}, {0.270598F, -0.270598F, 0.9238795F, 1.0F}, {0.3535532F, -0.1464465F, 0.9238795F, 1.0F},
	{0.0F, 0.0F, 1.0F, 1.0F},

	{0.7071067F, 0.0F, -0.7071067F, 0.0F}, {0.6532814F, 0.270598F, -0.7071067F, 0.0F}, {0.5F, 0.5F, -0.7071067F, 0.0F}, {0.270598F, 0.6532814F, -0.7071067F, 0.0F}, {0.0F, 0.7071067F, -0.7071067F, 0.0F}, {-0.270598F, 0.6532814F, -0.7071067F, 0.0F}, {-0.5F, 0.5F, -0.7071067F, 0.0F}, {-0.6532814F, 0.270598F, -0.7071067F, 0.0F}, {-0.7071067F, 0.0F, -0.7071067F, 0.0F}, {-0.6532814F, -0.270598F, -0.7071067F, 0.0F}, {-0.5F, -0.5F, -0.7071067F, 0.0F}, {-0.270598F, -0.6532814F, -0.7071067F, 0.0F}, {0.0F, -0.7071067F, -0.7071067F, 0.0F}, {0.270598F, -0.6532814F, -0.7071067F, 0.0F}, {0.5F, -0.5F, -0.7071067F, 0.0F}, {0.6532814F, -0.270598F, -0.7071067F, 0.0F},
	{0.3826833F, 0.0F, -0.9238795F, 0.0F}, {0.3535532F, 0.1464465F, -0.9238795F, 0.0F}, {0.270598F, 0.270598F, -0.9238795F, 0.0F}, {0.1464465F, 0.3535532F, -0.9238795F, 0.0F}, {0.0F, 0.3826833F, -0.9238795F, 0.0F}, {-0.1464465F, 0.3535532F, -0.9238795F, 0.0F}, {-0.270598F, 0.270598F, -0.9238795F, 0.0F}, {-0.3535532F, 0.1464465F, -0.9238795F, 0.0F}, {-0.3826833F, 0.0F, -0.9238795F, 0.0F}, {-0.3535532F, -0.1464465F, -0.9238795F, 0.0F}, {-0.270598F, -0.270598F, -0.9238795F, 0.0F}, {-0.1464465F, -0.3535532F, -0.9238795F, 0.0F}, {0.0F, -0.3826833F, -0.9238795F, 0.0F}, {0.1464465F, -0.3535532F, -0.9238795F, 0.0F}, {0.270598F, -0.270598F, -0.9238795F, 0.0F}, {0.3535532F, -0.1464465F, -0.9238795F, 0.0F},
	{0.0F, 0.0F, -1.0F, 0.0F}
};

const Triangle CapsuleVolumeManipulator::interiorTriangle[256] =
{
	{{0, 1, 17}}, {{1, 18, 17}}, {{1, 2, 18}}, {{2, 19, 18}}, {{2, 3, 19}}, {{3, 20, 19}}, {{3, 4, 20}}, {{4, 21, 20}}, {{4, 5, 21}}, {{5, 22, 21}}, {{5, 6, 22}}, {{6, 23, 22}}, {{6, 7, 23}}, {{7, 24, 23}}, {{7, 8, 24}}, {{8, 25, 24}}, {{8, 9, 25}}, {{9, 26, 25}}, {{9, 10, 26}}, {{10, 27, 26}}, {{10, 11, 27}}, {{11, 28, 27}}, {{11, 12, 28}}, {{12, 29, 28}}, {{12, 13, 29}}, {{13, 30, 29}}, {{13, 14, 30}}, {{14, 31, 30}}, {{14, 15, 31}}, {{15, 32, 31}}, {{15, 16, 32}}, {{16, 33, 32}},
	{{17, 18, 34}}, {{18, 35, 34}}, {{18, 19, 35}}, {{19, 36, 35}}, {{19, 20, 36}}, {{20, 37, 36}}, {{20, 21, 37}}, {{21, 38, 37}}, {{21, 22, 38}}, {{22, 39, 38}}, {{22, 23, 39}}, {{23, 40, 39}}, {{23, 24, 40}}, {{24, 41, 40}}, {{24, 25, 41}}, {{25, 42, 41}}, {{25, 26, 42}}, {{26, 43, 42}}, {{26, 27, 43}}, {{27, 44, 43}}, {{27, 28, 44}}, {{28, 45, 44}}, {{28, 29, 45}}, {{29, 46, 45}}, {{29, 30, 46}}, {{30, 47, 46}}, {{30, 31, 47}}, {{31, 48, 47}}, {{31, 32, 48}}, {{32, 49, 48}}, {{32, 33, 49}}, {{33, 50, 49}},
	{{51, 52, 68}}, {{52, 69, 68}}, {{52, 53, 69}}, {{53, 70, 69}}, {{53, 54, 70}}, {{54, 71, 70}}, {{54, 55, 71}}, {{55, 72, 71}}, {{55, 56, 72}}, {{56, 73, 72}}, {{56, 57, 73}}, {{57, 74, 73}}, {{57, 58, 74}}, {{58, 75, 74}}, {{58, 59, 75}}, {{59, 76, 75}}, {{59, 60, 76}}, {{60, 77, 76}}, {{60, 61, 77}}, {{61, 78, 77}}, {{61, 62, 78}}, {{62, 79, 78}}, {{62, 63, 79}}, {{63, 80, 79}}, {{63, 64, 80}}, {{64, 81, 80}}, {{64, 65, 81}}, {{65, 82, 81}}, {{65, 66, 82}}, {{66, 83, 82}}, {{66, 67, 83}}, {{67, 84, 83}},
	{{68, 69, 85}}, {{69, 86, 85}}, {{69, 70, 86}}, {{70, 87, 86}}, {{70, 71, 87}}, {{71, 88, 87}}, {{71, 72, 88}}, {{72, 89, 88}}, {{72, 73, 89}}, {{73, 90, 89}}, {{73, 74, 90}}, {{74, 91, 90}}, {{74, 75, 91}}, {{75, 92, 91}}, {{75, 76, 92}}, {{76, 93, 92}}, {{76, 77, 93}}, {{77, 94, 93}}, {{77, 78, 94}}, {{78, 95, 94}}, {{78, 79, 95}}, {{79, 96, 95}}, {{79, 80, 96}}, {{80, 97, 96}}, {{80, 81, 97}}, {{81, 98, 97}}, {{81, 82, 98}}, {{82, 99, 98}}, {{82, 83, 99}}, {{83, 100, 99}}, {{83, 84, 100}}, {{84, 101, 100}},

	{{102, 103, 118}}, {{103, 119, 118}}, {{103, 104, 119}}, {{104, 120, 119}}, {{104, 105, 120}}, {{105, 121, 120}}, {{105, 106, 121}}, {{106, 122, 121}}, {{106, 107, 122}}, {{107, 123, 122}}, {{107, 108, 123}}, {{108, 124, 123}}, {{108, 109, 124}}, {{109, 125, 124}}, {{109, 110, 125}}, {{110, 126, 125}}, {{110, 111, 126}}, {{111, 127, 126}}, {{111, 112, 127}}, {{112, 128, 127}}, {{112, 113, 128}}, {{113, 129, 128}}, {{113, 114, 129}}, {{114, 130, 129}}, {{114, 115, 130}}, {{115, 131, 130}}, {{115, 116, 131}}, {{116, 132, 131}}, {{116, 117, 132}}, {{117, 133, 132}}, {{117, 102, 133}}, {{102, 118, 133}},
	{{118, 119, 134}}, {{119, 120, 134}}, {{120, 121, 134}}, {{121, 122, 134}}, {{122, 123, 134}}, {{123, 124, 134}}, {{124, 125, 134}}, {{125, 126, 134}}, {{126, 127, 134}}, {{127, 128, 134}}, {{128, 129, 134}}, {{129, 130, 134}}, {{130, 131, 134}}, {{131, 132, 134}}, {{132, 133, 134}}, {{133, 118, 134}},

	{{151, 152, 135}}, {{152, 136, 135}}, {{152, 153, 136}}, {{153, 137, 136}}, {{153, 154, 137}}, {{154, 138, 137}}, {{154, 155, 138}}, {{155, 139, 138}}, {{155, 156, 139}}, {{156, 140, 139}}, {{156, 157, 140}}, {{157, 141, 140}}, {{157, 158, 141}}, {{158, 142, 141}}, {{158, 159, 142}}, {{159, 143, 142}}, {{159, 160, 143}}, {{160, 144, 143}}, {{160, 161, 144}}, {{161, 145, 144}}, {{161, 162, 145}}, {{162, 146, 145}}, {{162, 163, 146}}, {{163, 147, 146}}, {{163, 164, 147}}, {{164, 148, 147}}, {{164, 165, 148}}, {{165, 149, 148}}, {{165, 166, 149}}, {{166, 150, 149}}, {{166, 151, 150}}, {{151, 135, 150}},
	{{152, 151, 167}}, {{153, 152, 167}}, {{154, 153, 167}}, {{155, 154, 167}}, {{156, 155, 167}}, {{157, 156, 167}}, {{158, 157, 167}}, {{159, 158, 167}}, {{160, 159, 167}}, {{161, 160, 167}}, {{162, 161, 167}}, {{163, 162, 167}}, {{164, 163, 167}}, {{165, 164, 167}}, {{166, 165, 167}}, {{151, 166, 167}},

	{{34, 35, 51}}, {{35, 52, 51}}, {{35, 36, 52}}, {{36, 53, 52}},
	{{36, 37, 53}}, {{37, 54, 53}}, {{37, 38, 54}}, {{38, 55, 54}},
	{{38, 39, 55}}, {{39, 56, 55}}, {{39, 40, 56}}, {{40, 57, 56}},
	{{40, 41, 57}}, {{41, 58, 57}}, {{41, 42, 58}}, {{42, 59, 58}},
	{{42, 43, 59}}, {{43, 60, 59}}, {{43, 44, 60}}, {{44, 61, 60}},
	{{44, 45, 61}}, {{45, 62, 61}}, {{45, 46, 62}}, {{46, 63, 62}},
	{{46, 47, 63}}, {{47, 64, 63}}, {{47, 48, 64}}, {{48, 65, 64}},
	{{48, 49, 65}}, {{49, 66, 65}}, {{49, 50, 66}}, {{50, 67, 66}}
};

const ConstVector4D CapsuleVolumeManipulator::prototypeOutlinePosition[136] =
{
	{0.0F, 1.0F, 0.0F, 1.0F}, {0.0F, 0.9238795F, 0.3826833F, 1.0F},
	{0.0F, 0.9238795F, 0.3826833F, 1.0F}, {0.0F, 0.7071067F, 0.7071067F, 1.0F},
	{0.0F, 0.7071067F, 0.7071067F, 1.0F}, {0.0F, 0.3826833F, 0.9238795F, 1.0F},
	{0.0F, 0.3826833F, 0.9238795F, 1.0F}, {0.0F, 0.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 1.0F, 1.0F}, {0.0F, -0.3826833F, 0.9238795F, 1.0F},
	{0.0F, -0.3826833F, 0.9238795F, 1.0F}, {0.0F, -0.7071067F, 0.7071067F, 1.0F},
	{0.0F, -0.7071067F, 0.7071067F, 1.0F}, {0.0F, -0.9238795F, 0.3826833F, 1.0F},
	{0.0F, -0.9238795F, 0.3826833F, 1.0F}, {0.0F, -1.0F, 0.0F, 1.0F},

	{0.0F, -1.0F, 0.0F, 0.0F}, {0.0F, -0.9238795F, -0.3826833F, 0.0F},
	{0.0F, -0.9238795F, -0.3826833F, 0.0F}, {0.0F, -0.7071067F, -0.7071067F, 0.0F},
	{0.0F, -0.7071067F, -0.7071067F, 0.0F}, {0.0F, -0.3826833F, -0.9238795F, 0.0F},
	{0.0F, -0.3826833F, -0.9238795F, 0.0F}, {0.0F, 0.0F, -1.0F, 0.0F},
	{0.0F, 0.0F, -1.0F, 0.0F}, {0.0F, 0.3826833F, -0.9238795F, 0.0F},
	{0.0F, 0.3826833F, -0.9238795F, 0.0F}, {0.0F, 0.7071067F, -0.7071067F, 0.0F},
	{0.0F, 0.7071067F, -0.7071067F, 0.0F}, {0.0F, 0.9238795F, -0.3826833F, 0.0F},
	{0.0F, 0.9238795F, -0.3826833F, 0.0F}, {0.0F, 1.0F, 0.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F, 1.0F}, {-0.9238795F, 0.0F, 0.3826833F, 1.0F},
	{-0.9238795F, 0.0F, 0.3826833F, 1.0F}, {-0.7071067F, 0.0F, 0.7071067F, 1.0F},
	{-0.7071067F, 0.0F, 0.7071067F, 1.0F}, {-0.3826833F, 0.0F, 0.9238795F, 1.0F},
	{-0.3826833F, 0.0F, 0.9238795F, 1.0F}, {0.0F, 0.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 1.0F, 1.0F}, {0.3826833F, 0.0F, 0.9238795F, 1.0F},
	{0.3826833F, 0.0F, 0.9238795F, 1.0F}, {0.7071067F, 0.0F, 0.7071067F, 1.0F},
	{0.7071067F, 0.0F, 0.7071067F, 1.0F}, {0.9238795F, 0.0F, 0.3826833F, 1.0F},
	{0.9238795F, 0.0F, 0.3826833F, 1.0F}, {1.0F, 0.0F, 0.0F, 1.0F},

	{1.0F, 0.0F, 0.0F, 0.0F}, {0.9238795F, 0.0F, -0.3826833F, 0.0F},
	{0.9238795F, 0.0F, -0.3826833F, 0.0F}, {0.7071067F, 0.0F, -0.7071067F, 0.0F},
	{0.7071067F, 0.0F, -0.7071067F, 0.0F}, {0.3826833F, 0.0F, -0.9238795F, 0.0F},
	{0.3826833F, 0.0F, -0.9238795F, 0.0F}, {0.0F, 0.0F, -1.0F, 0.0F},
	{0.0F, 0.0F, -1.0F, 0.0F}, {-0.3826833F, 0.0F, -0.9238795F, 0.0F},
	{-0.3826833F, 0.0F, -0.9238795F, 0.0F}, {-0.7071067F, 0.0F, -0.7071067F, 0.0F},
	{-0.7071067F, 0.0F, -0.7071067F, 0.0F}, {-0.9238795F, 0.0F, -0.3826833F, 0.0F},
	{-0.9238795F, 0.0F, -0.3826833F, 0.0F}, {-1.0F, 0.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826833F, 0.0F, 1.0F},
	{0.9238795F, 0.3826833F, 0.0F, 1.0F}, {0.7071067F, 0.7071067F, 0.0F, 1.0F},
	{0.7071067F, 0.7071067F, 0.0F, 1.0F}, {0.3826833F, 0.9238795F, 0.0F, 1.0F},
	{0.3826833F, 0.9238795F, 0.0F, 1.0F}, {0.0F, 1.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F, 1.0F}, {-0.3826833F, 0.9238795F, 0.0F, 1.0F},
	{-0.3826833F, 0.9238795F, 0.0F, 1.0F}, {-0.7071067F, 0.7071067F, 0.0F, 1.0F},
	{-0.7071067F, 0.7071067F, 0.0F, 1.0F}, {-0.9238795F, 0.3826833F, 0.0F, 1.0F},
	{-0.9238795F, 0.3826833F, 0.0F, 1.0F}, {-1.0F, 0.0F, 0.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826833F, 0.0F, 1.0F},
	{-0.9238795F, -0.3826833F, 0.0F, 1.0F}, {-0.7071067F, -0.7071067F, 0.0F, 1.0F},
	{-0.7071067F, -0.7071067F, 0.0F, 1.0F}, {-0.3826833F, -0.9238795F, 0.0F, 1.0F},
	{-0.3826833F, -0.9238795F, 0.0F, 1.0F}, {0.0F, -1.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F, 1.0F}, {0.3826833F, -0.9238795F, 0.0F, 1.0F},
	{0.3826833F, -0.9238795F, 0.0F, 1.0F}, {0.7071067F, -0.7071067F, 0.0F, 1.0F},
	{0.7071067F, -0.7071067F, 0.0F, 1.0F}, {0.9238795F, -0.3826833F, 0.0F, 1.0F},
	{0.9238795F, -0.3826833F, 0.0F, 1.0F}, {1.0F, 0.0F, 0.0F, 1.0F},

	{1.0F, 0.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826833F, 0.0F, 0.0F},
	{0.9238795F, 0.3826833F, 0.0F, 0.0F}, {0.7071067F, 0.7071067F, 0.0F, 0.0F},
	{0.7071067F, 0.7071067F, 0.0F, 0.0F}, {0.3826833F, 0.9238795F, 0.0F, 0.0F},
	{0.3826833F, 0.9238795F, 0.0F, 0.0F}, {0.0F, 1.0F, 0.0F, 0.0F},
	{0.0F, 1.0F, 0.0F, 0.0F}, {-0.3826833F, 0.9238795F, 0.0F, 0.0F},
	{-0.3826833F, 0.9238795F, 0.0F, 0.0F}, {-0.7071067F, 0.7071067F, 0.0F, 0.0F},
	{-0.7071067F, 0.7071067F, 0.0F, 0.0F}, {-0.9238795F, 0.3826833F, 0.0F, 0.0F},
	{-0.9238795F, 0.3826833F, 0.0F, 0.0F}, {-1.0F, 0.0F, 0.0F, 0.0F},
	{-1.0F, 0.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826833F, 0.0F, 0.0F},
	{-0.9238795F, -0.3826833F, 0.0F, 0.0F}, {-0.7071067F, -0.7071067F, 0.0F, 0.0F},
	{-0.7071067F, -0.7071067F, 0.0F, 0.0F}, {-0.3826833F, -0.9238795F, 0.0F, 0.0F},
	{-0.3826833F, -0.9238795F, 0.0F, 0.0F}, {0.0F, -1.0F, 0.0F, 0.0F},
	{0.0F, -1.0F, 0.0F, 0.0F}, {0.3826833F, -0.9238795F, 0.0F, 0.0F},
	{0.3826833F, -0.9238795F, 0.0F, 0.0F}, {0.7071067F, -0.7071067F, 0.0F, 0.0F},
	{0.7071067F, -0.7071067F, 0.0F, 0.0F}, {0.9238795F, -0.3826833F, 0.0F, 0.0F},
	{0.9238795F, -0.3826833F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F, 0.0F}, {0.0F, 1.0F, 0.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F, 0.0F}, {0.0F, -1.0F, 0.0F, 1.0F}
};


const ConstPoint3D TruncatedPyramidVolumeManipulator::prototypeInteriorPosition[24] =
{
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 1.0F}, {1.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F}, {0.0F, 1.0F, 1.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F}, {1.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F}, {0.0F, 0.0F, 1.0F},
	{0.0F, 0.0F, 1.0F}, {1.0F, 0.0F, 1.0F}, {1.0F, 1.0F, 1.0F}, {0.0F, 1.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 0.0F}, {1.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 0.0F}
};

const ConstPoint3D TruncatedPyramidVolumeManipulator::prototypeOutlinePosition[24] =
{
	{0.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 0.0F},
	{1.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 0.0F, 0.0F},

	{0.0F, 0.0F, 1.0F}, {1.0F, 0.0F, 1.0F},
	{1.0F, 0.0F, 1.0F}, {1.0F, 1.0F, 1.0F},
	{1.0F, 1.0F, 1.0F}, {0.0F, 1.0F, 1.0F},
	{0.0F, 1.0F, 1.0F}, {0.0F, 0.0F, 1.0F},

	{0.0F, 0.0F, 0.0F}, {0.0F, 0.0F, 1.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F},
	{1.0F, 1.0F, 0.0F}, {1.0F, 1.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F}
};


SharedVertexBuffer TruncatedConeVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);

const ConstPoint3D TruncatedConeVolumeManipulator::prototypeInteriorPosition[66] =
{
	{1.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826834F, 1.0F}, {0.7071068F, 0.7071068F, 1.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.0F, 1.0F, 1.0F}, {-0.3826834F, 0.9238795F, 1.0F}, {-0.7071068F, 0.7071068F, 1.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-1.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826834F, 1.0F}, {-0.7071068F, -0.7071068F, 1.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{0.0F, -1.0F, 1.0F}, {0.3826834F, -0.9238795F, 1.0F}, {0.7071068F, -0.7071068F, 1.0F}, {0.9238795F, -0.3826834F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.9238795F, 0.3826834F, 1.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.7071068F, 0.7071068F, 1.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.3826834F, 0.9238795F, 1.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.7071068F, 0.7071068F, 1.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 1.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.9238795F, -0.3826834F, 1.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.7071068F, -0.7071068F, 1.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -1.0F, 1.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.3826834F, -0.9238795F, 1.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.7071068F, -0.7071068F, 1.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {0.9238795F, -0.3826834F, 1.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F}
};

const Triangle TruncatedConeVolumeManipulator::interiorTriangle[60] =
{
	{{0, 1, 15}}, {{1, 2, 15}}, {{2, 14, 15}}, {{2, 3, 14}},
	{{3, 13, 14}}, {{3, 4, 13}}, {{4, 12, 13}}, {{4, 5, 12}},
	{{5, 11, 12}}, {{5, 6, 11}}, {{6, 10, 11}}, {{6, 7, 10}},
	{{7, 9, 10}}, {{7, 8, 9}},

	{{16, 31, 17}}, {{17, 31, 18}}, {{18, 31, 30}}, {{18, 30, 19}},
	{{19, 30, 29}}, {{19, 29, 20}}, {{20, 29, 28}}, {{20, 28, 21}},
	{{21, 28, 27}}, {{21, 27, 22}}, {{22, 27, 26}}, {{22, 26, 23}},
	{{23, 26, 25}}, {{23, 25, 24}},

	{{32, 34, 33}}, {{34, 35, 33}}, {{34, 36, 35}}, {{36, 37, 35}},
	{{36, 38, 37}}, {{38, 39, 37}}, {{38, 40, 39}}, {{40, 41, 39}},
	{{40, 42, 41}}, {{42, 43, 41}}, {{42, 44, 43}}, {{44, 45, 43}},
	{{44, 46, 45}}, {{46, 47, 45}}, {{46, 48, 47}}, {{48, 49, 47}},
	{{48, 50, 49}}, {{50, 51, 49}}, {{50, 52, 51}}, {{52, 53, 51}},
	{{52, 54, 53}}, {{54, 55, 53}}, {{54, 56, 55}}, {{56, 57, 55}},
	{{56, 58, 57}}, {{58, 59, 57}}, {{58, 60, 59}}, {{60, 61, 59}},
	{{60, 62, 61}}, {{62, 63, 61}}, {{62, 64, 63}}, {{64, 65, 63}}
};

const ConstPoint3D TruncatedConeVolumeManipulator::prototypeOutlinePosition[72] =
{
	{1.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826834F, 1.0F},
	{0.9238795F, 0.3826834F, 1.0F}, {0.7071068F, 0.7071068F, 1.0F},
	{0.7071068F, 0.7071068F, 1.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.3826834F, 0.9238795F, 1.0F}, {0.0F, 1.0F, 1.0F},

	{0.0F, 1.0F, 1.0F}, {-0.3826834F, 0.9238795F, 1.0F},
	{-0.3826834F, 0.9238795F, 1.0F}, {-0.7071068F, 0.7071068F, 1.0F},
	{-0.7071068F, 0.7071068F, 1.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-0.9238795F, 0.3826834F, 1.0F}, {-1.0F, 0.0F, 1.0F},

	{-1.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826834F, 1.0F},
	{-0.9238795F, -0.3826834F, 1.0F}, {-0.7071068F, -0.7071068F, 1.0F},
	{-0.7071068F, -0.7071068F, 1.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{-0.3826834F, -0.9238795F, 1.0F}, {0.0F, -1.0F, 1.0F},

	{0.0F, -1.0F, 1.0F}, {0.3826834F, -0.9238795F, 1.0F},
	{0.3826834F, -0.9238795F, 1.0F}, {0.7071068F, -0.7071068F, 1.0F},
	{0.7071068F, -0.7071068F, 1.0F}, {0.9238795F, -0.3826834F, 1.0F},
	{0.9238795F, -0.3826834F, 1.0F}, {1.0F, 0.0F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},

	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-1.0F, 0.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},

	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {1.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -1.0F, 1.0F}
};


SharedVertexBuffer TruncatedDomeVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);

const ConstPoint3D TruncatedDomeVolumeManipulator::prototypeInteriorPosition[100] =
{
	{1.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826834F, 1.0F}, {0.7071068F, 0.7071068F, 1.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.0F, 1.0F, 1.0F}, {-0.3826834F, 0.9238795F, 1.0F}, {-0.7071068F, 0.7071068F, 1.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-1.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826834F, 1.0F}, {-0.7071068F, -0.7071068F, 1.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{0.0F, -1.0F, 1.0F}, {0.3826834F, -0.9238795F, 1.0F}, {0.7071068F, -0.7071068F, 1.0F}, {0.9238795F, -0.3826834F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.333333F}, {1.0F, 0.0F, 0.666667F}, {1.0F, 0.0F, 1.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.9238795F, 0.3826834F, 0.333333F}, {0.9238795F, 0.3826834F, 0.666667F}, {0.9238795F, 0.3826834F, 1.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.7071068F, 0.7071068F, 0.333333F}, {0.7071068F, 0.7071068F, 0.666667F}, {0.7071068F, 0.7071068F, 1.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.3826834F, 0.9238795F, 0.333333F}, {0.3826834F, 0.9238795F, 0.666667F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.333333F}, {0.0F, 1.0F, 0.666667F}, {0.0F, 1.0F, 1.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.3826834F, 0.9238795F, 0.333333F}, {-0.3826834F, 0.9238795F, 0.666667F}, {-0.3826834F, 0.9238795F, 1.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.7071068F, 0.7071068F, 0.333333F}, {-0.7071068F, 0.7071068F, 0.666667F}, {-0.7071068F, 0.7071068F, 1.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-0.9238795F, 0.3826834F, 0.333333F}, {-0.9238795F, 0.3826834F, 0.666667F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 0.333333F}, {-1.0F, 0.0F, 0.666667F}, {-1.0F, 0.0F, 1.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.9238795F, -0.3826834F, 0.333333F}, {-0.9238795F, -0.3826834F, 0.666667F}, {-0.9238795F, -0.3826834F, 1.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.7071068F, -0.7071068F, 0.333333F}, {-0.7071068F, -0.7071068F, 0.666667F}, {-0.7071068F, -0.7071068F, 1.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {-0.3826834F, -0.9238795F, 0.333333F}, {-0.3826834F, -0.9238795F, 0.666667F}, {-0.3826834F, -0.9238795F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -1.0F, 0.333333F}, {0.0F, -1.0F, 0.666667F}, {0.0F, -1.0F, 1.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.3826834F, -0.9238795F, 0.333333F}, {0.3826834F, -0.9238795F, 0.666667F}, {0.3826834F, -0.9238795F, 1.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.7071068F, -0.7071068F, 0.333333F}, {0.7071068F, -0.7071068F, 0.666667F}, {0.7071068F, -0.7071068F, 1.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {0.9238795F, -0.3826834F, 0.333333F}, {0.9238795F, -0.3826834F, 0.666667F}, {0.9238795F, -0.3826834F, 1.0F},
	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.333333F}, {1.0F, 0.0F, 0.666667F}, {1.0F, 0.0F, 1.0F}
};

const Triangle TruncatedDomeVolumeManipulator::interiorTriangle[124] =
{
	{{0, 1, 15}}, {{1, 2, 15}}, {{2, 14, 15}}, {{2, 3, 14}},
	{{3, 13, 14}}, {{3, 4, 13}}, {{4, 12, 13}}, {{4, 5, 12}},
	{{5, 11, 12}}, {{5, 6, 11}}, {{6, 10, 11}}, {{6, 7, 10}},
	{{7, 9, 10}}, {{7, 8, 9}},

	{{16, 31, 17}}, {{17, 31, 18}}, {{18, 31, 30}}, {{18, 30, 19}},
	{{19, 30, 29}}, {{19, 29, 20}}, {{20, 29, 28}}, {{20, 28, 21}},
	{{21, 28, 27}}, {{21, 27, 22}}, {{22, 27, 26}}, {{22, 26, 23}},
	{{23, 26, 25}}, {{23, 25, 24}},

	{{32, 36, 33}}, {{36, 37, 33}}, {{33, 37, 34}}, {{37, 38, 34}}, {{34, 38, 35}}, {{38, 39, 35}},
	{{36, 40, 37}}, {{40, 41, 37}}, {{37, 41, 38}}, {{41, 42, 38}}, {{38, 42, 39}}, {{42, 43, 39}},
	{{40, 44, 41}}, {{44, 45, 41}}, {{41, 45, 42}}, {{45, 46, 42}}, {{42, 46, 43}}, {{46, 47, 43}},
	{{44, 48, 45}}, {{48, 49, 45}}, {{45, 49, 46}}, {{49, 50, 46}}, {{46, 50, 47}}, {{50, 51, 47}},
	{{48, 52, 49}}, {{52, 53, 49}}, {{49, 53, 50}}, {{53, 54, 50}}, {{50, 54, 51}}, {{54, 55, 51}},
	{{52, 56, 53}}, {{56, 57, 53}}, {{53, 57, 54}}, {{57, 58, 54}}, {{54, 58, 55}}, {{58, 59, 55}},
	{{56, 60, 57}}, {{60, 61, 57}}, {{57, 61, 58}}, {{61, 62, 58}}, {{58, 62, 59}}, {{62, 63, 59}},
	{{60, 64, 61}}, {{64, 65, 61}}, {{61, 65, 62}}, {{65, 66, 62}}, {{62, 66, 63}}, {{66, 67, 63}},
	{{64, 68, 65}}, {{68, 69, 65}}, {{65, 69, 66}}, {{69, 70, 66}}, {{66, 70, 67}}, {{70, 71, 67}},
	{{68, 72, 69}}, {{72, 73, 69}}, {{69, 73, 70}}, {{73, 74, 70}}, {{70, 74, 71}}, {{74, 75, 71}},
	{{72, 76, 73}}, {{76, 77, 73}}, {{73, 77, 74}}, {{77, 78, 74}}, {{74, 78, 75}}, {{78, 79, 75}},
	{{76, 80, 77}}, {{80, 81, 77}}, {{77, 81, 78}}, {{81, 82, 78}}, {{78, 82, 79}}, {{82, 83, 79}},
	{{80, 84, 81}}, {{84, 85, 81}}, {{81, 85, 82}}, {{85, 86, 82}}, {{82, 86, 83}}, {{86, 87, 83}},
	{{84, 88, 85}}, {{88, 89, 85}}, {{85, 89, 86}}, {{89, 90, 86}}, {{86, 90, 87}}, {{90, 91, 87}},
	{{88, 92, 89}}, {{92, 93, 89}}, {{89, 93, 90}}, {{93, 94, 90}}, {{90, 94, 91}}, {{94, 95, 91}},
	{{92, 96, 93}}, {{96, 97, 93}}, {{93, 97, 94}}, {{97, 98, 94}}, {{94, 98, 95}}, {{98, 99, 95}}
};

const ConstPoint3D TruncatedDomeVolumeManipulator::prototypeOutlinePosition[88] =
{
	{1.0F, 0.0F, 1.0F}, {0.9238795F, 0.3826834F, 1.0F},
	{0.9238795F, 0.3826834F, 1.0F}, {0.7071068F, 0.7071068F, 1.0F},
	{0.7071068F, 0.7071068F, 1.0F}, {0.3826834F, 0.9238795F, 1.0F},
	{0.3826834F, 0.9238795F, 1.0F}, {0.0F, 1.0F, 1.0F},

	{0.0F, 1.0F, 1.0F}, {-0.3826834F, 0.9238795F, 1.0F},
	{-0.3826834F, 0.9238795F, 1.0F}, {-0.7071068F, 0.7071068F, 1.0F},
	{-0.7071068F, 0.7071068F, 1.0F}, {-0.9238795F, 0.3826834F, 1.0F},
	{-0.9238795F, 0.3826834F, 1.0F}, {-1.0F, 0.0F, 1.0F},

	{-1.0F, 0.0F, 1.0F}, {-0.9238795F, -0.3826834F, 1.0F},
	{-0.9238795F, -0.3826834F, 1.0F}, {-0.7071068F, -0.7071068F, 1.0F},
	{-0.7071068F, -0.7071068F, 1.0F}, {-0.3826834F, -0.9238795F, 1.0F},
	{-0.3826834F, -0.9238795F, 1.0F}, {0.0F, -1.0F, 1.0F},

	{0.0F, -1.0F, 1.0F}, {0.3826834F, -0.9238795F, 1.0F},
	{0.3826834F, -0.9238795F, 1.0F}, {0.7071068F, -0.7071068F, 1.0F},
	{0.7071068F, -0.7071068F, 1.0F}, {0.9238795F, -0.3826834F, 1.0F},
	{0.9238795F, -0.3826834F, 1.0F}, {1.0F, 0.0F, 1.0F},

	{1.0F, 0.0F, 0.0F}, {0.9238795F, 0.3826834F, 0.0F},
	{0.9238795F, 0.3826834F, 0.0F}, {0.7071068F, 0.7071068F, 0.0F},
	{0.7071068F, 0.7071068F, 0.0F}, {0.3826834F, 0.9238795F, 0.0F},
	{0.3826834F, 0.9238795F, 0.0F}, {0.0F, 1.0F, 0.0F},

	{0.0F, 1.0F, 0.0F}, {-0.3826834F, 0.9238795F, 0.0F},
	{-0.3826834F, 0.9238795F, 0.0F}, {-0.7071068F, 0.7071068F, 0.0F},
	{-0.7071068F, 0.7071068F, 0.0F}, {-0.9238795F, 0.3826834F, 0.0F},
	{-0.9238795F, 0.3826834F, 0.0F}, {-1.0F, 0.0F, 0.0F},

	{-1.0F, 0.0F, 0.0F}, {-0.9238795F, -0.3826834F, 0.0F},
	{-0.9238795F, -0.3826834F, 0.0F}, {-0.7071068F, -0.7071068F, 0.0F},
	{-0.7071068F, -0.7071068F, 0.0F}, {-0.3826834F, -0.9238795F, 0.0F},
	{-0.3826834F, -0.9238795F, 0.0F}, {0.0F, -1.0F, 0.0F},

	{0.0F, -1.0F, 0.0F}, {0.3826834F, -0.9238795F, 0.0F},
	{0.3826834F, -0.9238795F, 0.0F}, {0.7071068F, -0.7071068F, 0.0F},
	{0.7071068F, -0.7071068F, 0.0F}, {0.9238795F, -0.3826834F, 0.0F},
	{0.9238795F, -0.3826834F, 0.0F}, {1.0F, 0.0F, 0.0F},

	{1.0F, 0.0F, 0.0F}, {1.0F, 0.0F, 0.333333F},
	{1.0F, 0.0F, 0.333333F}, {1.0F, 0.0F, 0.666667F},
	{1.0F, 0.0F, 0.666667F}, {1.0F, 0.0F, 1.0F},
	{0.0F, 1.0F, 0.0F}, {0.0F, 1.0F, 0.333333F},
	{0.0F, 1.0F, 0.333333F}, {0.0F, 1.0F, 0.666667F},
	{0.0F, 1.0F, 0.666667F}, {0.0F, 1.0F, 1.0F},
	{-1.0F, 0.0F, 0.0F}, {-1.0F, 0.0F, 0.333333F},
	{-1.0F, 0.0F, 0.333333F}, {-1.0F, 0.0F, 0.666667F},
	{-1.0F, 0.0F, 0.666667F}, {-1.0F, 0.0F, 1.0F},
	{0.0F, -1.0F, 0.0F}, {0.0F, -1.0F, 0.333333F},
	{0.0F, -1.0F, 0.333333F}, {0.0F, -1.0F, 0.666667F},
	{0.0F, -1.0F, 0.666667F}, {0.0F, -1.0F, 1.0F}
};


SharedVertexBuffer ProjectionVolumeManipulator::interiorIndexBuffer(kVertexBufferIndex | kVertexBufferStatic);
SharedVertexBuffer ProjectionVolumeManipulator::outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferStatic);

const ConstPoint3D ProjectionVolumeManipulator::interiorPosition[16] =
{
	{0.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 1.0F}, {1.0F, -1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {-1.0F, 1.0F, 1.0F}, {1.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {-1.0F, -1.0F, 1.0F}, {-1.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {1.0F, -1.0F, 1.0F}, {-1.0F, -1.0F, 1.0F},
	{-1.0F, -1.0F, 1.0F}, {1.0F, -1.0F, 1.0F}, {1.0F, 1.0F, 1.0F}, {-1.0F, 1.0F, 1.0F}
};

const Triangle ProjectionVolumeManipulator::interiorTriangle[6] =
{
	{{0, 1, 2}}, {{3, 4, 5}}, {{6, 7, 8}}, {{9, 10, 11}},
	{{12, 13, 14}}, {{12, 14, 15}}
};

const ConstPoint3D ProjectionVolumeManipulator::outlinePosition[16] =
{
	{0.0F, 0.0F, 0.0F}, {-1.0F, -1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {1.0F, -1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {1.0F, 1.0F, 1.0F},
	{0.0F, 0.0F, 0.0F}, {-1.0F, 1.0F, 1.0F},

	{-1.0F, -1.0F, 1.0F}, {1.0F, -1.0F, 1.0F},
	{1.0F, -1.0F, 1.0F}, {1.0F, 1.0F, 1.0F},
	{1.0F, 1.0F, 1.0F}, {-1.0F, 1.0F, 1.0F},
	{-1.0F, 1.0F, 1.0F}, {-1.0F, -1.0F, 1.0F}
};


VolumeManipulator::VolumeManipulator(Node *node, RenderType renderType, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) :
		interiorColorAttribute(kAttributeMutable),
		interiorTextureAttribute(textureName),
		interiorRenderable(renderType, kRenderDepthTest | kRenderDepthInhibit),
		outlineColorAttribute(kAttributeMutable),
		outlineTextureAttribute(&EditorManipulator::outlineTextureHeader, EditorManipulator::outlineTextureImage),
		outlineRenderable(kRenderLines, kRenderDepthTest | kRenderDepthInhibit),
		interiorVertexBuffer(kVertexBufferAttribute | kVertexBufferDynamic)
{
	interiorColor = interior;
	outlineColor = outline;
	Unselect();

	interiorRenderable.SetAmbientBlendState(kBlendInterpolate);
	interiorRenderable.SetShaderFlags(kShaderAmbientEffect | kShaderScaleVertex);
	interiorRenderable.SetRenderParameterPointer(&volumeSizeVector);
	interiorRenderable.SetTransformable(node);

	interiorRenderable.SetVertexBuffer(kVertexBufferAttributeArray, &interiorVertexBuffer, sizeof(InteriorVertex));
	interiorRenderable.SetVertexAttributeArray(kArrayPosition, 0, 3);
	interiorRenderable.SetVertexAttributeArray(kArrayTexcoord, sizeof(Point3D), 2);

	interiorAttributeList.Append(&interiorColorAttribute);
	interiorAttributeList.Append(&interiorTextureAttribute);
	interiorRenderable.SetMaterialAttributeList(&interiorAttributeList);

	outlineRenderable.SetAmbientBlendState(kBlendPremultInterp);
	outlineRenderable.SetShaderFlags(kShaderAmbientEffect | kShaderProjectiveTexture);
	outlineRenderable.SetGeometryShaderIndex(kGeometryShaderExpandLineSegment);
	outlineRenderable.SetRenderParameterPointer(&volumeSizeVector);
	outlineRenderable.SetTransformable(node);

	outlineRenderable.SetVertexAttributeArray(kArrayPosition, 0, 3);

	outlineAttributeList.Append(&outlineColorAttribute);
	outlineAttributeList.Append(&outlineTextureAttribute);
	outlineRenderable.SetMaterialAttributeList(&outlineAttributeList);
}

VolumeManipulator::~VolumeManipulator()
{
}

void VolumeManipulator::BuildOutlineVertexBuffer(VertexBuffer *vertexBuffer, int32 vertexCount, const Point3D *position)
{
	vertexBuffer->Establish(sizeof(OutlineVertex) * vertexCount, position);
}

void VolumeManipulator::Select(void)
{
	interiorColorAttribute.SetDiffuseColor(interiorColor);
	outlineColorAttribute.SetDiffuseColor(outlineColor);
}

void VolumeManipulator::Unselect(void)
{
	interiorColorAttribute.SetDiffuseColor(interiorColor * 0.625F);
	outlineColorAttribute.SetDiffuseColor(outlineColor * 0.5F);
}

bool VolumeManipulator::Pick(const Ray *ray, PickData *data) const
{
	Point3D q1 = ray->origin + ray->direction * ray->tmin;
	Point3D q2 = ray->origin + ray->direction * ray->tmax;
	float r = -ray->radius;

	const Point3D *position = interiorPositionArray;
	const Vector3D& size = volumeSizeVector.GetVector3D();

	if (interiorRenderable.GetRenderType() == kRenderIndexedTriangles)
	{
		const Triangle *triangle = interiorTriangleArray;
		int32 primitiveCount = interiorRenderable.GetPrimitiveCount();

		for (machine a = 0; a < primitiveCount; a++)
		{
			Point3D p1 = position[triangle->index[0]] & size;
			Point3D p2 = position[triangle->index[1]] & size;
			Point3D p3 = position[triangle->index[2]] & size;

			Vector3D normal = Normalize((p2 - p1) % (p3 - p1));
			Antivector4D plane(normal, p1);

			float d1 = plane ^ q1;
			if (d1 > 0.0F)
			{
				float d2 = plane ^ q2;
				if (d2 < 0.0F)
				{
					float t = ray->tmin + d1 / (d1 - d2) * (ray->tmax - ray->tmin);
					Point3D q = ray->origin + ray->direction * t;

					Antivector4D k1(normal % (p2 - p1), p1);
					if ((k1 ^ q) * InverseMag(k1.GetAntivector3D()) > r)
					{
						Antivector4D k2(normal % (p3 - p2), p2);
						if ((k2 ^ q) * InverseMag(k2.GetAntivector3D()) > r)
						{
							Antivector4D k3(normal % (p1 - p3), p3);
							if ((k3 ^ q) * InverseMag(k3.GetAntivector3D()) > r)
							{
								data->rayParam = t;
								return (true);
							}
						}
					}
				}
			}

			triangle++;
		}
	}
	else
	{
		int32 primitiveCount = interiorRenderable.GetVertexCount() / 4;

		for (machine a = 0; a < primitiveCount; a++)
		{
			Point3D p1 = position[0] & size;
			Point3D p2 = position[1] & size;
			Point3D p3 = position[2] & size;
			Point3D p4 = position[3] & size;

			Vector3D normal = Normalize((p2 - p1) % (p3 - p1));
			Antivector4D plane(normal, p1);

			float d1 = plane ^ q1;
			if (d1 > 0.0F)
			{
				float d2 = plane ^ q2;
				if (d2 < 0.0F)
				{
					float t = ray->tmin + d1 / (d1 - d2) * (ray->tmax - ray->tmin);
					Point3D q = ray->origin + ray->direction * t;

					Antivector4D k1(normal % (p2 - p1), p1);
					if ((k1 ^ q) * InverseMag(k1.GetAntivector3D()) > r)
					{
						Antivector4D k2(normal % (p3 - p2), p2);
						if ((k2 ^ q) * InverseMag(k2.GetAntivector3D()) > r)
						{
							Antivector4D k3(normal % (p4 - p3), p3);
							if ((k3 ^ q) * InverseMag(k3.GetAntivector3D()) > r)
							{
								Antivector4D k4(normal % (p1 - p4), p4);
								if ((k4 ^ q) * InverseMag(k4.GetAntivector3D()) > r)
								{
									data->rayParam = t;
									return (true);
								}
							}
						}
					}
				}
			}

			position += 4;
		}
	}

	return (false);
}

bool VolumeManipulator::PolygonVisibleInRegion(int32 vertexCount, const Point3D *vertex, const VisibilityRegion *region)
{
	int32 planeCount = region->GetPlaneCount();
	if (planeCount > 0)
	{
		Point3D		vertexArray[2][kMaxPolyhedronFaceCount + 16];
		int8		location[kMaxPolyhedronFaceCount + 16];

		const Antivector4D *planeArray = region->GetPlaneArray();
		vertexCount = Math::ClipPolygon(vertexCount, vertex, planeArray[0], location, vertexArray[0]);
		if (vertexCount == 0)
		{
			return (false);
		}

		int32 parity = 0;
		for (machine a = 1; a < planeCount; a++)
		{
			vertexCount = Math::ClipPolygon(vertexCount, vertexArray[parity], planeArray[a], location, vertexArray[parity ^ 1]);
			if (vertexCount == 0)
			{
				return (false);
			}

			parity ^= 1;
		}
	}

	return (true);
}

bool VolumeManipulator::RegionPick(const Transform4D& worldTransform, const VisibilityRegion *region) const
{
	Point3D		polygon[4];

	const Point3D *position = interiorPositionArray;
	const Vector3D& size = volumeSizeVector.GetVector3D();

	if (interiorRenderable.GetRenderType() == kRenderIndexedTriangles)
	{
		const Triangle *triangle = interiorTriangleArray;
		int32 primitiveCount = interiorRenderable.GetPrimitiveCount();

		for (machine a = 0; a < primitiveCount; a++)
		{
			polygon[0] = worldTransform * (position[triangle->index[0]] & size);
			polygon[1] = worldTransform * (position[triangle->index[1]] & size);
			polygon[2] = worldTransform * (position[triangle->index[2]] & size);

			if (PolygonVisibleInRegion(3, polygon, region))
			{
				return (true);
			}

			triangle++;
		}
	}
	else
	{
		int32 primitiveCount = interiorRenderable.GetVertexCount() / 4;

		for (machine a = 0; a < primitiveCount; a++)
		{
			polygon[0] = worldTransform * (position[0] & size);
			polygon[1] = worldTransform * (position[1] & size);
			polygon[2] = worldTransform * (position[2] & size);
			polygon[3] = worldTransform * (position[3] & size);

			if (PolygonVisibleInRegion(4, polygon, region))
			{
				return (true);
			}

			position += 4;
		}
	}

	return (false);
}

void VolumeManipulator::Render(const ManipulatorRenderData *renderData)
{
	List<Renderable> *renderList = renderData->manipulatorList;
	if (renderList)
	{
		volumeSizeVector.w = renderData->lineScale;

		renderList->Append(&interiorRenderable);
		renderList->Append(&outlineRenderable);
	}
}


PlateVolumeManipulator::PlateVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderQuads, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(4);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 4);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(8);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 8, &outlinePosition[0]);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
}

PlateVolumeManipulator::~PlateVolumeManipulator()
{
	outlineVertexBuffer.Release();
}

void PlateVolumeManipulator::SetPlateSize(const Vector2D& size)
{
	SetVolumeSize(size.x, size.y, 0.0F);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	float x = size.x;
	float y = size.y;
	float dx = 0.5F - x * 0.5F;
	float dy = 0.5F - y * 0.5F;
	x += dx;
	y += dy;

	vertex[0].position = interiorPosition[0];
	vertex[0].texcoord.Set(dx, dy);

	vertex[1].position = interiorPosition[1];
	vertex[1].texcoord.Set(x, dy);

	vertex[2].position = interiorPosition[2];
	vertex[2].texcoord.Set(x, y);

	vertex[3].position = interiorPosition[3];
	vertex[3].texcoord.Set(dx, y);

	interiorVertexBuffer.EndUpdate();
}

void PlateVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, BoundingSphere *sphere)
{
	float x = size.x * 0.5F;
	float y = size.y * 0.5F;

	sphere->SetCenter(x, y, 0.0F);
	sphere->SetRadius(Sqrt(x * x + y * y));
}

Box3D PlateVolumeManipulator::CalculateBoundingBox(const Vector2D& size)
{
	return (Box3D(Zero3D, Point3D(size, 0.0F)));
}

int32 PlateVolumeManipulator::GetHandleTable(const Vector2D& size, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(0.0F, 0.0F, 0.0F);
	handle[1].Set(x * 0.5F, 0.0F, 0.0F);
	handle[2].Set(x, 0.0F, 0.0F);
	handle[3].Set(x, y * 0.5F, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(x * 0.5F, y, 0.0F);
	handle[6].Set(0.0F, y, 0.0F);
	handle[7].Set(0.0F, y * 0.5F, 0.0F);

	return (8);
}

void PlateVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[8] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY,
		kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY,
		kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeX
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 4;
}

bool PlateVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, Vector2D& newSize)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= (handleFlags & kManipulatorHandleNegativeX) ? -2.0F : 2.0F;
			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			resizeData->positionOffset.x = (oldSize.x - newSize.x) * 0.5F;
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= (handleFlags & kManipulatorHandleNegativeY) ? -2.0F : 2.0F;
			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			resizeData->positionOffset.y = (oldSize.y - newSize.y) * 0.5F;
		}

		move = true;
	}
	else
	{
		if (handleFlags & kManipulatorHandlePositiveX)
		{
			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeX)
		{
			newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
			resizeData->positionOffset.x = oldSize.x - newSize.x;
			move = true;
		}

		if (handleFlags & kManipulatorHandlePositiveY)
		{
			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeY)
		{
			newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
			resizeData->positionOffset.y = oldSize.y - newSize.y;
			move = true;
		}
	}

	return (move);
}


DiskVolumeManipulator::DiskVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(16);
	interiorRenderable->SetPrimitiveCount(14);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 16);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(32);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 32, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 14, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

DiskVolumeManipulator::~DiskVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void DiskVolumeManipulator::SetDiskSize(const Vector2D& size)
{
	SetVolumeSize(size.x, size.y, 0.0F);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	const ConstVector2D *trig = Math::GetTrigTable();
	for (machine a = 0; a < 16; a++)
	{
		Vector2D cs = trig[a * 16] & size;
		vertex[a].position = interiorPosition[a];
		vertex[a].texcoord.Set(cs.x + 0.5F, cs.y + 0.5F);
	}

	interiorVertexBuffer.EndUpdate();
}

void DiskVolumeManipulator::CalculateVolumeSphere(float radius, BoundingSphere *sphere)
{
	sphere->SetCenter(Point3D(0.0F, 0.0F, 0.0F));
	sphere->SetRadius(radius);
}

void DiskVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, BoundingSphere *sphere)
{
	sphere->SetCenter(Point3D(0.0F, 0.0F, 0.0F));
	sphere->SetRadius(Fmax(size.x, size.y));
}

Box3D DiskVolumeManipulator::CalculateBoundingBox(float radius)
{
	return (Box3D(Point3D(-radius, -radius, 0.0F), Point3D(radius, radius, 0.0F)));
}

Box3D DiskVolumeManipulator::CalculateBoundingBox(const Vector2D& size)
{
	return (Box3D(Point3D(-size, 0.0F), Point3D(size, 0.0F)));
}

int32 DiskVolumeManipulator::GetHandleTable(float radius, Point3D *handle)
{
	handle[0].Set(radius, 0.0F, 0.0F);
	handle[1].Set(-radius, 0.0F, 0.0F);
	handle[2].Set(0.0F, radius, 0.0F);
	handle[3].Set(0.0F, -radius, 0.0F);

	return (4);
}

int32 DiskVolumeManipulator::GetHandleTable(const Vector2D& size, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(x, 0.0F, 0.0F);
	handle[1].Set(-x, 0.0F, 0.0F);
	handle[2].Set(0.0F, y, 0.0F);
	handle[3].Set(0.0F, -y, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(-x, -y, 0.0F);
	handle[6].Set(-x, y, 0.0F);
	handle[7].Set(x, -y, 0.0F);

	return (8);
}

void DiskVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[8] =
	{
		kManipulatorHandlePositiveX,
		kManipulatorHandleNegativeX,
		kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 1;
}

bool DiskVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float& newRadius)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
	}
	else
	{
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
	}

	return (move);
}

bool DiskVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, Vector2D& newSize)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			if (handleFlags & kManipulatorHandleNegativeX)
			{
				dx = -dx;
			}

			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			if (handleFlags & kManipulatorHandleNegativeY)
			{
				dy = -dy;
			}

			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
	}
	else
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeX)
			{
				newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
				resizeData->positionOffset.x = oldSize.x - newSize.x;
			}
			else
			{
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
				resizeData->positionOffset.x = newSize.x - oldSize.x;
			}
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeY)
			{
				newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
				resizeData->positionOffset.y = oldSize.y - newSize.y;
			}
			else
			{
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
				resizeData->positionOffset.y = newSize.y - oldSize.y;
			}
		}

		move = true;
	}

	return (move);
}


BoxVolumeManipulator::BoxVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderQuads, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(24);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 24);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(24);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 24, &outlinePosition[0]);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
}

BoxVolumeManipulator::~BoxVolumeManipulator()
{
	outlineVertexBuffer.Release();
}

void BoxVolumeManipulator::SetBoxSize(const Vector3D& size)
{
	SetVolumeSize(size.x, size.y, size.z);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();
	for (machine a = 0; a < 24; a++)
	{
		vertex[a].position = interiorPosition[a];
	}

	float x = size.x;
	float y = size.y;
	float z = size.z;
	float dx = 0.5F - x * 0.5F;
	float dy = 0.5F - y * 0.5F;
	float dz = 0.5F - z * 0.5F;
	x += dx;
	y += dy;
	z += dz;

	vertex[0].texcoord.Set(dy, dz);
	vertex[1].texcoord.Set(y, dz);
	vertex[2].texcoord.Set(y, z);
	vertex[3].texcoord.Set(dy, z);

	vertex[4].texcoord.Set(dy, dz);
	vertex[5].texcoord.Set(y, dz);
	vertex[6].texcoord.Set(y, z);
	vertex[7].texcoord.Set(dy, z);

	vertex[8].texcoord.Set(dx, dz);
	vertex[9].texcoord.Set(x, dz);
	vertex[10].texcoord.Set(x, z);
	vertex[11].texcoord.Set(dx, z);

	vertex[12].texcoord.Set(dx, dz);
	vertex[13].texcoord.Set(x, dz);
	vertex[14].texcoord.Set(x, z);
	vertex[15].texcoord.Set(dx, z);

	vertex[16].texcoord.Set(dx, dy);
	vertex[17].texcoord.Set(x, dy);
	vertex[18].texcoord.Set(x, y);
	vertex[19].texcoord.Set(dx, y);

	vertex[20].texcoord.Set(dx, dy);
	vertex[21].texcoord.Set(x, dy);
	vertex[22].texcoord.Set(x, y);
	vertex[23].texcoord.Set(dx, y);

	interiorVertexBuffer.EndUpdate();
}

void BoxVolumeManipulator::CalculateVolumeSphere(const Vector3D& size, BoundingSphere *sphere)
{
	float x = size.x * 0.5F;
	float y = size.y * 0.5F;
	float z = size.z * 0.5F;

	sphere->SetCenter(Point3D(x, y, z));
	sphere->SetRadius(Sqrt(x * x + y * y + z * z));
}

Box3D BoxVolumeManipulator::CalculateBoundingBox(const Vector3D& size)
{
	return (Box3D(Zero3D, Zero3D + size));
}

int32 BoxVolumeManipulator::GetHandleTable(const Vector3D& size, Point3D *handle)
{
	float x = size.x;
	float y = size.y;
	float z = size.z;

	handle[0].Set(0.0F, 0.0F, 0.0F);
	handle[1].Set(x * 0.5F, 0.0F, 0.0F);
	handle[2].Set(x, 0.0F, 0.0F);
	handle[3].Set(x, y * 0.5F, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(x * 0.5F, y, 0.0F);
	handle[6].Set(0.0F, y, 0.0F);
	handle[7].Set(0.0F, y * 0.5F, 0.0F);

	handle[8].Set(0.0F, 0.0F, z);
	handle[9].Set(x * 0.5F, 0.0F, z);
	handle[10].Set(x, 0.0F, z);
	handle[11].Set(x, y * 0.5F, z);
	handle[12].Set(x, y, z);
	handle[13].Set(x * 0.5F, y, z);
	handle[14].Set(0.0F, y, z);
	handle[15].Set(0.0F, y * 0.5F, z);

	z *= 0.5F;
	handle[16].Set(0.0F, 0.0F, z);
	handle[17].Set(x, 0.0F, z);
	handle[18].Set(x, y, z);
	handle[19].Set(0.0F, y, z);

	return (20);
}

void BoxVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[20] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = (index < 16) ? index ^ 12 : index ^ 2;
}

bool BoxVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector3D& oldSize, Vector3D& newSize)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= (handleFlags & kManipulatorHandleNegativeX) ? -2.0F : 2.0F;
			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			resizeData->positionOffset.x = (oldSize.x - newSize.x) * 0.5F;
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= (handleFlags & kManipulatorHandleNegativeY) ? -2.0F : 2.0F;
			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			resizeData->positionOffset.y = (oldSize.y - newSize.y) * 0.5F;
		}

		move = true;
	}
	else
	{
		if (handleFlags & kManipulatorHandlePositiveX)
		{
			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeX)
		{
			newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
			resizeData->positionOffset.x = oldSize.x - newSize.x;
			move = true;
		}

		if (handleFlags & kManipulatorHandlePositiveY)
		{
			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeY)
		{
			newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
			resizeData->positionOffset.y = oldSize.y - newSize.y;
			move = true;
		}
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newSize.z = Fmax(oldSize.z + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newSize.z = Fmax(oldSize.z - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldSize.z - newSize.z;
		move = true;
	}

	return (move);
}


PyramidVolumeManipulator::PyramidVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(16);
	interiorRenderable->SetPrimitiveCount(6);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 16);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(16);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 16, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 6, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

PyramidVolumeManipulator::~PyramidVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void PyramidVolumeManipulator::SetPyramidSize(const Vector2D& size, float height)
{
	SetVolumeSize(size.x, size.y, height);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();
	for (machine a = 0; a < 16; a++)
	{
		vertex[a].position = interiorPosition[a];
	}

	float x = size.x;
	float y = size.y;
	float dx = 0.5F - x * 0.5F;
	float dy = 0.5F - y * 0.5F;
	float dh = 0.5F - height * 0.5F;
	x += dx;
	y += dy;
	height += dh;

	vertex[0].texcoord.Set(dy, dh);
	vertex[1].texcoord.Set(y, dh);
	vertex[2].texcoord.Set(0.5F, height);

	vertex[3].texcoord.Set(dy, dh);
	vertex[4].texcoord.Set(y, dh);
	vertex[5].texcoord.Set(0.5F, height);

	vertex[6].texcoord.Set(dx, dh);
	vertex[7].texcoord.Set(x, dh);
	vertex[8].texcoord.Set(0.5F, height);

	vertex[9].texcoord.Set(dx, dh);
	vertex[10].texcoord.Set(x, dh);
	vertex[11].texcoord.Set(0.5F, height);

	vertex[12].texcoord.Set(dx, dy);
	vertex[13].texcoord.Set(x, dy);
	vertex[14].texcoord.Set(x, y);
	vertex[15].texcoord.Set(dx, y);

	interiorVertexBuffer.EndUpdate();
}

void PyramidVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, BoundingSphere *sphere)
{
	float x = size.x * 0.5F;
	float y = size.y * 0.5F;
	float r = Sqrt(x * x + y * y);

	if (height > r)
	{
		float d = (r * r + height * height) / (height * 2.0F);
		sphere->SetCenter(x, y, height - d);
		sphere->SetRadius(d);
	}
	else
	{
		sphere->SetCenter(x, y, 0.0F);
		sphere->SetRadius(r);
	}
}

Box3D PyramidVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Zero3D, Point3D(size, height)));
}

int32 PyramidVolumeManipulator::GetHandleTable(const Vector2D& size, float height, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(0.0F, 0.0F, 0.0F);
	handle[1].Set(x * 0.5F, 0.0F, 0.0F);
	handle[2].Set(x, 0.0F, 0.0F);
	handle[3].Set(x, y * 0.5F, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(x * 0.5F, y, 0.0F);
	handle[6].Set(0.0F, y, 0.0F);
	handle[7].Set(0.0F, y * 0.5F, 0.0F);

	handle[8].Set(0.0F, 0.0F, height);
	handle[9].Set(x * 0.5F, 0.0F, height);
	handle[10].Set(x, 0.0F, height);
	handle[11].Set(x, y * 0.5F, height);
	handle[12].Set(x, y, height);
	handle[13].Set(x * 0.5F, y, height);
	handle[14].Set(0.0F, y, height);
	handle[15].Set(0.0F, y * 0.5F, height);

	return (16);
}

void PyramidVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[16] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 12;
}

bool PyramidVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, Vector2D& newSize, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= (handleFlags & kManipulatorHandleNegativeX) ? -2.0F : 2.0F;
			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			resizeData->positionOffset.x = (oldSize.x - newSize.x) * 0.5F;
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= (handleFlags & kManipulatorHandleNegativeY) ? -2.0F : 2.0F;
			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			resizeData->positionOffset.y = (oldSize.y - newSize.y) * 0.5F;
		}

		move = true;
	}
	else
	{
		if (handleFlags & kManipulatorHandlePositiveX)
		{
			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeX)
		{
			newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
			resizeData->positionOffset.x = oldSize.x - newSize.x;
			move = true;
		}

		if (handleFlags & kManipulatorHandlePositiveY)
		{
			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeY)
		{
			newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
			resizeData->positionOffset.y = oldSize.y - newSize.y;
			move = true;
		}
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldHeight - newHeight;
		move = true;
	}

	return (move);
}


CylinderVolumeManipulator::CylinderVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(66);
	interiorRenderable->SetPrimitiveCount(60);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 66);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(72);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 72, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 60, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

CylinderVolumeManipulator::~CylinderVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void CylinderVolumeManipulator::SetCylinderSize(const Vector2D& size, float height)
{
	SetVolumeSize(size.x, size.y, height);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	const ConstVector2D *trig = Math::GetTrigTable();
	for (machine a = 0; a < 16; a++)
	{
		const Vector2D& cs = trig[a * 16];
		float x = size.x * cs.x + 0.5F;
		float y = size.y * cs.y + 0.5F;

		vertex[a].position = interiorPosition[a];
		vertex[a].texcoord.Set(x, y);

		vertex[a + 16].position = interiorPosition[a + 16];
		vertex[a + 16].texcoord.Set(x, 1.0F - y);
	}

	float circum = Sqrt(size.x * size.y) * K::tau;
	float dc = 0.5F - circum * 0.5F;
	float dh = 0.5F - height * 0.5F;
	circum *= 0.0625F;

	for (machine a = 0; a < 17; a++)
	{
		float x = (float) a * circum;
		machine i = a * 2 + 32;

		vertex[i].position = interiorPosition[i];
		vertex[i].texcoord.Set(dc + x, dh);

		vertex[i + 1].position = interiorPosition[i + 1];
		vertex[i + 1].texcoord.Set(dc + x, dh + height);
	}

	interiorVertexBuffer.EndUpdate();
}

void CylinderVolumeManipulator::CalculateVolumeSphere(float radius, float height, BoundingSphere *sphere)
{
	float h = height * 0.5F;

	sphere->SetCenter(Point3D(0.0F, 0.0F, h));
	sphere->SetRadius(Sqrt(h * h + radius * radius));
}

void CylinderVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, BoundingSphere *sphere)
{
	float r = Fmax(size.x, size.y);
	float h = height * 0.5F;

	sphere->SetCenter(Point3D(0.0F, 0.0F, h));
	sphere->SetRadius(Sqrt(h * h + r * r));
}

Box3D CylinderVolumeManipulator::CalculateBoundingBox(float radius, float height)
{
	return (Box3D(Point3D(-radius, -radius, 0.0F), Point3D(radius, radius, height)));
}

Box3D CylinderVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Point3D(-size, 0.0F), Point3D(size, height)));
}

int32 CylinderVolumeManipulator::GetHandleTable(float radius, float height, Point3D *handle)
{
	handle[0].Set(radius, 0.0F, 0.0F);
	handle[1].Set(-radius, 0.0F, 0.0F);
	handle[2].Set(0.0F, radius, 0.0F);
	handle[3].Set(0.0F, -radius, 0.0F);
	handle[4].Set(radius, 0.0F, height);
	handle[5].Set(-radius, 0.0F, height);
	handle[6].Set(0.0F, radius, height);
	handle[7].Set(0.0F, -radius, height);

	return (8);
}

int32 CylinderVolumeManipulator::GetHandleTable(const Vector2D& size, float height, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(x, 0.0F, 0.0F);
	handle[1].Set(-x, 0.0F, 0.0F);
	handle[2].Set(0.0F, y, 0.0F);
	handle[3].Set(0.0F, -y, 0.0F);
	handle[4].Set(x, 0.0F, height);
	handle[5].Set(-x, 0.0F, height);
	handle[6].Set(0.0F, y, height);
	handle[7].Set(0.0F, -y, height);

	handle[8].Set(x, y, 0.0F);
	handle[9].Set(-x, -y, 0.0F);
	handle[10].Set(-x, y, 0.0F);
	handle[11].Set(x, -y, 0.0F);
	handle[12].Set(x, y, height);
	handle[13].Set(-x, -y, height);
	handle[14].Set(-x, y, height);
	handle[15].Set(x, -y, height);

	return (16);
}

void CylinderVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[16] =
	{
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 5;
}

bool CylinderVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float oldHeight, float& newRadius, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
	}
	else
	{
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldHeight - newHeight;
		move = true;
	}

	return (move);
}

bool CylinderVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, Vector2D& newSize, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			if (handleFlags & kManipulatorHandleNegativeX)
			{
				dx = -dx;
			}

			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			if (handleFlags & kManipulatorHandleNegativeY)
			{
				dy = -dy;
			}

			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
	}
	else
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeX)
			{
				newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
				resizeData->positionOffset.x = oldSize.x - newSize.x;
			}
			else
			{
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
				resizeData->positionOffset.x = newSize.x - oldSize.x;
			}
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeY)
			{
				newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
				resizeData->positionOffset.y = oldSize.y - newSize.y;
			}
			else
			{
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
				resizeData->positionOffset.y = newSize.y - oldSize.y;
			}
		}

		move = true;
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldHeight - newHeight;
		move = true;
	}

	return (move);
}


ConeVolumeManipulator::ConeVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(49);
	interiorRenderable->SetPrimitiveCount(30);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 49);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(40);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 40, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 30, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

ConeVolumeManipulator::~ConeVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void ConeVolumeManipulator::SetConeSize(const Vector2D& size, float height)
{
	SetVolumeSize(size.x, size.y, height);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	const ConstVector2D *trig = Math::GetTrigTable();
	for (machine a = 0; a < 16; a++)
	{
		const Vector2D& cs = trig[a * 16];
		float x = size.x * cs.x + 0.5F;
		float y = size.y * cs.y + 0.5F;

		vertex[a].position = interiorPosition[a];
		vertex[a].texcoord.Set(x, 1.0F - y);
	}

	float circum = Sqrt(size.x * size.y) * K::tau;
	float dc = 0.5F - circum * 0.5F;
	float dh = 0.5F - height * 0.5F;
	circum *= 0.0625F;
	float dx = circum * 0.5F;

	for (machine a = 0; a < 16; a++)
	{
		float x = (float) a * circum;
		machine i = a * 2 + 16;

		vertex[i].position = interiorPosition[i];
		vertex[i].texcoord.Set(dc + x, dh);

		vertex[i + 1].position = interiorPosition[i + 1];
		vertex[i + 1].texcoord.Set(dc + x + dx, dh + height);
	}

	vertex[48].position = interiorPosition[48];
	vertex[48].texcoord.Set(dc + circum * 16.0F, dh);

	interiorVertexBuffer.EndUpdate();
}

void ConeVolumeManipulator::CalculateVolumeSphere(float radius, float height, BoundingSphere *sphere)
{
	if (height > radius)
	{
		float d = (radius * radius + height * height) / (height * 2.0F);
		sphere->SetCenter(0.0F, 0.0F, height - d);
		sphere->SetRadius(d);
	}
	else
	{
		sphere->SetCenter(0.0F, 0.0F, 0.0F);
		sphere->SetRadius(radius);
	}
}

void ConeVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, BoundingSphere *sphere)
{
	float r = Fmax(size.x, size.y);
	if (height > r)
	{
		float d = (r * r + height * height) / (height * 2.0F);
		sphere->SetCenter(0.0F, 0.0F, height - d);
		sphere->SetRadius(d);
	}
	else
	{
		sphere->SetCenter(0.0F, 0.0F, 0.0F);
		sphere->SetRadius(r);
	}
}

Box3D ConeVolumeManipulator::CalculateBoundingBox(float radius, float height)
{
	return (Box3D(Point3D(-radius, -radius, 0.0F), Point3D(radius, radius, height)));
}

Box3D ConeVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Point3D(-size, 0.0F), Point3D(size, height)));
}

int32 ConeVolumeManipulator::GetHandleTable(float radius, float height, Point3D *handle)
{
	handle[0].Set(radius, 0.0F, 0.0F);
	handle[1].Set(-radius, 0.0F, 0.0F);
	handle[2].Set(0.0F, radius, 0.0F);
	handle[3].Set(0.0F, -radius, 0.0F);
	handle[4].Set(radius, 0.0F, height);
	handle[5].Set(-radius, 0.0F, height);
	handle[6].Set(0.0F, radius, height);
	handle[7].Set(0.0F, -radius, height);

	return (8);
}

int32 ConeVolumeManipulator::GetHandleTable(const Vector2D& size, float height, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(x, 0.0F, 0.0F);
	handle[1].Set(-x, 0.0F, 0.0F);
	handle[2].Set(0.0F, y, 0.0F);
	handle[3].Set(0.0F, -y, 0.0F);
	handle[4].Set(x, 0.0F, height);
	handle[5].Set(-x, 0.0F, height);
	handle[6].Set(0.0F, y, height);
	handle[7].Set(0.0F, -y, height);

	handle[8].Set(x, y, 0.0F);
	handle[9].Set(-x, -y, 0.0F);
	handle[10].Set(-x, y, 0.0F);
	handle[11].Set(x, -y, 0.0F);
	handle[12].Set(x, y, height);
	handle[13].Set(-x, -y, height);
	handle[14].Set(-x, y, height);
	handle[15].Set(x, -y, height);

	return (16);
}

void ConeVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[16] =
	{
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 5;
}

bool ConeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float oldHeight, float& newRadius, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
	}
	else
	{
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldHeight - newHeight;
		move = true;
	}

	return (move);
}

bool ConeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, Vector2D& newSize, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			if (handleFlags & kManipulatorHandleNegativeX)
			{
				dx = -dx;
			}

			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			if (handleFlags & kManipulatorHandleNegativeY)
			{
				dy = -dy;
			}

			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
	}
	else
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeX)
			{
				newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
				resizeData->positionOffset.x = oldSize.x - newSize.x;
			}
			else
			{
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
				resizeData->positionOffset.x = newSize.x - oldSize.x;
			}
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeY)
			{
				newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
				resizeData->positionOffset.y = oldSize.y - newSize.y;
			}
			else
			{
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
				resizeData->positionOffset.y = newSize.y - oldSize.y;
			}
		}

		move = true;
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldHeight - newHeight;
		move = true;
	}

	return (move);
}


SphereVolumeManipulator::SphereVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(151);
	interiorRenderable->SetPrimitiveCount(224);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 151);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(96);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 96, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 224, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

SphereVolumeManipulator::~SphereVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void SphereVolumeManipulator::SetSphereSize(const Vector3D& size)
{
	SetVolumeSize(size.x, size.y, size.z);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	float circum = Sqrt(size.x * size.y) * K::tau_over_16;
	machine k = 0;

	for (machine j = 0; j < 5; j++)
	{
		for (machine i = 0; i < 17; i++)
		{
			const Point3D& p = interiorPosition[k];
			float x = (float) i * circum;
			float y = size.z * p.z;

			vertex[k].position = p;
			vertex[k].texcoord.Set(x, y);

			k++;
		}
	}

	for (machine a = 85; a < 118; a++)
	{
		const Point3D& p = interiorPosition[a];
		float x = size.x * p.x;
		float y = size.y * p.y;

		vertex[a].position = p;
		vertex[a].texcoord.Set(x, y);
	}

	for (machine a = 118; a < 151; a++)
	{
		const Point3D& p = interiorPosition[a];
		float x = size.x * p.x;
		float y = size.y * p.y;

		vertex[a].position = p;
		vertex[a].texcoord.Set(x, 1.0F - y);
	}

	interiorVertexBuffer.EndUpdate();
}

void SphereVolumeManipulator::CalculateVolumeSphere(float radius, BoundingSphere *sphere)
{
	sphere->SetCenter(Zero3D);
	sphere->SetRadius(radius);
}

void SphereVolumeManipulator::CalculateVolumeSphere(const Vector3D& size, BoundingSphere *sphere)
{
	sphere->SetCenter(Zero3D);
	sphere->SetRadius(Fmax(size.x, size.y, size.z));
}

Box3D SphereVolumeManipulator::CalculateBoundingBox(float radius)
{
	return (Box3D(Point3D(-radius, -radius, -radius), Point3D(radius, radius, radius)));
}

Box3D SphereVolumeManipulator::CalculateBoundingBox(const Vector3D& size)
{
	return (Box3D(Zero3D - size, Zero3D + size));
}

int32 SphereVolumeManipulator::GetHandleTable(float radius, Point3D *handle)
{
	handle[0].Set(radius, 0.0F, 0.0F);
	handle[1].Set(-radius, 0.0F, 0.0F);
	handle[2].Set(0.0F, radius, 0.0F);
	handle[3].Set(0.0F, -radius, 0.0F);
	handle[4].Set(0.0F, 0.0F, radius);
	handle[5].Set(0.0F, 0.0F, -radius);

	return (6);
}

int32 SphereVolumeManipulator::GetHandleTable(const Vector3D& size, Point3D *handle)
{
	float x = size.x;
	float y = size.y;
	float z = size.z;

	handle[0].Set(-x, -y, -z);
	handle[1].Set(0.0F, -y, -z);
	handle[2].Set(x, -y, -z);
	handle[3].Set(x, 0.0F, -z);
	handle[4].Set(x, y, -z);
	handle[5].Set(0.0F, y, -z);
	handle[6].Set(-x, y, -z);
	handle[7].Set(-x, 0.0F, -z);

	handle[8].Set(-x, -y, z);
	handle[9].Set(0.0F, -y, z);
	handle[10].Set(x, -y, z);
	handle[11].Set(x, 0.0F, z);
	handle[12].Set(x, y, z);
	handle[13].Set(0.0F, y, z);
	handle[14].Set(-x, y, z);
	handle[15].Set(-x, 0.0F, z);

	handle[16].Set(-x, -y, 0.0F);
	handle[17].Set(x, -y, 0.0F);
	handle[18].Set(x, y, 0.0F);
	handle[19].Set(-x, y, 0.0F);

	return (20);
}

void SphereVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[20] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = (index < 16) ? index ^ 12 : index ^ 2;
}

void SphereVolumeManipulator::GetCircularHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[6] =
	{
		kManipulatorHandlePositiveX,
		kManipulatorHandleNegativeX,
		kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeY,
		kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeZ
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 1;
}

bool SphereVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float& newRadius)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNonzeroY)
	{
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
	}
	else
	{
		if (handleFlags & kManipulatorHandleNegativeZ)
		{
			dz = -dz;
		}

		newRadius = Fmax(oldRadius + dz, kSizeEpsilon);
	}

	return (false);
}

bool SphereVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector3D& oldSize, Vector3D& newSize)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			if (handleFlags & kManipulatorHandleNegativeX)
			{
				dx = -dx;
			}

			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			if (handleFlags & kManipulatorHandleNegativeY)
			{
				dy = -dy;
			}

			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}

		if (handleFlags & kManipulatorHandleNonzeroZ)
		{
			if (handleFlags & kManipulatorHandleNegativeZ)
			{
				dz = -dz;
			}

			newSize.z = Fmax(oldSize.z + dz, kSizeEpsilon);
		}
	}
	else
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeX)
			{
				newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
				resizeData->positionOffset.x = oldSize.x - newSize.x;
			}
			else
			{
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
				resizeData->positionOffset.x = newSize.x - oldSize.x;
			}
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeY)
			{
				newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
				resizeData->positionOffset.y = oldSize.y - newSize.y;
			}
			else
			{
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
				resizeData->positionOffset.y = newSize.y - oldSize.y;
			}
		}

		if (handleFlags & kManipulatorHandleNonzeroZ)
		{
			dz *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeZ)
			{
				newSize.z = Fmax(oldSize.z - dz, kSizeEpsilon);
				resizeData->positionOffset.z = oldSize.z - newSize.z;
			}
			else
			{
				newSize.z = Fmax(oldSize.z + dz, kSizeEpsilon);
				resizeData->positionOffset.z = newSize.z - oldSize.z;
			}
		}

		move = true;
	}

	return (move);
}


DomeVolumeManipulator::DomeVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(100);
	interiorRenderable->SetPrimitiveCount(126);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 100);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(64);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 64, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 126, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

DomeVolumeManipulator::~DomeVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void DomeVolumeManipulator::SetDomeSize(const Vector3D& size)
{
	SetVolumeSize(size.x, size.y, size.z);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	float circum = Sqrt(size.x * size.y) * K::tau_over_16;
	machine k = 0;

	for (machine j = 0; j < 3; j++)
	{
		for (machine i = 0; i < 17; i++)
		{
			const Point3D& p = interiorPosition[k];
			float x = (float) i * circum;
			float y = size.z * p.z;

			vertex[k].position = p;
			vertex[k].texcoord.Set(x, y);

			k++;
		}
	}

	for (machine a = 51; a < 84; a++)
	{
		const Point3D& p = interiorPosition[a];
		float x = size.x * p.x;
		float y = size.y * p.y;

		vertex[a].position = p;
		vertex[a].texcoord.Set(x, y);
	}

	const ConstVector2D *trig = Math::GetTrigTable();
	for (machine a = 0; a < 16; a++)
	{
		const Vector2D& cs = trig[a * 16];
		float x = size.x * cs.x + 0.5F;
		float y = size.y * cs.y + 0.5F;

		vertex[a + 84].position = interiorPosition[a + 84];
		vertex[a + 84].texcoord.Set(x, 1.0F - y);
	}

	interiorVertexBuffer.EndUpdate();
}

void DomeVolumeManipulator::CalculateVolumeSphere(float radius, BoundingSphere *sphere)
{
	sphere->SetCenter(Zero3D);
	sphere->SetRadius(radius);
}

void DomeVolumeManipulator::CalculateVolumeSphere(const Vector3D& size, BoundingSphere *sphere)
{
	sphere->SetCenter(Zero3D);
	sphere->SetRadius(Fmax(size.x, size.y, size.z));
}

Box3D DomeVolumeManipulator::CalculateBoundingBox(float radius)
{
	return (Box3D(Point3D(-radius, -radius, 0.0F), Point3D(radius, radius, radius)));
}

Box3D DomeVolumeManipulator::CalculateBoundingBox(const Vector3D& size)
{
	return (Box3D(Point3D(-size.x, -size.y, 0.0F), Zero3D + size));
}

int32 DomeVolumeManipulator::GetHandleTable(float radius, Point3D *handle)
{
	handle[0].Set(radius, 0.0F, 0.0F);
	handle[1].Set(-radius, 0.0F, 0.0F);
	handle[2].Set(0.0F, radius, 0.0F);
	handle[3].Set(0.0F, -radius, 0.0F);
	handle[4].Set(radius, 0.0F, radius);
	handle[5].Set(-radius, 0.0F, radius);
	handle[6].Set(0.0F, radius, radius);
	handle[7].Set(0.0F, -radius, radius);

	return (8);
}

int32 DomeVolumeManipulator::GetHandleTable(const Vector3D& size, Point3D *handle)
{
	float x = size.x;
	float y = size.y;
	float z = size.z;

	handle[0].Set(x, 0.0F, 0.0F);
	handle[1].Set(-x, 0.0F, 0.0F);
	handle[2].Set(0.0F, y, 0.0F);
	handle[3].Set(0.0F, -y, 0.0F);
	handle[4].Set(x, 0.0F, z);
	handle[5].Set(-x, 0.0F, z);
	handle[6].Set(0.0F, y, z);
	handle[7].Set(0.0F, -y, z);

	handle[8].Set(x, y, 0.0F);
	handle[9].Set(-x, -y, 0.0F);
	handle[10].Set(-x, y, 0.0F);
	handle[11].Set(x, -y, 0.0F);
	handle[12].Set(x, y, z);
	handle[13].Set(-x, -y, z);
	handle[14].Set(-x, y, z);
	handle[15].Set(x, -y, z);

	return (16);
}

void DomeVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[16] =
	{
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = index ^ 5;
}

bool DomeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float& newRadius)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
	}
	else
	{
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newRadius = Fmax(oldRadius + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newRadius = Fmax(oldRadius - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldRadius - newRadius;
		move = true;
	}

	return (move);
}

bool DomeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector3D& oldSize, Vector3D& newSize)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->resizeFlags & kManipulatorResizeCenter)
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			if (handleFlags & kManipulatorHandleNegativeX)
			{
				dx = -dx;
			}

			newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			if (handleFlags & kManipulatorHandleNegativeY)
			{
				dy = -dy;
			}

			newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
		}
	}
	else
	{
		if (handleFlags & kManipulatorHandleNonzeroX)
		{
			dx *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeX)
			{
				newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
				resizeData->positionOffset.x = oldSize.x - newSize.x;
			}
			else
			{
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
				resizeData->positionOffset.x = newSize.x - oldSize.x;
			}
		}

		if (handleFlags & kManipulatorHandleNonzeroY)
		{
			dy *= 0.5F;

			if (handleFlags & kManipulatorHandleNegativeY)
			{
				newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
				resizeData->positionOffset.y = oldSize.y - newSize.y;
			}
			else
			{
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
				resizeData->positionOffset.y = newSize.y - oldSize.y;
			}
		}

		move = true;
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newSize.z = Fmax(oldSize.z + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newSize.z = Fmax(oldSize.z - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldSize.z - newSize.z;
		move = true;
	}

	return (move);
}


CapsuleVolumeManipulator::CapsuleVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) :
		VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName),
		outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferDynamic)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(168);
	interiorRenderable->SetPrimitiveCount(256);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 168);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(136);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));
	outlineVertexBuffer.Establish(sizeof(OutlineVertex) * 136);

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 256, interiorTriangle);
	}

	SetInteriorPositionArray(interiorPosition);
	SetInteriorTriangleArray(interiorTriangle);
}

CapsuleVolumeManipulator::~CapsuleVolumeManipulator()
{
	interiorIndexBuffer.Release();
}

void CapsuleVolumeManipulator::SetCapsuleSize(const Vector3D& size, float height)
{
	SetVolumeSize(size.x, size.y, 1.0F);

	const Vector4D *protoPosition = &prototypeInteriorPosition[0];
	Point3D *position = interiorPosition;
	for (machine a = 0; a < 168; a++)
	{
		position->Set(protoPosition->x, protoPosition->y, protoPosition->z * size.z + protoPosition->w * height);
		protoPosition++;
		position++;
	}

	volatile InteriorVertex *restrict interiorVertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();

	float circum = Sqrt(size.x * size.y) * K::tau_over_16;
	float dh = 0.5F - height * 0.5F;
	machine k = 0;

	for (machine j = 0; j < 6; j++)
	{
		for (machine i = 0; i < 17; i++)
		{
			const Point3D& p = interiorPosition[k];

			interiorVertex[k].position = p;
			interiorVertex[k].texcoord.Set((float) i * circum, dh + p.z);

			k++;
		}
	}

	for (machine a = 102; a < 135; a++)
	{
		const Point3D& p = interiorPosition[a];
		float x = size.x * p.x;
		float y = size.y * p.y;

		interiorVertex[a].position = p;
		interiorVertex[a].texcoord.Set(x, y);
	}

	for (machine a = 135; a < 168; a++)
	{
		const Point3D& p = interiorPosition[a];
		float x = size.x * p.x;
		float y = size.y * p.y;

		interiorVertex[a].position = p;
		interiorVertex[a].texcoord.Set(x, 1.0F - y);
	}

	interiorVertexBuffer.EndUpdate();

	volatile OutlineVertex *restrict outlineVertex = outlineVertexBuffer.BeginUpdate<OutlineVertex>();

	protoPosition = &prototypeOutlinePosition[0];
	for (machine a = 0; a < 136; a++)
	{
		outlineVertex[a].position.Set(protoPosition->x, protoPosition->y, protoPosition->z * size.z + protoPosition->w * height);
		protoPosition++;
	}

	outlineVertexBuffer.EndUpdate();
}

void CapsuleVolumeManipulator::CalculateVolumeSphere(float radius, float height, BoundingSphere *sphere)
{
	float h = height * 0.5F;
	sphere->SetCenter(Point3D(0.0F, 0.0F, h));
	sphere->SetRadius(radius + h);
}

void CapsuleVolumeManipulator::CalculateVolumeSphere(const Vector3D& size, float height, BoundingSphere *sphere)
{
	float h = height * 0.5F;
	sphere->SetCenter(Point3D(0.0F, 0.0F, h));
	sphere->SetRadius(Fmax(size.x, size.y, size.z + h));
}

Box3D CapsuleVolumeManipulator::CalculateBoundingBox(float radius, float height)
{
	return (Box3D(Point3D(-radius, -radius, -radius), Point3D(radius, radius, radius + height)));
}

Box3D CapsuleVolumeManipulator::CalculateBoundingBox(const Vector3D& size, float height)
{
	return (Box3D(Zero3D - size, Point3D(size.x, size.y, size.z + height)));
}

int32 CapsuleVolumeManipulator::GetHandleTable(float radius, float height, Point3D *handle)
{
	handle[0].Set(radius, 0.0F, 0.0F);
	handle[1].Set(-radius, 0.0F, 0.0F);
	handle[2].Set(0.0F, radius, 0.0F);
	handle[3].Set(0.0F, -radius, 0.0F);
	handle[4].Set(radius, 0.0F, height);
	handle[5].Set(-radius, 0.0F, height);
	handle[6].Set(0.0F, radius, height);
	handle[7].Set(0.0F, -radius, height);

	return (8);
}

int32 CapsuleVolumeManipulator::GetHandleTable(const Vector3D& size, float height, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(x, 0.0F, 0.0F);
	handle[1].Set(-x, 0.0F, 0.0F);
	handle[2].Set(0.0F, y, 0.0F);
	handle[3].Set(0.0F, -y, 0.0F);
	handle[4].Set(x, 0.0F, height);
	handle[5].Set(-x, 0.0F, height);
	handle[6].Set(0.0F, y, height);
	handle[7].Set(0.0F, -y, height);

	handle[8].Set(x, y, 0.0F);
	handle[9].Set(-x, -y, 0.0F);
	handle[10].Set(-x, y, 0.0F);
	handle[11].Set(x, -y, 0.0F);
	handle[12].Set(x, y, height);
	handle[13].Set(-x, -y, height);
	handle[14].Set(-x, y, height);
	handle[15].Set(x, -y, height);

	handle[16].Set(0.0F, 0.0F, -size.z);
	handle[17].Set(0.0F, 0.0F, height + size.z);

	return (18);
}

void CapsuleVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[18] =
	{
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveZ
	};

	handleData->handleFlags = handleFlags[index];

	if (index < 16)
	{
		handleData->oppositeIndex = index ^ 5;
	}
	else
	{
		handleData->oppositeIndex = index ^ 1;
	}
}

bool CapsuleVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float oldHeight, float& newRadius, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
	}
	else
	{
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
	}

	if (handleFlags & kManipulatorHandlePositiveZ)
	{
		newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
	}
	else if (handleFlags & kManipulatorHandleNegativeZ)
	{
		newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
		resizeData->positionOffset.z = oldHeight - newHeight;
		move = true;
	}

	return (move);
}

bool CapsuleVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector3D& oldSize, float oldHeight, Vector3D& newSize, float& newHeight)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	bool move = false;
	unsigned_int32 handleFlags = resizeData->handleFlags;

	if (resizeData->handleIndex < 16)
	{
		if (resizeData->resizeFlags & kManipulatorResizeCenter)
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				if (handleFlags & kManipulatorHandleNegativeX)
				{
					dx = -dx;
				}

				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				if (handleFlags & kManipulatorHandleNegativeY)
				{
					dy = -dy;
				}

				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			}
		}
		else
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				dx *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeX)
				{
					newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
					resizeData->positionOffset.x = oldSize.x - newSize.x;
				}
				else
				{
					newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
					resizeData->positionOffset.x = newSize.x - oldSize.x;
				}
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				dy *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeY)
				{
					newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
					resizeData->positionOffset.y = oldSize.y - newSize.y;
				}
				else
				{
					newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
					resizeData->positionOffset.y = newSize.y - oldSize.y;
				}
			}

			move = true;
		}

		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
			resizeData->positionOffset.z = oldHeight - newHeight;
			move = true;
		}
	}
	else
	{
		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newSize.z = Fmax(oldSize.z + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newSize.z = Fmax(oldSize.z - dz, kSizeEpsilon);
		}
	}

	return (move);
}


TruncatedPyramidVolumeManipulator::TruncatedPyramidVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) :
		VolumeManipulator(node, kRenderQuads, interior, outline, textureName),
		outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferDynamic)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(24);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 24);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(24);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));
	outlineVertexBuffer.Establish(sizeof(OutlineVertex) * 24);

	SetInteriorPositionArray(interiorPosition);
}

TruncatedPyramidVolumeManipulator::~TruncatedPyramidVolumeManipulator()
{
}

void TruncatedPyramidVolumeManipulator::SetTruncatedPyramidSize(const Vector2D& size, float height, float ratio)
{
	SetVolumeSize(1.0F, 1.0F, height);

	const Point3D *protoPosition = &prototypeInteriorPosition[0];
	Point3D *position = interiorPosition;
	for (machine a = 0; a < 24; a++)
	{
		float r = protoPosition->z * (ratio - 1.0F) + 1.0F;
		position->Set(((protoPosition->x - 0.5F) * r + 0.5F) * size.x, ((protoPosition->y - 0.5F) * r + 0.5F) * size.y, protoPosition->z);
		protoPosition++;
		position++;
	}

	volatile InteriorVertex *restrict interiorVertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();
	for (machine a = 0; a < 24; a++)
	{
		interiorVertex[a].position = interiorPosition[a];
	}

	float x1 = size.x;
	float y1 = size.y;
	float z = height;
	float dx1 = 0.5F - x1 * 0.5F;
	float dy1 = 0.5F - y1 * 0.5F;
	float dz = 0.5F - z * 0.5F;
	x1 += dx1;
	y1 += dy1;
	z += dz;

	float dx2 = (dx1 - 0.5F) * ratio + 0.5F;
	float dy2 = (dy1 - 0.5F) * ratio + 0.5F;
	float x2 = (x1 - 0.5F) * ratio + 0.5F;
	float y2 = (y1 - 0.5F) * ratio + 0.5F;

	interiorVertex[0].texcoord.Set(dy1, dz);
	interiorVertex[1].texcoord.Set(y1, dz);
	interiorVertex[2].texcoord.Set(y2, z);
	interiorVertex[3].texcoord.Set(dy2, z);

	interiorVertex[4].texcoord.Set(dy1, dz);
	interiorVertex[5].texcoord.Set(y1, dz);
	interiorVertex[6].texcoord.Set(y2, z);
	interiorVertex[7].texcoord.Set(dy2, z);

	interiorVertex[8].texcoord.Set(dx1, dz);
	interiorVertex[9].texcoord.Set(x1, dz);
	interiorVertex[10].texcoord.Set(x2, z);
	interiorVertex[11].texcoord.Set(dx2, z);

	interiorVertex[12].texcoord.Set(dx1, dz);
	interiorVertex[13].texcoord.Set(x1, dz);
	interiorVertex[14].texcoord.Set(x2, z);
	interiorVertex[15].texcoord.Set(dx2, z);

	interiorVertex[16].texcoord.Set(dx2, dy2);
	interiorVertex[17].texcoord.Set(x2, dy2);
	interiorVertex[18].texcoord.Set(x2, y2);
	interiorVertex[19].texcoord.Set(dx2, y2);

	interiorVertex[20].texcoord.Set(dx1, dy1);
	interiorVertex[21].texcoord.Set(x1, dy1);
	interiorVertex[22].texcoord.Set(x1, y1);
	interiorVertex[23].texcoord.Set(dx1, y1);

	interiorVertexBuffer.EndUpdate();

	volatile OutlineVertex *restrict outlineVertex = outlineVertexBuffer.BeginUpdate<OutlineVertex>();

	protoPosition = &prototypeOutlinePosition[0];
	for (machine a = 0; a < 24; a++)
	{
		float r = protoPosition->z * (ratio - 1.0F) + 1.0F;
		outlineVertex[a].position.Set(((protoPosition->x - 0.5F) * r + 0.5F) * size.x, ((protoPosition->y - 0.5F) * r + 0.5F) * size.y, protoPosition->z);
		protoPosition++;
	}

	outlineVertexBuffer.EndUpdate();
}

void TruncatedPyramidVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, float ratio, BoundingSphere *sphere)
{
	float sx = size.x * 0.5F;
	float sy = size.y * 0.5F;
	float s2 = sx * sx + sy * sy;
	float z = FmaxZero((s2 * (ratio * ratio - 1.0F) + height * height) / (height * 2.0F));

	sphere->SetCenter(sx, sy, z);
	sphere->SetRadius(Sqrt(s2 + z * z));
}

Box3D TruncatedPyramidVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Zero3D, Point3D(size, height)));
}

int32 TruncatedPyramidVolumeManipulator::GetHandleTable(const Vector2D& size, float height, float ratio, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(0.0F, 0.0F, 0.0F);
	handle[1].Set(x * 0.5F, 0.0F, 0.0F);
	handle[2].Set(x, 0.0F, 0.0F);
	handle[3].Set(x, y * 0.5F, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(x * 0.5F, y, 0.0F);
	handle[6].Set(0.0F, y, 0.0F);
	handle[7].Set(0.0F, y * 0.5F, 0.0F);

	handle[8].Set(0.0F, 0.0F, height);
	handle[9].Set(x * 0.5F, 0.0F, height);
	handle[10].Set(x, 0.0F, height);
	handle[11].Set(x, y * 0.5F, height);
	handle[12].Set(x, y, height);
	handle[13].Set(x * 0.5F, y, height);
	handle[14].Set(0.0F, y, height);
	handle[15].Set(0.0F, y * 0.5F, height);

	float r = (1.0F + ratio) * 0.5F;
	handle[16].Set(r * x, r * y, height);

	return (17);
}

void TruncatedPyramidVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[17] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		0
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = (index < 20) ? ((index < 16) ? index ^ 12 : index ^ 2) : kHandleOrigin;
}

bool TruncatedPyramidVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, float oldRatio, Vector2D& newSize, float& newHeight, float& newRatio)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;
	float dz = resizeData->resizeDelta.z;

	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags != 0)
	{
		bool move = false;

		if (resizeData->resizeFlags & kManipulatorResizeCenter)
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				dx *= (handleFlags & kManipulatorHandleNegativeX) ? -2.0F : 2.0F;
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
				resizeData->positionOffset.x = (oldSize.x - newSize.x) * 0.5F;
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				dy *= (handleFlags & kManipulatorHandleNegativeY) ? -2.0F : 2.0F;
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
				resizeData->positionOffset.y = (oldSize.y - newSize.y) * 0.5F;
			}

			move = true;
		}
		else
		{
			if (handleFlags & kManipulatorHandlePositiveX)
			{
				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			}
			else if (handleFlags & kManipulatorHandleNegativeX)
			{
				newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
				resizeData->positionOffset.x = oldSize.x - newSize.x;
				move = true;
			}

			if (handleFlags & kManipulatorHandlePositiveY)
			{
				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			}
			else if (handleFlags & kManipulatorHandleNegativeY)
			{
				newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
				resizeData->positionOffset.y = oldSize.y - newSize.y;
				move = true;
			}
		}

		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
			resizeData->positionOffset.z = oldHeight - newHeight;
			move = true;
		}

		return (move);
	}

	float dr = (dx + dy) * InverseMag(oldSize);
	newRatio = Clamp(oldRatio + dr, kSizeEpsilon, 1.0F - kSizeEpsilon);
	return (false);
}


TruncatedConeVolumeManipulator::TruncatedConeVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) :
		VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName),
		outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferDynamic)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(66);
	interiorRenderable->SetPrimitiveCount(60);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 66);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(72);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));
	outlineVertexBuffer.Establish(sizeof(OutlineVertex) * 72);

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 60, interiorTriangle);
	}

	SetInteriorPositionArray(interiorPosition);
	SetInteriorTriangleArray(interiorTriangle);
}

TruncatedConeVolumeManipulator::~TruncatedConeVolumeManipulator()
{
	interiorIndexBuffer.Release();
}

void TruncatedConeVolumeManipulator::SetTruncatedConeSize(const Vector2D& size, float height, float ratio)
{
	SetVolumeSize(1.0F, 1.0F, height);

	const Point3D *protoPosition = &prototypeInteriorPosition[0];
	Point3D *position = interiorPosition;
	for (machine a = 0; a < 66; a++)
	{
		float r = protoPosition->z * (ratio - 1.0F) + 1.0F;
		position->Set(protoPosition->x * size.x * r, protoPosition->y * size.y * r, protoPosition->z);
		protoPosition++;
		position++;
	}

	volatile InteriorVertex *restrict interiorVertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();
	for (machine a = 0; a < 66; a++)
	{
		interiorVertex[a].position = interiorPosition[a];
	}

	const ConstVector2D *trig = Math::GetTrigTable();
	for (machine a = 0; a < 16; a++)
	{
		const Vector2D& cs = trig[a * 16];
		float x = size.x * cs.x + 0.5F;
		float y = size.y * cs.y + 0.5F;

		interiorVertex[a].texcoord.Set(x, y);
		interiorVertex[a + 16].texcoord.Set(x, 1.0F - y);
	}

	float circum = Sqrt(size.x * size.y) * K::tau;
	float dc = 0.5F - circum * 0.5F;
	float dh = 0.5F - height * 0.5F;
	circum *= 0.0625F;

	for (machine a = 0; a < 17; a++)
	{
		float x = (float) a * circum;
		interiorVertex[a * 2 + 32].texcoord.Set(dc + x, dh);
		interiorVertex[a * 2 + 33].texcoord.Set(dc + x, dh + height);
	}

	interiorVertexBuffer.EndUpdate();

	volatile OutlineVertex *restrict outlineVertex = outlineVertexBuffer.BeginUpdate<OutlineVertex>();

	protoPosition = &prototypeOutlinePosition[0];
	for (machine a = 0; a < 72; a++)
	{
		float r = protoPosition->z * (ratio - 1.0F) + 1.0F;
		outlineVertex[a].position.Set(protoPosition->x * size.x * r, protoPosition->y * size.y * r, protoPosition->z);
		protoPosition++;
	}

	outlineVertexBuffer.EndUpdate();
}

void TruncatedConeVolumeManipulator::CalculateVolumeSphere(float radius, float height, float ratio, BoundingSphere *sphere)
{
	float z = FmaxZero((radius * radius * (ratio * ratio - 1.0F) + height * height) / (height * 2.0F));

	sphere->SetCenter(0.0F, 0.0F, z);
	sphere->SetRadius(Sqrt(radius * radius + z * z));
}

void TruncatedConeVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, float ratio, BoundingSphere *sphere)
{
	float s = Fmax(size.x, size.y);
	float z = FmaxZero((s * s * (ratio * ratio - 1.0F) + height * height) / (height * 2.0F));

	sphere->SetCenter(0.0F, 0.0F, z);
	sphere->SetRadius(Sqrt(s * s + z * z));
}

Box3D TruncatedConeVolumeManipulator::CalculateBoundingBox(float radius, float height)
{
	return (Box3D(Point3D(-radius, -radius, 0.0F), Point3D(radius, radius, height)));
}

Box3D TruncatedConeVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Point3D(-size, 0.0F), Point3D(size, height)));
}

int32 TruncatedConeVolumeManipulator::GetHandleTable(float radius, float height, float ratio, Point3D *handle)
{
	handle[0].Set(-radius, -radius, 0.0F);
	handle[1].Set(0.0F, -radius, 0.0F);
	handle[2].Set(radius, -radius, 0.0F);
	handle[3].Set(radius, 0.0F, 0.0F);
	handle[4].Set(radius, radius, 0.0F);
	handle[5].Set(0.0F, radius, 0.0F);
	handle[6].Set(-radius, radius, 0.0F);
	handle[7].Set(-radius, 0.0F, 0.0F);

	handle[8].Set(-radius, -radius, height);
	handle[9].Set(0.0F, -radius, height);
	handle[10].Set(radius, -radius, height);
	handle[11].Set(radius, 0.0F, height);
	handle[12].Set(radius, radius, height);
	handle[13].Set(0.0F, radius, height);
	handle[14].Set(-radius, radius, height);
	handle[15].Set(-radius, 0.0F, height);

	float x = radius * ratio * K::sqrt_2_over_2;
	handle[16].Set(x, x, height);

	return (17);
}

int32 TruncatedConeVolumeManipulator::GetHandleTable(const Vector2D& size, float height, float ratio, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(-x, -y, 0.0F);
	handle[1].Set(0.0F, -y, 0.0F);
	handle[2].Set(x, -y, 0.0F);
	handle[3].Set(x, 0.0F, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(0.0F, y, 0.0F);
	handle[6].Set(-x, y, 0.0F);
	handle[7].Set(-x, 0.0F, 0.0F);

	handle[8].Set(-x, -y, height);
	handle[9].Set(0.0F, -y, height);
	handle[10].Set(x, -y, height);
	handle[11].Set(x, 0.0F, height);
	handle[12].Set(x, y, height);
	handle[13].Set(0.0F, y, height);
	handle[14].Set(-x, y, height);
	handle[15].Set(-x, 0.0F, height);

	x *= ratio * K::sqrt_2_over_2;
	y *= ratio * K::sqrt_2_over_2;
	handle[16].Set(x, y, height);

	return (17);
}

void TruncatedConeVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[17] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		0
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = (index < 16) ? index ^ 12 : kHandleOrigin;
}

bool TruncatedConeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float oldHeight, float oldRatio, float& newRadius, float& newHeight, float& newRatio)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags != 0)
	{
		float dz = resizeData->resizeDelta.z;

		if (resizeData->resizeFlags & kManipulatorResizeCenter)
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				if (handleFlags & kManipulatorHandleNegativeX)
				{
					dx = -dx;
				}

				newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				if (handleFlags & kManipulatorHandleNegativeY)
				{
					dy = -dy;
				}

				newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
			}
		}
		else
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				dx *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeX)
				{
					newRadius = Fmax(oldRadius - dx, kSizeEpsilon);
					resizeData->positionOffset.x = oldRadius - newRadius;
				}
				else
				{
					newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
					resizeData->positionOffset.x = newRadius - oldRadius;
				}
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				dy *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeY)
				{
					newRadius = Fmax(oldRadius - dy, kSizeEpsilon);
					resizeData->positionOffset.y = oldRadius - newRadius;
				}
				else
				{
					newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
					resizeData->positionOffset.y = newRadius - oldRadius;
				}
			}
		}

		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
			resizeData->positionOffset.z = oldHeight - newHeight;
		}

		return (true);
	}

	float dr = (dx + dy) / oldRadius;
	newRatio = Clamp(oldRatio + dr, kSizeEpsilon, 1.0F - kSizeEpsilon);
	return (false);
}

bool TruncatedConeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, float oldRatio, Vector2D& newSize, float& newHeight, float& newRatio)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags != 0)
	{
		float dz = resizeData->resizeDelta.z;

		if (resizeData->resizeFlags & kManipulatorResizeCenter)
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				if (handleFlags & kManipulatorHandleNegativeX)
				{
					dx = -dx;
				}

				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				if (handleFlags & kManipulatorHandleNegativeY)
				{
					dy = -dy;
				}

				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			}
		}
		else
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				dx *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeX)
				{
					newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
					resizeData->positionOffset.x = oldSize.x - newSize.x;
				}
				else
				{
					newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
					resizeData->positionOffset.x = newSize.x - oldSize.x;
				}
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				dy *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeY)
				{
					newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
					resizeData->positionOffset.y = oldSize.y - newSize.y;
				}
				else
				{
					newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
					resizeData->positionOffset.y = newSize.y - oldSize.y;
				}
			}
		}

		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
			resizeData->positionOffset.z = oldHeight - newHeight;
		}

		return (true);
	}

	float dr = (dx + dy) * InverseMag(oldSize);
	newRatio = Clamp(oldRatio + dr, kSizeEpsilon, 1.0F - kSizeEpsilon);
	return (false);
}


TruncatedDomeVolumeManipulator::TruncatedDomeVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) :
		VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName),
		outlineVertexBuffer(kVertexBufferAttribute | kVertexBufferDynamic)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(100);
	interiorRenderable->SetPrimitiveCount(124);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 100);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(88);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));
	outlineVertexBuffer.Establish(sizeof(OutlineVertex) * 88);

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 124, interiorTriangle);
	}

	SetInteriorPositionArray(interiorPosition);
	SetInteriorTriangleArray(interiorTriangle);
}

TruncatedDomeVolumeManipulator::~TruncatedDomeVolumeManipulator()
{
	interiorIndexBuffer.Release();
}

void TruncatedDomeVolumeManipulator::SetTruncatedDomeSize(const Vector2D& size, float height, float ratio)
{
	SetVolumeSize(1.0F, 1.0F, height);

	float s = (1.0F - ratio * ratio);

	const Point3D *protoPosition = &prototypeInteriorPosition[0];
	Point3D *position = interiorPosition;
	for (machine a = 0; a < 100; a++)
	{
		float z = protoPosition->z;
		float r = Sqrt(1.0F - z * z * s);
		position->Set(protoPosition->x * size.x * r, protoPosition->y * size.y * r, z);
		protoPosition++;
		position++;
	}

	volatile InteriorVertex *restrict interiorVertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();
	for (machine a = 0; a < 100; a++)
	{
		interiorVertex[a].position = interiorPosition[a];
	}

	const ConstVector2D *trig = Math::GetTrigTable();
	for (machine a = 0; a < 16; a++)
	{
		const Vector2D& cs = trig[a * 16];
		float x = size.x * cs.x + 0.5F;
		float y = size.y * cs.y + 0.5F;

		interiorVertex[a].texcoord.Set(x, y);
		interiorVertex[a + 16].texcoord.Set(x, 1.0F - y);
	}

	float circum = Sqrt(size.x * size.y) * K::tau;
	float dc = 0.5F - circum * 0.5F;
	float dh = 0.5F - height * 0.5F;
	circum *= 0.0625F;

	for (machine a = 0; a < 17; a++)
	{
		float x = (float) a * circum;
		machine i = a * 4 + 32;

		interiorVertex[i].texcoord.Set(dc + x, dh);
		interiorVertex[i + 1].texcoord.Set(dc + x, dh + height * 0.333333F);
		interiorVertex[i + 2].texcoord.Set(dc + x, dh + height * 0.666667F);
		interiorVertex[i + 3].texcoord.Set(dc + x, dh + height);
	}

	interiorVertexBuffer.EndUpdate();

	volatile OutlineVertex *restrict outlineVertex = outlineVertexBuffer.BeginUpdate<OutlineVertex>();

	protoPosition = &prototypeOutlinePosition[0];
	for (machine a = 0; a < 88; a++)
	{
		float z = protoPosition->z;
		float r = Sqrt(1.0F - z * z * s);
		outlineVertex[a].position.Set(protoPosition->x * size.x * r, protoPosition->y * size.y * r, z);
		protoPosition++;
	}

	outlineVertexBuffer.EndUpdate();
}

void TruncatedDomeVolumeManipulator::CalculateVolumeSphere(float radius, float height, float ratio, BoundingSphere *sphere)
{
	float z = FmaxZero((radius * radius * (ratio * ratio - 1.0F) + height * height) / (height * 2.0F));

	sphere->SetCenter(0.0F, 0.0F, z);
	sphere->SetRadius(Sqrt(radius * radius + z * z));
}

void TruncatedDomeVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, float ratio, BoundingSphere *sphere)
{
	float s = Fmax(size.x, size.y);
	float z = FmaxZero((s * s * (ratio * ratio - 1.0F) + height * height) / (height * 2.0F));

	sphere->SetCenter(0.0F, 0.0F, z);
	sphere->SetRadius(Sqrt(s * s + z * z));
}

Box3D TruncatedDomeVolumeManipulator::CalculateBoundingBox(float radius, float height)
{
	return (Box3D(Point3D(-radius, -radius, 0.0F), Point3D(radius, radius, height)));
}

Box3D TruncatedDomeVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Point3D(-size, 0.0F), Point3D(size, height)));
}

int32 TruncatedDomeVolumeManipulator::GetHandleTable(float radius, float height, float ratio, Point3D *handle)
{
	handle[0].Set(-radius, -radius, 0.0F);
	handle[1].Set(0.0F, -radius, 0.0F);
	handle[2].Set(radius, -radius, 0.0F);
	handle[3].Set(radius, 0.0F, 0.0F);
	handle[4].Set(radius, radius, 0.0F);
	handle[5].Set(0.0F, radius, 0.0F);
	handle[6].Set(-radius, radius, 0.0F);
	handle[7].Set(-radius, 0.0F, 0.0F);

	handle[8].Set(-radius, -radius, height);
	handle[9].Set(0.0F, -radius, height);
	handle[10].Set(radius, -radius, height);
	handle[11].Set(radius, 0.0F, height);
	handle[12].Set(radius, radius, height);
	handle[13].Set(0.0F, radius, height);
	handle[14].Set(-radius, radius, height);
	handle[15].Set(-radius, 0.0F, height);

	float x = radius * ratio * K::sqrt_2_over_2;
	handle[16].Set(x, x, height);

	return (17);
}

int32 TruncatedDomeVolumeManipulator::GetHandleTable(const Vector2D& size, float height, float ratio, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(-x, -y, 0.0F);
	handle[1].Set(0.0F, -y, 0.0F);
	handle[2].Set(x, -y, 0.0F);
	handle[3].Set(x, 0.0F, 0.0F);
	handle[4].Set(x, y, 0.0F);
	handle[5].Set(0.0F, y, 0.0F);
	handle[6].Set(-x, y, 0.0F);
	handle[7].Set(-x, 0.0F, 0.0F);

	handle[8].Set(-x, -y, height);
	handle[9].Set(0.0F, -y, height);
	handle[10].Set(x, -y, height);
	handle[11].Set(x, 0.0F, height);
	handle[12].Set(x, y, height);
	handle[13].Set(0.0F, y, height);
	handle[14].Set(-x, y, height);
	handle[15].Set(-x, 0.0F, height);

	x *= ratio * K::sqrt_2_over_2;
	y *= ratio * K::sqrt_2_over_2;
	handle[16].Set(x, y, height);

	return (17);
}

void TruncatedDomeVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[17] =
	{
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeZ,
		kManipulatorHandleNegativeX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandleNegativeY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveY | kManipulatorHandlePositiveZ,
		kManipulatorHandleNegativeX | kManipulatorHandlePositiveZ,
		0
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = (index < 16) ? index ^ 12 : kHandleOrigin;
}

bool TruncatedDomeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, float oldRadius, float oldHeight, float oldRatio, float& newRadius, float& newHeight, float& newRatio)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags != 0)
	{
		float dz = resizeData->resizeDelta.z;

		if (resizeData->resizeFlags & kManipulatorResizeCenter)
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				if (handleFlags & kManipulatorHandleNegativeX)
				{
					dx = -dx;
				}

				newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				if (handleFlags & kManipulatorHandleNegativeY)
				{
					dy = -dy;
				}

				newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
			}
		}
		else
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				dx *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeX)
				{
					newRadius = Fmax(oldRadius - dx, kSizeEpsilon);
					resizeData->positionOffset.x = oldRadius - newRadius;
				}
				else
				{
					newRadius = Fmax(oldRadius + dx, kSizeEpsilon);
					resizeData->positionOffset.x = newRadius - oldRadius;
				}
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				dy *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeY)
				{
					newRadius = Fmax(oldRadius - dy, kSizeEpsilon);
					resizeData->positionOffset.y = oldRadius - newRadius;
				}
				else
				{
					newRadius = Fmax(oldRadius + dy, kSizeEpsilon);
					resizeData->positionOffset.y = newRadius - oldRadius;
				}
			}
		}

		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
			resizeData->positionOffset.z = oldHeight - newHeight;
		}

		return (true);
	}

	float dr = (dx + dy) / oldRadius;
	newRatio = Clamp(oldRatio + dr, kSizeEpsilon, 1.0F - kSizeEpsilon);
	return (false);
}

bool TruncatedDomeVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, float oldRatio, Vector2D& newSize, float& newHeight, float& newRatio)
{
	float dx = resizeData->resizeDelta.x;
	float dy = resizeData->resizeDelta.y;

	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags != 0)
	{
		float dz = resizeData->resizeDelta.z;

		if (resizeData->resizeFlags & kManipulatorResizeCenter)
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				if (handleFlags & kManipulatorHandleNegativeX)
				{
					dx = -dx;
				}

				newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				if (handleFlags & kManipulatorHandleNegativeY)
				{
					dy = -dy;
				}

				newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
			}
		}
		else
		{
			if (handleFlags & kManipulatorHandleNonzeroX)
			{
				dx *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeX)
				{
					newSize.x = Fmax(oldSize.x - dx, kSizeEpsilon);
					resizeData->positionOffset.x = oldSize.x - newSize.x;
				}
				else
				{
					newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
					resizeData->positionOffset.x = newSize.x - oldSize.x;
				}
			}

			if (handleFlags & kManipulatorHandleNonzeroY)
			{
				dy *= 0.5F;

				if (handleFlags & kManipulatorHandleNegativeY)
				{
					newSize.y = Fmax(oldSize.y - dy, kSizeEpsilon);
					resizeData->positionOffset.y = oldSize.y - newSize.y;
				}
				else
				{
					newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
					resizeData->positionOffset.y = newSize.y - oldSize.y;
				}
			}
		}

		if (handleFlags & kManipulatorHandlePositiveZ)
		{
			newHeight = Fmax(oldHeight + dz, kSizeEpsilon);
		}
		else if (handleFlags & kManipulatorHandleNegativeZ)
		{
			newHeight = Fmax(oldHeight - dz, kSizeEpsilon);
			resizeData->positionOffset.z = oldHeight - newHeight;
		}

		return (true);
	}

	float dr = (dx + dy) * InverseMag(oldSize);
	newRatio = Clamp(oldRatio + dr, kSizeEpsilon, 1.0F - kSizeEpsilon);
	return (false);
}


ProjectionVolumeManipulator::ProjectionVolumeManipulator(Node *node, const ColorRGBA& interior, const ColorRGBA& outline, const char *textureName) : VolumeManipulator(node, kRenderIndexedTriangles, interior, outline, textureName)
{
	Renderable *interiorRenderable = GetInteriorRenderable();
	interiorRenderable->SetVertexCount(16);
	interiorRenderable->SetPrimitiveCount(6);
	interiorRenderable->SetVertexBuffer(kVertexBufferIndexArray, &interiorIndexBuffer);
	interiorVertexBuffer.Establish(sizeof(InteriorVertex) * 16);

	Renderable *outlineRenderable = GetOutlineRenderable();
	outlineRenderable->SetVertexCount(16);
	outlineRenderable->SetVertexBuffer(kVertexBufferAttributeArray, &outlineVertexBuffer, sizeof(OutlineVertex));

	if (outlineVertexBuffer.Retain() == 1)
	{
		BuildOutlineVertexBuffer(&outlineVertexBuffer, 16, &outlinePosition[0]);
	}

	if (interiorIndexBuffer.Retain() == 1)
	{
		interiorIndexBuffer.Establish(sizeof(Triangle) * 6, interiorTriangle);
	}

	SetInteriorPositionArray(&interiorPosition[0]);
	SetInteriorTriangleArray(interiorTriangle);
}

ProjectionVolumeManipulator::~ProjectionVolumeManipulator()
{
	interiorIndexBuffer.Release();
	outlineVertexBuffer.Release();
}

void ProjectionVolumeManipulator::SetProjectionSize(const Vector2D& size, float height)
{
	SetVolumeSize(size.x, size.y, height);

	volatile InteriorVertex *restrict vertex = interiorVertexBuffer.BeginUpdate<InteriorVertex>();
	for (machine a = 0; a < 16; a++)
	{
		vertex[a].position = interiorPosition[a];
	}

	float x = size.x;
	float y = size.y;
	float dx = 0.5F - size.x * 0.5F;
	float dy = 0.5F - size.y * 0.5F;
	float dz = 0.5F - height * 0.5F;
	x += dx;
	y += dy;
	height += dz;

	vertex[0].texcoord.Set(0.5F, height);
	vertex[1].texcoord.Set(dy, dz);
	vertex[2].texcoord.Set(y, dz);

	vertex[3].texcoord.Set(0.5F, height);
	vertex[4].texcoord.Set(dx, dz);
	vertex[5].texcoord.Set(x, dz);

	vertex[6].texcoord.Set(0.5F, height);
	vertex[7].texcoord.Set(dy, dz);
	vertex[8].texcoord.Set(y, dz);

	vertex[9].texcoord.Set(0.5F, height);
	vertex[10].texcoord.Set(dx, dz);
	vertex[11].texcoord.Set(x, dz);

	vertex[12].texcoord.Set(dx, dy);
	vertex[13].texcoord.Set(x, dy);
	vertex[14].texcoord.Set(x, y);
	vertex[15].texcoord.Set(dx, y);

	interiorVertexBuffer.EndUpdate();
}

void ProjectionVolumeManipulator::CalculateVolumeSphere(const Vector2D& size, float height, BoundingSphere *sphere)
{
	float x = size.x;
	float y = size.y;
	float r = Sqrt(x * x + y * y);

	if (height > r)
	{
		float d = (r * r + height * height) / (height * 2.0F);
		sphere->SetCenter(Point3D(0.0F, 0.0F, d));
		sphere->SetRadius(d);
	}
	else
	{
		sphere->SetCenter(Point3D(0.0F, 0.0F, height));
		sphere->SetRadius(r);
	}
}

Box3D ProjectionVolumeManipulator::CalculateBoundingBox(const Vector2D& size, float height)
{
	return (Box3D(Point3D(-size, 0.0F), Point3D(size, height)));
}

int32 ProjectionVolumeManipulator::GetHandleTable(const Vector2D& size, float height, Point3D *handle)
{
	float x = size.x;
	float y = size.y;

	handle[0].Set(x, 0.0F, height);
	handle[1].Set(0.0F, y, height);
	handle[2].Set(-x, 0.0F, height);
	handle[3].Set(0.0F, -y, height);
	return (4);
}

void ProjectionVolumeManipulator::GetHandleData(int32 index, ManipulatorHandleData *handleData)
{
	static const unsigned_int32 handleFlags[4] =
	{
		kManipulatorHandlePositiveX,
		kManipulatorHandlePositiveY,
		kManipulatorHandleNegativeX,
		kManipulatorHandleNegativeY
	};

	handleData->handleFlags = handleFlags[index];
	handleData->oppositeIndex = kHandleOrigin;
}

bool ProjectionVolumeManipulator::Resize(const ManipulatorResizeData *resizeData, const Vector2D& oldSize, float oldHeight, Vector2D& newSize, float& newHeight)
{
	unsigned_int32 handleFlags = resizeData->handleFlags;
	if (handleFlags & kManipulatorHandleNonzeroX)
	{
		float dx = resizeData->resizeDelta.x;
		if (handleFlags & kManipulatorHandleNegativeX)
		{
			dx = -dx;
		}

		newSize.x = Fmax(oldSize.x + dx, kSizeEpsilon);
	}
	else
	{
		float dy = resizeData->resizeDelta.y;
		if (handleFlags & kManipulatorHandleNegativeY)
		{
			dy = -dy;
		}

		newSize.y = Fmax(oldSize.y + dy, kSizeEpsilon);
	}

	if (!(resizeData->resizeFlags & kManipulatorResizeConstrain))
	{
		float dz = resizeData->resizeDelta.z;
		newHeight = Fmax((oldHeight + dz), kSizeEpsilon);
	}

	return (false);
}

// ZYUQURM
